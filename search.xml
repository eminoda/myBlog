<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>怎么通过 XHR 方式来处理图片资源的响应</title>
      <link href="/legacy/2021/12/23/xhr-response-type/"/>
      <url>/legacy/2021/12/23/xhr-response-type/</url>
      
        <content type="html"><![CDATA[<h1 id="前端为何要解析图片资源"><a href="#前端为何要解析图片资源" class="headerlink" title="前端为何要解析图片资源"></a>前端为何要解析图片资源</h1><p>通常对于前端开发者来说，页面 <strong>HTML</strong> 中通过 <strong>img</strong> 标签来内嵌图片资源是家常便饭了，如果需要资源文件的下载，往往由后端提供一个下载链接，然后通过 <strong>a</strong> 标签进行“无脑”跳转即可。</p><p>但真实的场景往往更需要前端不得不通过 <strong>XHR</strong> 方式来获取图片资源，比如：</p><ul><li>请求需要 <strong>token</strong> 授权，而 <strong>img</strong> 标签可没法自定义 <strong>header</strong></li><li>业务上需要前端整合资源做下载功能</li><li>…</li></ul><p>对于刚入门前端的开发来说，这可比原先要复杂多了。这篇将说明如何通过 XHR 来请求图片资源，如果你经验丰富可以给我提点宝贵意见，在此真心地希望所有人能有所收获。</p><h1 id="如何通过-XHR-来解析图片资源"><a href="#如何通过-XHR-来解析图片资源" class="headerlink" title="如何通过 XHR 来解析图片资源"></a>如何通过 XHR 来解析图片资源</h1><p>先说下思路：</p><ol><li>通过 XHR 来发送图片资源的请求，定义 <strong>responseType</strong> 来约定响应回来的内容。</li><li>如果是图片预览，借助 <strong>Blob</strong> 生成图片的地址， <strong>img</strong> 引用该值作为 <strong>src</strong> 即可。</li><li>如果是下载，则通过 <strong>a</strong> 标签的 <strong>download</strong> 属性来触发浏览器下载功能。</li></ol><h2 id="有哪几种-XHR-responseType"><a href="#有哪几种-XHR-responseType" class="headerlink" title="有哪几种 XHR responseType"></a>有哪几种 XHR responseType</h2><p>平时常听到的 <strong>Ajax</strong> 这词，就是通过 <strong>XHR（XMLHttpRequest）</strong> 对象得以实现的。在 <strong>XHR</strong> 中有个 <strong>responseType</strong> 属性，依靠它可以更改服务端的响应类型。</p><p><strong>responseType</strong> 共有如下可选值：</p><ul><li>text: DOMString 对象中的文本</li><li>arraybuffer: 二进制数据的 ArrayBuffer 对象</li><li>blob: 二进制数据的 Blob 对象</li><li>json: 返回数据转 JSON 对象</li><li>document: HTML 的 Document 对象</li><li>ms-stream: （ie 专属）</li></ul><p>我们先看下：浏览器直接访问一个图片地址和 <strong>img</strong> 标签内嵌图片地址，他们返回头信息区别：</p><img src="/legacy/2021/12/23/xhr-response-type/responseType-browser.png" class="" title="浏览器直接请求"><img src="/legacy/2021/12/23/xhr-response-type/responseType-image.png" class="" title="img标签内嵌"><p>这两种方式都依靠浏览器和 <strong>img</strong> 标签的特性约定了 <strong>Accept</strong> 接收内容的类型，并且都展示出了图片。而我们都不能在此之上针对最开始说的业务场景做什么特别处理，那怎么通过 <strong>XHR</strong> 方式来展示图片呢？</p><p>先看下，直接使用 <strong>axios</strong> 默认配置请求图片地址有什么效果（不设置 responseType）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imageSrc = <span class="string">"http://127.0.0.1:3000/image/google.png"</span>;</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .get(imageSrc, &#123;</span><br><span class="line">    responseType: <span class="string">""</span>, <span class="comment">//text</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = response.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"text:"</span>, data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>默认 <strong>responseType</strong> 不定义的话和 <strong>text</strong> 是一个效果，返回的图片内容被转成了字符串，也就是下面看到的乱码：</p><img src="/legacy/2021/12/23/xhr-response-type/responseType-text.png" class="" title="xhr直接请求"><p>显而易见，也只有 <strong>responseType</strong> 为 <strong>arraybuffer</strong> 或者 blob 时才能得到二进制的“原始数据”。</p><h2 id="解析二进制数据"><a href="#解析二进制数据" class="headerlink" title="解析二进制数据"></a>解析二进制数据</h2><p>我们选用相对复杂的 <strong>arraybuffer</strong> 进行示例：</p><p>首先将 <strong>responseType</strong> 设置为 <strong>arraybuffer</strong> 进行请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(imageSrc, &#123;</span><br><span class="line">    responseType: <span class="string">"arraybuffer"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arraybuffer = response.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"arraybuffer:"</span>, arraybuffer);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>响应后，我们将得到 <strong>ArrayBuffer</strong> 对象类型的二进制字节数组：</p><img src="/legacy/2021/12/23/xhr-response-type/responseType-arraybuffer.png" class="" title="arraybuffer请求"><p>这个 <strong>ArrayBuffer</strong> 不能直接操作，需要转为 <strong>TypeArray</strong> 类型数组。再通过 <strong>String.fromCharCode</strong> 将字节数据转为 <strong>ASCII 码</strong>（即普通字符串）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arraybuffer);</span><br><span class="line"><span class="keyword">const</span> str = bytes.reduce(<span class="function">(<span class="params">acc, byte</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc + <span class="built_in">String</span>.fromCharCode(byte);</span><br><span class="line">&#125;, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>得到普通字符串后，调用 <strong>window.btoa</strong> 方法，即可转为 <strong>base64</strong> 数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> base64 = <span class="built_in">window</span>.btoa(str);</span><br><span class="line"><span class="comment">// iVBORw0KGgo.....wAAAAAElFTkSuQmCC</span></span><br><span class="line">showToPage(<span class="string">"data:image/png;base64,"</span> + base64);</span><br></pre></td></tr></table></figure><p>最后，页面 <strong>img</strong> 标签前加上 <strong>base64</strong> 前缀即可展示：</p><img src="/legacy/2021/12/23/xhr-response-type/responseType-base64.png" class="" title="base64图片展示"><p><strong>经过三步，我们通过 arraybuffer 方式解析了图片，那有什么简化办法呢？</strong></p><p>肯定是有的：</p><p>如果还是选择 <strong>arraybuffer</strong> 方式，对于支持 <strong>Blob</strong> <strong>对象的浏览器环境来说，ArrayBuffer</strong> 对象可以直接转成 <strong>Blob</strong>，然后通过 <strong>URL.createObjectURL</strong> 直接在内存创建该图片资源的引用地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(imageSrc, &#123;</span><br><span class="line">    responseType: <span class="string">"arraybuffer"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arraybuffer = response.data;</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([arraybuffer], &#123; <span class="attr">type</span>: <span class="string">"image/png"</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">    showToPage(objectURL);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><img src="/legacy/2021/12/23/xhr-response-type/responseType-blob.png" class="" title="blob图片展示"><p>也可以选择 <strong>responseType</strong> 为 <strong>blob</strong> 方式，响应回来的数据直接就是 <strong>blob</strong> 类型，直接生成 <strong>objectURL</strong> 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(imageSrc, &#123;</span><br><span class="line">    responseType: <span class="string">"blob"</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> blob = response.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"blob:"</span>, blob); <span class="comment">//  Blob &#123;size: 4026, type: 'image/png'&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> objectURL = URL.createObjectURL(blob);</span><br><span class="line">    showToPage(objectURL);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="题外话：a-标签的下载"><a href="#题外话：a-标签的下载" class="headerlink" title="题外话：a 标签的下载"></a>题外话：a 标签的下载</h2><p>对于一个图片的资源地址来说，浏览器直接访问是会预览该图片的，而不是出现下载弹框。另外，业务上为了实现追踪文件的下载进度这样的功能，我们借助 <strong>XHR</strong> 的 <strong>progress</strong> 就会很容易。</p><p>不考虑浏览器兼容问题，我们可以通过 <strong>a</strong> 标签的 <strong>download</strong> 来实现，直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 objectURL 后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">  a.href = url;</span><br><span class="line">  a.download = <span class="built_in">Date</span>.now() + <span class="string">".png"</span>;</span><br><span class="line">  a.style.display = <span class="string">"none"</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">  a.click();</span><br><span class="line">  URL.revokeObjectURL(a.href); <span class="comment">// 释放 objectURL</span></span><br><span class="line">  a.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/12/23/xhr-response-type/a-download.png" class="" title="a标签下载"><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><strong>responseType</strong> 只是一个很简单的属性值，一般来说手头上的框架中都有已有相关功能的封装，而对于繁忙我们来说很容易忽视这些基本特性。</p><p>抛砖引玉，本篇到此也只说了些皮毛，像 arraybuffer 和 blog 的区别，浏览器对于大文件下载兼容性都没有涉及。</p><p>虽然社区都有成熟的插件，但这些都需要在业务中投入时间来实践尝试，毕竟要知其所以然。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xhr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CROS 和 OPTIOINS</title>
      <link href="/legacy/2021/10/20/cors-and-options/"/>
      <url>/legacy/2021/10/20/cors-and-options/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相关跨域等概念，都能在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">CORS MDN</a> 找到对应的说明描述。</p><p>本篇会针对几个知识点做说明，并结合代码示例做一些实操，加深理解（而不是跟着百度人云亦云）。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p></blockquote><p>简单说，当我们访问一个网站时，浏览器会对源地址的不同部分（协议://域名:端口）做检查。比如防止利用它源的存储信息（Cookies…）做不安全的用途。</p><h2 id="跨域-CORS"><a href="#跨域-CORS" class="headerlink" title="跨域 CORS"></a>跨域 CORS</h2><p>但凡被浏览器识别为不同源，浏览器都会认为是跨域，默认是不允许的。</p><p>比如：试图在 <a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 中，请求 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> 的资源会出现如下错误：</p><img src="/legacy/2021/10/20/cors-and-options/cors-error.png" class="" title="跨域错误"><p>这也是前端 100% 在接口调试中会遇到的问题。</p><p><strong>同源和跨域的判断规则</strong></p><p>当前浏览器访问地址：<a href="http://domain/url" target="_blank" rel="noopener">http://domain/url</a></p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://domain/other" target="_blank" rel="noopener">http://domain/other</a></td><td>同源</td><td>地址不同</td></tr><tr><td><a href="http://domain2" target="_blank" rel="noopener">http://domain2</a></td><td>跨域</td><td>域名不同</td></tr><tr><td><a href="http://domain:8080" target="_blank" rel="noopener">http://domain:8080</a></td><td>跨域</td><td>端口不同</td></tr><tr><td><a href="https://domain" target="_blank" rel="noopener">https://domain</a></td><td>跨域</td><td>协议不同</td></tr></tbody></table><h2 id="简单请求和复杂请求"><a href="#简单请求和复杂请求" class="headerlink" title="简单请求和复杂请求"></a>简单请求和复杂请求</h2><p>相信都会在浏览器的 Network 中看到两个同样地址的请求，有没有想过这是为什么呢？这是因为在请求中，会分为 <strong>简单请求</strong> 和 <strong>复杂请求</strong> 。</p><p><strong>简单请求</strong>：满足如下条件的，将不会触发跨域检查：</p><ul><li>请求方法为：<strong>GET</strong> 、<strong>POST</strong> 、 <strong>HEAD</strong></li><li>请求头：<strong>Accept</strong>、<strong>Accept-Language</strong>、<strong>Content-Language</strong>、<strong>Content-Type</strong></li></ul><p>其中 <strong>Content-Type</strong> 限定为 ：text/plain、multipart/form-data、application/x-www-form-urlencoded</p><p>我们可以更改同源规则，看下如下示例：</p><blockquote><p><a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> 下，请求 <a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a> 不同端口的地址</p></blockquote><img src="/legacy/2021/10/20/cors-and-options/easy-request-1.png" class="" title="简单请求"><p>域名不同，这已经跨域了。但由于请求方法为 <strong>GET</strong>，符合 <strong>简单请求</strong>，请求将正常工作。</p><p><strong>复杂请求</strong>：不满足简单请求的都为复杂请求。在发送请求前，会使用 <strong>options</strong> 方法发起一个 <strong>预检请求（Preflight）</strong> 到服务器，以获知服务器是否允许该实际请求。</p><p>模拟一个跨域请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 端口不同，content-type 也非限定值</span></span><br><span class="line">axios.post(</span><br><span class="line">  <span class="string">'http://127.0.0.1:3000/test/cors'</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>能看到在请求之前浏览器会事先发起一个 <strong>Preflight 预检请求</strong>：</p><img src="/legacy/2021/10/20/cors-and-options/options-1.png" class="" title="Preflight"><p>这个 <strong>预检请求</strong> 的请求方法为 <strong>options</strong>，同时会包含 <strong>Access-Control-xxx</strong> 的请求头：</p><img src="/legacy/2021/10/20/cors-and-options/options-2.png" class="" title="options请求信息"><p>当然，此时服务端没有做跨域处理（示例使用 express 起的服务，预检请求默认响应 200），就会出现浏览器 CORS 的错误警告。</p><img src="/legacy/2021/10/20/cors-and-options/cors-error.png" class="" title="跨域错误"><h1 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h1><p>对于跨域，前端再熟悉不过，百度搜索能找到一堆解决方法，关键词不是 <strong>JSONP</strong>，或者添加些 <strong>Access-Control-XXX</strong> 响应头。</p><p>本篇将详细说下后一种方式，姑且称为：服务端解决方案。</p><h2 id="为-options-添加响应头"><a href="#为-options-添加响应头" class="headerlink" title="为 options 添加响应头"></a>为 options 添加响应头</h2><p>以 <strong>express</strong> 举例，首先对 <strong>OPTIONS</strong> 方法的请求添加这些响应头，它将根据告诉浏览器根据这些属性进行跨域限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, PUT, POST, DELETE, OPTIONS'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'content-type'</span>);</span><br><span class="line">    res.status(<span class="number">200</span>).end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你不对 <strong>预检接口</strong> 做正确的设置，那么后续一切都是徒劳。</p><p>打个比方：如果 <strong>Access-Control-Allow-Methods</strong> 只设置了 <strong>POST</strong>，如果客户端请求方法为 <strong>PUT</strong>，那么最终会出现跨域异常，并会指出 <strong>PUT</strong> 没有在预检请求中的 <strong>Access-Control-Allow-Methods</strong> 出现：</p><img src="/legacy/2021/10/20/cors-and-options/cors-methods.png" class="" title="跨域方法错误"><p>所以，以后读懂跨域异常对于正确的添加服务端响应信息非常重要。另外：<strong>GET、POST、HEAD</strong> 属于简单请求的方法，所以即使不在 <strong>Access-Control-Allow-Methods</strong> 定义也不碍事（如果不对请指出）</p><h2 id="正式的跨域请求"><a href="#正式的跨域请求" class="headerlink" title="正式的跨域请求"></a>正式的跨域请求</h2><p>随后对我们代码发出的请求额外添加跨域响应头（这需要和前面的预检接口一致）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// http://127.0.0.1:3000/test/cors</span></span><br><span class="line">  res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后能看到我们等请求正常请求到了：</p><img src="/legacy/2021/10/20/cors-and-options/cors-success.png" class="" title="跨域请求"><h1 id="对于跨域请求头的说明"><a href="#对于跨域请求头的说明" class="headerlink" title="对于跨域请求头的说明"></a>对于跨域请求头的说明</h1><p>上例出现了我们经常见到的三个：<strong>Access-Control-Allow-Origin</strong>，<strong>Access-Control-Allow-Methods</strong>，<strong>Access-Control-Allow-Headers</strong>。</p><p>参考 <strong>cors</strong> 库，另外还有其他用于预检请求的响应头：</p><table><thead><tr><th>头属性</th><th>作用</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>判断源地址（协议://域名:端口）</td></tr><tr><td>Access-Control-Allow-Methods</td><td>限定方法（GET,HEAD,PUT,PATCH,POST,DELETE）</td></tr><tr><td>Access-Control-Allow-Headers</td><td>限定请求头（content-type）</td></tr><tr><td>Access-Control-Max-Age</td><td>预检请求的缓存时间（单位为秒，-1 不缓存）</td></tr><tr><td>Access-Control-Expose-Headers</td><td>授权客户端能获取到的响应头</td></tr><tr><td>Access-Control-Request-Headers</td><td>客户端生成的请求头</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>限定客户端可以携带敏感信息</td></tr><tr><td>Vary</td><td>定义可变化的头，防止浏览器缓存</td></tr></tbody></table><p>下面将对上面这些头做个说明。</p><h2 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h2><p>在 <strong>预检请求</strong> 和 <strong>正常请求</strong> 告知浏览器被允许的源。支持通配符“*”，但不支持以逗号“,”分割的多源填写方式。</p><p>如果尝试些多个域名，则会出现如下错误：</p><blockquote><p>Response to preflight request doesn’t pass access control check: The ‘Access-Control-Allow-Origin’ header contains multiple values ‘aaa,bbb’, but only one is allowed.</p></blockquote><img src="/legacy/2021/10/20/cors-and-options/cors-access-orgin.png" class="" title="多源错误"><p>另外，也不建议 <strong>Access-Control-Allow-Origin</strong> 以通配符方式定义，这样会增加安全隐患，最好以请求方的 <strong>origin</strong> 来赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = req.headers.origin;</span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin || <span class="string">'*'</span>);</span><br><span class="line"><span class="comment">// 因为会随着客户端请求的 Origin 变化，所以标识 Vary，让浏览器不要缓存</span></span><br><span class="line">res.setHeader(<span class="string">'Vary'</span>, <span class="string">'Origin'</span>);</span><br></pre></td></tr></table></figure><h2 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h2><p>被允许的 <strong>Http</strong> 方法，按照需要填写，支持多个，例如： <strong>GET</strong> , <strong>HEAD</strong> , <strong>PUT</strong> , <strong>PATCH</strong> , <strong>POST</strong> , <strong>DELETE</strong> 。</p><p>由于判断 <strong>简单请求</strong> 之一的 <strong>HTTP</strong> 方法默认为 <strong>GET</strong> ， <strong>POST</strong> ， <strong>HEAD</strong> ，所以这些即使不在 <strong>Access-Control-Allow-Methods</strong> 约定，浏览器也是支持的。</p><p>比如：如果服务端定义 <strong>PUT</strong> 方法，而客户端发送的方法为 <strong>DELETE</strong>，则会出现如下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>Method DELETE is not allowed by Access-Control-Allow-Methods in preflight response.</p></blockquote><img src="/legacy/2021/10/20/cors-and-options/cors-access-method.png" class="" title="方法错误"><h2 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h2><p>在 <strong>预检接口</strong> 告知客户端允许的请求头。</p><p>像 <strong>简单请求</strong> 约定的请求头默认支持： <strong>Accept</strong> 、 <strong>Accept-Language</strong> 、 <strong>Content-Language</strong> 、 <strong>Content-Type</strong> （<strong>text/plain、multipart/form-data、application/x-www-form-urlencoded</strong>）</p><p>如果客户端的请求头不在定义范围内，则会报错：</p><blockquote><p>Request header field abc is not allowed by Access-Control-Allow-Headers in preflight response.</p></blockquote><img src="/legacy/2021/10/20/cors-and-options/cors-access-headers.png" class="" title="请求头错误"><p>需要将此头调整为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'content-type, abc'</span>);</span><br></pre></td></tr></table></figure><h2 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h2><p>定义 <strong>预检接口</strong> 告知客户端允许的请求头可以缓存多久。</p><p>默认时间规则：</p><ul><li>在 Firefox 中，上限是 24 小时 （即 86400 秒）。</li><li>在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。</li><li>从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。</li><li>Chromium 同时规定了一个默认值 5 秒。</li><li>如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。</li></ul><p>比如设置为 5 秒后，客户端在第一次会发送 <strong>预检接口</strong> 后，5 秒内将不再发送 <strong>预检接口</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="string">'5'</span>);</span><br></pre></td></tr></table></figure><img src="/legacy/2021/10/20/cors-and-options/cors-access-maxage.gif" class="" title="缓存示例"><h2 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h2><p>跨域的请求，默认浏览器不会将当前地址的 Cookies 信息传给服务器，以确保信息的安全性。如果有需要，服务端需要设置 <strong>Access-Control-Allow-Credentials</strong> 响应头，另外客户端也需要开启 <strong>withCredentials</strong> 配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端请求</span></span><br><span class="line">axios.post(</span><br><span class="line">  <span class="string">'http://127.0.0.1:3000/test/cors'</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">      abc: <span class="string">'123'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    withCredentials: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有请求</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>Access-Control-Allow-Origin</strong> 不能设置通配符“*”方式，会出现如下错误：</p><img src="/legacy/2021/10/20/cors-and-options/cors-access-credentials.png" class="" title="不支持通配符"><p>这个 <strong>Access-Control-Allow-Origin</strong> 必须是当前页面源的地址。</p><h2 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h2><p>和 <strong>Access-Control-Allow-Credentials</strong> 类似，如果服务端有自定义设置的请求头，跨域的客户端请求在响应信息中是接收不到该请求头的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">res.setHeader(<span class="string">'def'</span>, <span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .post(</span><br><span class="line">    <span class="string">'http://127.0.0.1:3000/test/cors'</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        abc: <span class="string">'123'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      withCredentials: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.headers.def); <span class="comment">//undefined</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>需要在服务端设置 <strong>Access-Control-Expose-Headers</strong> 响应头，并标记哪些头是客户端能获取到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'def'</span>);</span><br><span class="line">res.setHeader(<span class="string">'def'</span>, <span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h2 id="Access-Control-Request-Headers"><a href="#Access-Control-Request-Headers" class="headerlink" title="Access-Control-Request-Headers"></a>Access-Control-Request-Headers</h2><p>我试了半天没找到 <strong>Access-Control-Request-Headers</strong> 的使用示例，其实它是根据当前请求的头拼接得到的。</p><p>如果客户端的请求头为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"content-type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">  <span class="attr">"abc"</span>: <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"xyz"</span>: <span class="string">"123"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么浏览器最后会在 <strong>预检接口</strong> 添加一个 <strong>Access-Control-Request-Headers</strong> 的头，其值为：abc,content-type,xyz。然后服务端再根据 <strong>Access-Control-Allow-Headers</strong> 告诉浏览器服务端的请求头支持说明，最后浏览器判断是否会有跨域错误。</p><p>另外，对于服务端也需要针对 <strong>Access-Control-Request-Headers</strong> 做 <strong>Vary</strong> 处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Vary'</span>, <span class="string">'Origin'</span> + <span class="string">', '</span> + req.headers[<span class="string">'access-control-request-headers'</span>]);</span><br></pre></td></tr></table></figure><p>如此，对于跨域及其怎么处理头信息会有个基本的概念。希望在遇到类似问题能有章法的解决，而非胡乱尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造属于自己的一款命令行 cli 脚手架工具</title>
      <link href="/legacy/2021/10/18/commander-quickstart/"/>
      <url>/legacy/2021/10/18/commander-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你想了解命令行脚手架，这篇将带你入个门了解 <strong>commander</strong> 和 <strong>inquirer</strong> 库的使用。然后通过一个 Demo 示例来示范如何创作一个脚手架。</p><h1 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h1><p>首先需要知道 <strong>commander</strong> 这个 <strong>npm</strong> 库，它帮我们封装了 <strong>解析命令行</strong> 的能力。我们之后要做的脚手架都是基于 <strong>commander</strong> 的。</p><h2 id="先了解几个简单的使用方式"><a href="#先了解几个简单的使用方式" class="headerlink" title="先了解几个简单的使用方式"></a>先了解几个简单的使用方式</h2><h3 id="显示帮助-amp-版本信息"><a href="#显示帮助-amp-版本信息" class="headerlink" title="显示帮助&amp;版本信息"></a>显示帮助&amp;版本信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="comment">// 定义程序名称，版本</span></span><br><span class="line">program.name(cliName).version(pkg.version);</span><br><span class="line"><span class="comment">// 解析命令行</span></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure><p>执行 <strong>node ./bin/fl-cli –help</strong> ，将看到如下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli --help</span><br><span class="line">Usage: fl [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version  output the version number</span><br><span class="line">  -h, --help     display help for command</span><br></pre></td></tr></table></figure><p>这个 <strong>program.parse</strong> 方法必须调用，不然命令行工具就不能“正常的工作了”。</p><p>输出信息中，能看到 <strong>Usage</strong> 条目，默认它向我们展示如何去使用这个命令，当然我们也可以更改它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program.usage(<span class="string">'&lt;command&gt; [options]'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: fl &lt;command&gt; [options]</span><br></pre></td></tr></table></figure><h3 id="如何约定命令-Command？"><a href="#如何约定命令-Command？" class="headerlink" title="如何约定命令 Command？"></a>如何约定命令 Command？</h3><p>命名一个 <strong>create</strong> 命令，约定用于创建应用（类似 vue create）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">'create'</span>)</span><br><span class="line">  .description(<span class="string">'创建应用'</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello command'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>通过 <strong>help</strong> 命令，能看到 <strong>Commands</strong> 条目中增加的新命令信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli --help</span><br><span class="line">Usage: fl &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version   output the version number</span><br><span class="line">  -h, --help      display help for command</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create          创建应用</span><br><span class="line">  help [command]  display help for command</span><br></pre></td></tr></table></figure><p>执行 <strong>create</strong> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli create</span><br><span class="line">hello command</span><br></pre></td></tr></table></figure><h3 id="如何定义命令参数-Options？"><a href="#如何定义命令参数-Options？" class="headerlink" title="如何定义命令参数 Options？"></a>如何定义命令参数 Options？</h3><p>我们需要额外增加参数，来让命令应对多种情况，比如可以设置 -f 使得创建的应用强制覆盖当前路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">'create'</span>)</span><br><span class="line">  .description(<span class="string">'创建应用'</span>)</span><br><span class="line">  .option(<span class="string">'-f,'</span>, <span class="string">'是否强制创建'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">options, command</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli create -f</span><br><span class="line">&#123; f: true &#125;</span><br></pre></td></tr></table></figure><p>我们也能自定义参数值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.option(<span class="string">'-f,--force &lt;path&gt;'</span>, <span class="string">'是否强制创建'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli create --force /use/local</span><br><span class="line">&#123; force: '/use/local' &#125;</span><br></pre></td></tr></table></figure><p>需要注意，如果用户输入了 <strong>非预期</strong> 的参数将报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli create -abc</span><br><span class="line">error: unknown option '-abc'</span><br></pre></td></tr></table></figure><p>我们可以添加 <strong>allowUnknownOption()</strong> 方法，防止 <strong>非预期</strong> 参数影响命令的执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">'create'</span>)</span><br><span class="line">  .description(<span class="string">'创建应用'</span>)</span><br><span class="line">  .option(<span class="string">'-f,--force &lt;path&gt;'</span>, <span class="string">'是否强制创建'</span>)</span><br><span class="line">  .allowUnknownOption()</span><br><span class="line">  .action(<span class="function">(<span class="params">options, command</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\project\frontend-learn-cli&gt;node ./bin/fl-cli create -abc</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h2><p>如上，我们就能进行开发简单的命令行工具了。但离 <strong>人性化</strong> 的命令行工具还有点距离，下面提供几种技巧：</p><h3 id="控制台输出语句的颜色"><a href="#控制台输出语句的颜色" class="headerlink" title="控制台输出语句的颜色"></a>控制台输出语句的颜色</h3><p>有个仓库叫 <strong>chalk</strong> ，让我们可以自定义 <strong>console.log</strong> 输出的颜色。这对于命令行有非常好的可视化效果。</p><p>我们对 –help 命令做个封装，在 help 信息末尾添加蓝色的帮助命令语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line">exports.outputHelp = <span class="function">(<span class="params">cliName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`  Run <span class="subst">$&#123;chalk.cyan(<span class="string">`<span class="subst">$&#123;cliName&#125;</span> &lt;command&gt; --help`</span>)&#125;</span> for detailed usage of given command.`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">program.on(<span class="string">'--help'</span>, () =&gt; &#123;</span><br><span class="line">  outputHelp(cliName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时，遍历每个 <strong>Command</strong> 命令，也为其添加这一功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program.commands.forEach(<span class="function">(<span class="params">c</span>) =&gt;</span> c.on(<span class="string">'--help'</span>, () =&gt; outputHelp(cliName)));</span><br></pre></td></tr></table></figure><img src="/legacy/2021/10/18/commander-quickstart/chalk.png" class="" title="效果展示"><h3 id="“命令-参数”错误的封装"><a href="#“命令-参数”错误的封装" class="headerlink" title="“命令/参数”错误的封装"></a>“命令/参数”错误的封装</h3><p>由于命令错误，参数错误或者值漏填会导致命令行的出错，对于这类非预期的错误需要及时提示使用者，而不是只展示：<strong>error: option ‘-f,–force <path>‘ argument missing</strong> 这样的信息。</p><p>参考 <a href="https://github.com/vuejs/vue-cli/blob/dev/packages/%40vue/cli/bin/vue.js#L219" target="_blank" rel="noopener">Vue 的错误处理</a> 我们可以覆写 <strong>commander</strong> 的方法，结合 <strong>chalk</strong> 加强输出错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enhanceErrorMessages = <span class="function">(<span class="params">methodName, log</span>) =&gt;</span> &#123;</span><br><span class="line">  program.Command.prototype[methodName] = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (methodName === <span class="string">'unknownOption'</span> &amp;&amp; <span class="keyword">this</span>._allowUnknownOption) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.outputHelp();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  `</span> + chalk.red(log(...args)));</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类似有：missingArgument，unknownOption，optionMissingArgument 方法</span></span><br><span class="line">enhanceErrorMessages(<span class="string">'missingArgument'</span>, (argName) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Missing required argument <span class="subst">$&#123;chalk.yellow(<span class="string">`&lt;<span class="subst">$&#123;argName&#125;</span>&gt;`</span>)&#125;</span>.`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/legacy/2021/10/18/commander-quickstart/enhance-error.png" class="" title="加强错误显示"><h3 id="交互式命令行-inquirer"><a href="#交互式命令行-inquirer" class="headerlink" title="交互式命令行 inquirer"></a>交互式命令行 inquirer</h3><p>通过 <strong>command</strong> ，<strong>option</strong> 可以定义所有命令行需要的功能，但在与使用者交互会相当不友好（会面对大量的命令说明）。</p><p>相信用过 <strong>vue-cli</strong> 都知道：在创建项目时，我们可以跟随命令行的提示来选择对应需要的功能。</p><p>这种交互式的命令行可以通过 <strong>inquirer</strong> 来完成。</p><p>下面是采用了这种方式的效果图：</p><img src="/legacy/2021/10/18/commander-quickstart/inquirer.gif" class="" title="效果图"><p>先定义一批 <strong>questions</strong> 交互问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultQuestions = [</span><br><span class="line">  <span class="comment">// 列表选择</span></span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'list'</span>,</span><br><span class="line">    name: <span class="string">'template'</span>,</span><br><span class="line">    message: <span class="string">'请选择模板'</span>,</span><br><span class="line">    choices: [&#123; <span class="attr">name</span>: <span class="string">'express'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'vue2'</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输入</span></span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'input'</span>,</span><br><span class="line">    name: <span class="string">'appName'</span>,</span><br><span class="line">    message: <span class="string">'请输入应用名称'</span>,</span><br><span class="line">    <span class="keyword">default</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'app'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> expressQuestions = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">'checkbox'</span>,</span><br><span class="line">    name: <span class="string">'express.middleware'</span>,</span><br><span class="line">    message: <span class="string">'请选择中间件'</span>,</span><br><span class="line">    choices: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">'express.json'</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">'express.urlencoded'</span>, <span class="attr">checked</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    when(answers) &#123;</span><br><span class="line">      <span class="keyword">return</span> answers.template == <span class="string">'express'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> questions = [...defaultQuestions, ...expressQuestions];</span><br></pre></td></tr></table></figure><p>然后在命令的 <strong>action</strong> 回调中调用 <strong>inquirer.prompt</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">'create'</span>)</span><br><span class="line">  .description(<span class="string">'创建应用'</span>)</span><br><span class="line">  .option(<span class="string">'-f,--force &lt;path&gt;'</span>, <span class="string">'是否强制创建'</span>)</span><br><span class="line">  <span class="comment">// .allowUnknownOption()</span></span><br><span class="line">  .action(<span class="function">(<span class="params">options, command</span>) =&gt;</span> &#123;</span><br><span class="line">    inquirer.prompt(questions).then(<span class="keyword">async</span> (answers) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(answers);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>当交互结束后，这个 <strong>answers</strong> 将是我们自定义的结果值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  template: <span class="string">'express'</span>,</span><br><span class="line">  appName: <span class="string">'app'</span>,</span><br><span class="line">  express: &#123; <span class="attr">middlewares</span>: [ <span class="string">'json'</span> ] &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  template: <span class="string">'express'</span>,</span><br><span class="line">  appName: <span class="string">'app'</span>,</span><br><span class="line">  express: &#123; <span class="attr">middlewares</span>: [ <span class="string">'json'</span> ] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>再了解上面有关命令行的工具操作后，下面可以实际“造”一个脚手架工具了。</p><p>下面将提供一个创建 <strong>express</strong> 代码模板的脚手架。用于快速生成相关代码目录，而不用去技术栈网站去拷贝大量代码。（具体代码逻辑，在 <strong>npm</strong> 搜索 <strong>frontend-learn-cli</strong> 即可）</p><p>简单实现思路：</p><h2 id="通过-commander-，实现对创建-create-指令的命令行解析"><a href="#通过-commander-，实现对创建-create-指令的命令行解析" class="headerlink" title="通过 commander ，实现对创建 create 指令的命令行解析"></a>通过 <strong>commander</strong> ，实现对创建 <strong>create</strong> 指令的命令行解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">'create'</span>)</span><br><span class="line">  .description(<span class="string">'创建应用'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">options, command</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//inquirer...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="添加-inquirer-定义好相关可选问题"><a href="#添加-inquirer-定义好相关可选问题" class="headerlink" title="添加 inquirer 定义好相关可选问题"></a>添加 <strong>inquirer</strong> 定义好相关可选问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inquirer.prompt(questions).then(<span class="keyword">async</span> (answers) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模板逻辑...</span></span><br><span class="line">  <span class="comment">// 模板类型（express, vue...）</span></span><br><span class="line">  <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="comment">// 中间件选择</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="定义模板固定代码"><a href="#定义模板固定代码" class="headerlink" title="定义模板固定代码"></a>定义模板固定代码</h2><p>根据自己对 <strong>express</strong> 的习惯，定义相关代码结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">  |- express</span><br><span class="line">    |- bin</span><br><span class="line">        | www.ejs</span><br><span class="line">    |- routes</span><br><span class="line">        | health.js.ejs</span><br><span class="line">    | app.js.ejs</span><br><span class="line">    | package.json.ejs</span><br></pre></td></tr></table></figure><p>注意：上面的文件都已 <strong>ejs</strong> 作为后缀。具体原因是：模板变量会根据 <strong>answers</strong> 变量，动态注入自定义值。</p><p><strong>ejs</strong> 文件模板会张这个样子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> app.js.ejs</span></span><br><span class="line">&lt;% if (express.middlewares.includes('json')) &#123; -%&gt;</span><br><span class="line">app.use(express.json())</span><br><span class="line">&lt;% &#125; -%&gt;</span><br><span class="line">&lt;% if (express.middlewares.includes('urlencoded')) &#123; -%&gt;</span><br><span class="line">app.use(express.urlencoded())</span><br><span class="line">&lt;% &#125; -%&gt;</span><br></pre></td></tr></table></figure><p>为什么选择 <strong>ejs</strong>？</p><p>是抄 <strong>express-generate</strong> 这个库的，当然也可以根据自己喜好选择模板引擎。这种模板方式让我做这种脚手架变得很方便，只要把历史项目 demo 复制进来，改一通后缀即可。</p><h2 id="通过-fs-读模板到指定路径"><a href="#通过-fs-读模板到指定路径" class="headerlink" title="通过 fs 读模板到指定路径"></a>通过 fs 读模板到指定路径</h2><p>将模板内的文件通过 <strong>fs-extra</strong> 写到指令执行的当前路径下（文件具体操作这里就不详述了）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inquirer.prompt(questions).then(<span class="keyword">async</span> (answers) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    _mkdirProjectDir(answers.appName, options.f);</span><br><span class="line">    _writeFiles([</span><br><span class="line">      &#123; <span class="attr">dirtory</span>: <span class="string">'bin'</span>, <span class="attr">fileName</span>: <span class="string">'www'</span>, answers &#125;,</span><br><span class="line">      &#123; <span class="attr">dirtory</span>: <span class="string">'routes'</span>, <span class="attr">fileName</span>: <span class="string">'health.js'</span>, answers &#125;,</span><br><span class="line">      &#123; <span class="attr">dirtory</span>: <span class="string">'util'</span>, <span class="attr">fileName</span>: <span class="string">'index.js'</span>, answers &#125;,</span><br><span class="line">      &#123; <span class="attr">fileName</span>: <span class="string">'app.js'</span>, answers &#125;,</span><br><span class="line">      &#123; <span class="attr">fileName</span>: <span class="string">'package.json'</span>, answers &#125;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(err.message));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="发布脚手架"><a href="#发布脚手架" class="headerlink" title="发布脚手架"></a>发布脚手架</h2><p>在 <strong>package.json</strong> 文件中，约定 <strong>bin</strong> 属性，并指向我们实现 commander 的文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">  "fel": "bin/fel-cli.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后通过 <strong>npm publish</strong> 发布我们的脚手架包，最后使用者通过 <strong>npm i xxx -g</strong> 下载就能用了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> commander </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 入门</title>
      <link href="/legacy/2021/08/23/docker-quickstart/"/>
      <url>/legacy/2021/08/23/docker-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是看 <a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">Docker 官方安装文档</a> 的总结，我不是 Docker 专家，也不是运维，但身边的工作环境都在说 docker，所以知晓一种技术怎么使用，解决什么问题是非常有必要的，<strong>技术类的东西只有实践了才有概念</strong>。</p><p>如果你也刚接触 docker，但看不怎么想官方文档的说明，想了解下 docker 到底怎么回事，说不定这篇可以帮助你。</p><h1 id="类-Unix-环境的准备"><a href="#类-Unix-环境的准备" class="headerlink" title="类 Unix 环境的准备"></a>类 Unix 环境的准备</h1><p>我是 windows 平台，虽然 docker 也有 windows 版本，但需要准备 <a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#step-4---download-the-linux-kernel-update-package" target="_blank" rel="noopener">WSL 2</a>，安装也比较麻烦 ，并且对于系统也有要求（版本要高于 19041，我是家庭版不合适）。</p><p>为了让这次的 docker 学习更贴近真实的生产环境，装个虚拟机是非常有必要的，当然也可以阿里云申请个 ecs（按时计费，也就几块，学完就回收）</p><p>搜索引擎直接搜：wmware download，进入 wmware 官网下载免费版的虚拟机 <a href="https://www.vmware.com/products/vsphere-hypervisor.html" target="_blank" rel="noopener">vSphere Hypervisor</a>，当然我选择了 <a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">VMware Workstation Pro</a>，它有一个月的试用时间。</p><p>因为是 windows 平台，点击 exe 文件后，直接安装，启动后首页如下：</p><img src="/legacy/2021/08/23/docker-quickstart/vwmare-home.png" class="" title="vwmare首页"><p>由于这只是个虚拟机，对应的系统镜像需要自己下载，而 Linux 是个开源的操作系统，我这里选择了 CentOS（对应下载了 <a href="http://isoredirect.centos.org/centos/8/isos/x86_64/" target="_blank" rel="noopener">x86_64 的 ios</a>），在 CentOS 下载页面里有一堆镜像地址，你可以随便选择一个：</p><img src="/legacy/2021/08/23/docker-quickstart/centos-ios-download.png" class="" title="选择ios镜像"><p>然后回到 vmware 新建个虚拟机，选择前面下载好的 ios 镜像：</p><img src="/legacy/2021/08/23/docker-quickstart/centos-ios-choose.png" class="" title="安装CentOS-IOS"><p>之后没特别的，一直下一步即可，中间稍稍关注下用户名和密码配置：</p><img src="/legacy/2021/08/23/docker-quickstart/wmware-config.png" class="" title="配置"><h1 id="安装-docker-环境"><a href="#安装-docker-环境" class="headerlink" title="安装 docker 环境"></a>安装 docker 环境</h1><ol><li><p>切换用户到 root</p><p>之后的操作将建立在系统权限下，所以实现将用户切换至 root，避免导致一些“不顺利”的情况发生。</p><img src="/legacy/2021/08/23/docker-quickstart/docker-1.png" class=""></li><li><p>设置 docker 仓库地址</p><img src="/legacy/2021/08/23/docker-quickstart/docker-2.png" class=""></li><li><p>安装 docker</p><img src="/legacy/2021/08/23/docker-quickstart/docker-3.png" class=""></li><li><p>将 docker 添加到系统服务中</p><img src="/legacy/2021/08/23/docker-quickstart/docker-4.png" class=""></li></ol><h1 id="开始第一个镜像"><a href="#开始第一个镜像" class="headerlink" title="开始第一个镜像"></a>开始第一个镜像</h1><ol><li><p>下载一个 <a href="https://github.com/docker/getting-started/tree/master/app" target="_blank" rel="noopener">Node.js 项目</a></p><blockquote><p><a href="https://github.com/docker/getting-started/tree/master/app" target="_blank" rel="noopener">https://github.com/docker/getting-started/tree/master/app</a></p></blockquote><p>你不需要懂得它能干嘛，就是起个服务，完成一些简单的功能让我们了解 docker 容器。</p></li><li><p>在根目录新建一个 Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> syntax=docker/dockerfile:1</span></span><br><span class="line">FROM node:12-alpine\</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换 apk 镜像</span></span><br><span class="line">RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories</span><br><span class="line">RUN apk add --no-cache python g++ make</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN yarn install --production</span><br><span class="line">CMD ["node", "src/index.js"]</span><br></pre></td></tr></table></figure><p>它有什么作用呢？</p><ul><li>从 alpine 中拉取 node12 的镜像</li><li>通过 apk 安装此项目需要的软件库</li><li>指定 docker 容器目录为 app，并将本地内容复制到此目录</li><li>安装 node 项目依赖，并启动项目</li></ul></li><li><p>构建镜像</p><p>在 docker 中构建一个镜像，并命名为：getting-started</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure></li><li><p>运行镜像</p><p>启动 getting-started 镜像，对外暴露 3000 端口，并映射为此 node 服务 3000 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 getting-started</span><br></pre></td></tr></table></figure><p>最后能看到这个 node 服务运行后的效果：</p><img src="/legacy/2021/08/23/docker-quickstart/docker-5.png" class=""></li><li><p>镜像的操作</p><img src="/legacy/2021/08/23/docker-quickstart/docker-6.png" class=""><p>查看所运行的镜像进程状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>从上表中找到需要操作的镜像 ID，停止镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><p>移除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="在-dockerhub-创建自己的镜像"><a href="#在-dockerhub-创建自己的镜像" class="headerlink" title="在 dockerhub 创建自己的镜像"></a>在 dockerhub 创建自己的镜像</h1><p>上面这些操作都是在本地环境，而镜像只有被“大家”都在使用才能体现出更高的价值，所以需要把镜像推到大家能下载到的平台才行。</p><p>docker 就提供了 hub 平台，我们可以把镜像扔到上面，下面就简单的操作下：</p><ol><li><p>首先你要在 dockerhub 注册一个账号，并登录上去</p><img src="/legacy/2021/08/23/docker-quickstart/docker-7.png" class=""><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u eminoda</span><br></pre></td></tr></table></figure></li><li><p>然后在将构建好的镜像推送上去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag getting-started eminoda/getting-started</span><br></pre></td></tr></table></figure></li><li><p>如果本地没有这个镜像，就会加载远程镜像，并启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 eminoda/getting-started</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 flex-grow 和 flex-shrink 是这么回事</title>
      <link href="/legacy/2021/08/16/flex-grow-and-shrink/"/>
      <url>/legacy/2021/08/16/flex-grow-and-shrink/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前面试被问到如下问题：</p><blockquote><p>flex: 1 0 auto;</p></blockquote><p>你知道它是什么意思么？虽然知道是有关伸缩的几个属性占位，但因为平时只写 <strong>flex: 1</strong>，一直没关注过这个语法糖其他表达式有什么规则，只要无奈回答：不知道。</p><p>可能这是个八股文，网上查查便知道，但写完这篇后，我觉得不应该发生在一个 web 开发的“老人”身上。</p><p><strong>先了解下 flex 有哪几种写法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">none</span> <span class="comment">/* value 'none' case */</span></span><br><span class="line">flex: &lt;'flex-grow'&gt; /* One value syntax, variation 1 */</span><br><span class="line">flex: &lt;'flex-basis'&gt; /* One value syntax, variation 2 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-basis'&gt; /* Two values syntax, variation 1 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; /* Two values syntax, variation 2 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; &lt;'flex-basis'&gt; /* Three values syntax */</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">inherit</span></span><br></pre></td></tr></table></figure><p><strong>flex</strong> 语法糖中出现了 <strong>flex-grow</strong>，<strong>flex-shrink</strong>，<strong>flex-basis</strong> 三个属性，如果你也不太了解的话，就随着下面的代码示例牢记在脑子里吧。</p><h1 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h1><blockquote><p>它指定了 <strong>flex</strong> 容器中剩余空间的多少应该分配给项目（flex 增长系数），默认为 0（无效）</p></blockquote><p>先来看张动图：</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow.gif" class="" title="增长示例"><p>代码如下（下面所有示例将基于此做略微改动）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span> <span class="attr">num</span>=<span class="string">"2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父级容器 */</span></span><br><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子元素 */</span></span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffa940</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 特别样式 */</span></span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span><span class="selector-attr">[num=<span class="string">"2"</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到随着 <strong>flex-grow</strong> 改变，中间元素从 200px 到填充整个区域做着切换。</p><p><strong>TLDR</strong>：弹性盒子内（display: flex），所有子元素（项目 item）的宽度总和不超过父级宽度的话，剩下的空间将被 <strong>flex-grow</strong> 修饰的元素按照一个规则进行增长。</p><p>这个就当热身，下面正式开始了。</p><h2 id="不同-width-下的变化"><a href="#不同-width-下的变化" class="headerlink" title="不同 width 下的变化"></a>不同 width 下的变化</h2><p><strong>父级宽度（600px）= 子元素宽度之和：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子元素将保持不变，因为没有多余空间供元素增长，所以即使设置了 <strong>flex-grow</strong> 也没效果。</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-1.png" class=""><p><strong>父级宽度（800px）&gt; 子元素宽度之和：</strong></p><p>每个元素的增长率为 1/(1+1+1)，多余空间为：800-200*3=200。</p><p>所以每个元素最终宽度为：200+200*1/3 = 266.66</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-2.png" class=""><p><strong>父级宽度（400px）&lt; 子元素宽度之和：</strong></p><p>由于子元素宽度总和大于父级，所以原本的宽度 200px 将失效，子元素宽度将为：400/3 = 133.33</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-3.png" class=""><h2 id="只有其中一元素设置了-flex-grow"><a href="#只有其中一元素设置了-flex-grow" class="headerlink" title="只有其中一元素设置了 flex-grow"></a>只有其中一元素设置了 flex-grow</h2><p><strong>只有其中一元素设置了 flex-grow</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="comment">/* flex-grow: 1; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span><span class="selector-attr">[num=<span class="string">"2"</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 1 个和第 2 个元素保持原 200px（默认不增长），多余空间为：800-200*2 = 400，中间元素将增长到 400px</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-only-1.png" class=""><p><strong>当 flex-grow 值为小数：</strong></p><p>为小数时，分母默认为 1，即此时增长率为 0.5/1，中间元素将增长到：200+0.5/1*200=300</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-only-2.png" class=""><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span><span class="selector-attr">[num=<span class="string">"2"</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h1><blockquote><p>指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。默认值为 1。</p></blockquote><h2 id="在不同-width-下的变化"><a href="#在不同-width-下的变化" class="headerlink" title="在不同 width 下的变化"></a>在不同 width 下的变化</h2><p><strong>父级宽度（600px）= 子元素宽度之和（600px）：</strong></p><p>两者宽度相同，不做收缩处理。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-shrink-width-2.png" class=""><p><strong>父级宽度（500px）&lt; 子元素宽度之和（600px）：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺少空间为 100px，每个元素收缩率为：1/(1*3)，即收缩长度为：200-100*1/(1*3) = 166.67</p><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-shrink-width-1.png" class=""><h2 id="只有其中一元素设置了-flex-shrink"><a href="#只有其中一元素设置了-flex-shrink" class="headerlink" title="只有其中一元素设置了 flex-shrink"></a>只有其中一元素设置了 flex-shrink</h2><p><strong>flex-shrink 为整数时：</strong></p><p>缺少空间为：200*3 - 500 = 100，中间元素将收缩到 200-100*(2/4)=150，第 1 个和第 2 个元素为 200-100*(1/4)=175</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span><span class="selector-attr">[num=<span class="string">"2"</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-shrink-value-1.png" class=""><p><strong>flex-shrink 为小数时：</strong></p><p>中间元素将收缩到 200-100*0.5/(2+.5)=180</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-shrink-value-2.png" class=""><h1 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h1><blockquote><p>指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p></blockquote><p>上面的例子中子元素都以 <strong>width</strong> 来初始化他们的宽度，但在 <strong>flex</strong> 布局中，还是强烈建议使用 <strong>flex-basis</strong>，一方面 <strong>flex-basis</strong> 的优先级高于 width，另一方面避免两者混用在不同浏览器展示形态的不同。</p><h2 id="flex-basis-优先级高于-width"><a href="#flex-basis-优先级高于-width" class="headerlink" title="flex-basis 优先级高于 width"></a>flex-basis 优先级高于 width</h2><p><strong>flex-basis</strong> 设置 100px，width 设置 200px，最终增长的宽度是基于 <strong>flex-basis</strong>：</p><p>注意，当 <strong>flex-basis</strong> 为 auto 时，则会以 <strong>width</strong> 设置的值为基数来计算。</p><h2 id="三个属性的简写"><a href="#三个属性的简写" class="headerlink" title="三个属性的简写"></a>三个属性的简写</h2><p>参照 flex 语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">none</span> <span class="comment">/* value 'none' case */</span></span><br><span class="line">flex: &lt;'flex-grow'&gt; /* One value syntax, variation 1 */</span><br><span class="line">flex: &lt;'flex-basis'&gt; /* One value syntax, variation 2 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-basis'&gt; /* Two values syntax, variation 1 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; /* Two values syntax, variation 2 */</span><br><span class="line">flex: &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt; &lt;'flex-basis'&gt; /* Three values syntax */</span><br><span class="line"><span class="selector-tag">flex</span>: <span class="selector-tag">inherit</span></span><br></pre></td></tr></table></figure><p>所以可以自行感受如下这些简写是什么含义：</p><p><strong>可增长</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="comment">/* 等同于 flex-grow: 1; */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-2.png" class=""><p><strong>设置基础宽度</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="comment">/* 等同于 flex-basis:200px */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-1.png" class=""><p><strong>可增长+设置基础宽度</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="comment">/* 等同于 */</span></span><br><span class="line">  <span class="comment">/* flex-grow: 1; */</span></span><br><span class="line">  <span class="comment">/* flex-basis:200px; */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-grow-width-2.png" class=""><p><strong>可增长+可缩小</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-content</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">  <span class="comment">/* 等同于 */</span></span><br><span class="line">  <span class="comment">/* flex-basis: 200px; */</span></span><br><span class="line">  <span class="comment">/* flex-grow: 1; */</span></span><br><span class="line">  <span class="comment">/* flex-shrink:1; */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2021/08/16/flex-grow-and-shrink/flex-shrink-width-1.png" class="">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 canvas 绘制网格背景</title>
      <link href="/legacy/2021/08/11/canvas-grid/"/>
      <url>/legacy/2021/08/11/canvas-grid/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有没有很好奇，类似 <strong>processOn</strong> 这类作图网站中，<strong>网格背景</strong> 是怎么做的呢？</p><img src="/legacy/2021/08/11/canvas-grid/processon.png" class="" title="网格背景"><p>如果你 F12 看过它的代码，你将发现原来不是通过 <strong>background-image</strong> 之类 <strong>css</strong> 属性做的，而是通过 <strong>canvas</strong> 实现的。</p><img src="/legacy/2021/08/11/canvas-grid/processon-2.png" class="" title="网格背景"><p>这篇主要讲如何通过 <strong>canvas</strong> 来绘制出这样的 <strong>网格背景</strong>，以及中间碰到的一个 <strong>线条模糊的问题</strong>。</p><h1 id="手把手写代码"><a href="#手把手写代码" class="headerlink" title="手把手写代码"></a>手把手写代码</h1><h2 id="1-创建-ctx-对象"><a href="#1-创建-ctx-对象" class="headerlink" title="1. 创建 ctx 对象"></a>1. 创建 ctx 对象</h2><p>这边将新建一个和屏幕尺寸相同的 <strong>canvas</strong> 画布：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvasEl = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">const</span> sh = screen.height;</span><br><span class="line"><span class="keyword">const</span> sw = screen.width;</span><br><span class="line">canvasEl.width = sw;</span><br><span class="line">canvasEl.height = sh;</span><br><span class="line"><span class="keyword">const</span> ctx = canvasEl.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure><h2 id="2-绘制网格"><a href="#2-绘制网格" class="headerlink" title="2. 绘制网格"></a>2. 绘制网格</h2><p>先简单说下思路：</p><p>根据 <strong>canvas</strong> 画布尺寸，以 <strong>10px</strong> 为间距，分别绘制横纵坐标的线条。</p><p>比如绘制横向线条，先将“画笔”移至起点坐标 (0, y)，然后通过线条方法 <strong>lineTo</strong> 绘制屏幕宽度的线条，即绘制 (0, y) 至 (screen.width, y) 的直线。</p><p>然后 <strong>y</strong> 会按照间距 <strong>10px</strong> 逐渐递增，直至绘制完整个屏幕。</p><p>下面根据横纵两个方向，封装了 <strong>draw</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> draw = <span class="function"><span class="keyword">function</span> (<span class="params">isColumn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> gutter = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> limit = isColumn ? sh : sw;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i * gutter + gutter &lt;= limit) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">const</span> point = i * gutter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空子路径列表开始一个新路径</span></span><br><span class="line">    ctx.beginPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    ctx.strokeStyle = point % <span class="number">100</span> !== <span class="number">0</span> ? <span class="string">"#f0f0f0"</span> : <span class="string">"#d6e4ff"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个新的子路径的起始点移动到(x，y)坐标</span></span><br><span class="line">    <span class="keyword">if</span> (isColumn) &#123;</span><br><span class="line">      ctx.moveTo(<span class="number">0</span>, point);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.moveTo(point, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用直线连接子路径的终点到x，y坐标</span></span><br><span class="line">    <span class="keyword">if</span> (isColumn) &#123;</span><br><span class="line">      ctx.lineTo(sw, point);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.lineTo(point, sh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前的画线样式，绘制当前或已经存在的路径的方法</span></span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很顺利你将得到 <strong>canvas</strong> 绘制的网格图形：</p><img src="/legacy/2021/08/11/canvas-grid/grid.png" class="" title="网格背景"><h1 id="线条模糊"><a href="#线条模糊" class="headerlink" title="线条模糊"></a>线条模糊</h1><p>如果你观察比较细腻，能发现上面的网格图形并不是很清晰，可以仔细观察下面的图：</p><img src="/legacy/2021/08/11/canvas-grid/grid-3.png" class="" title="对比"><p><strong>为什么会有这样的情况出现呢？</strong></p><p>因为调用 <strong>lineTo</strong> 是从 A 点到 B 点，轨迹是点到点的连线。当绘制 1px 线条时，是以这个轨迹连线为中间线左右各渲染 0.5px 的线条。这会使得一个像素点只渲染了一半，而另一半会用一个比较弱的颜色填充，导致绘制出模糊的线条。</p><p><strong>怎么改？</strong></p><p>只要在 <strong>moveTo</strong> 时，将坐标偏移 0.5px（即将线条轨迹偏移 0.5 位置），然后调用 <strong>lineTo</strong> 时，也将坐标偏移 0.5px。</p><p>这样，最终绘制线条的时候，将在一个完整的像素区域进行渲染了。</p><img src="/legacy/2021/08/11/canvas-grid/canvas-0.5.png" class="" title="选自：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;c0970eecd843"><p><strong>有没有便捷的方法？</strong></p><p>使用 <strong>translate</strong> 偏移 x 和 y 坐标值，然后绘制后再调用 <strong>setTransform</strong> 重置回来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.translate(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ctx.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/c0970eecd843" target="_blank" rel="noopener">canvas 画布解决 1px 线条模糊问题</a></li><li><a href="https://stackoverflow.com/questions/13879322/drawing-a-1px-thick-line-in-canvas-creates-a-2px-thick-line" target="_blank" rel="noopener">Drawing a 1px thick line in canvas creates a 2px thick line</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setTransform" target="_blank" rel="noopener">CanvasRenderingContext2D.setTransform()</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a.x = a = {n:2}，a.x 为什么是 undefined</title>
      <link href="/legacy/2021/08/08/fe-interview-object-ref/"/>
      <url>/legacy/2021/08/08/fe-interview-object-ref/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你一看便知这道面试题的答案，恭喜你有着扎实的 JS 功底，可惜我半天都想不明白，则写下这篇记录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">//?</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//?</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>先来看两段代码就当热身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2, 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">a.n = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// &#123; n: 2 &#125; &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>结果似乎不用过脑子，因为日常的编码里已经操练过很多次了。但上面到面试题，却出乎意料的摸不清头绪，你是不是像我一样在面试中思考片秒后，给出这样的答案？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// &#123;n:2&#125; 错，应为 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123;n:2&#125; 虽对但理解错</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;n:1&#125; 错，应为&#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>那我们就逐行分析其中的原由，首先是这两行的简单代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure><p>变量 a 在堆内存创建了一个对象 { n: 1 }，并指向它。同时变量 b 的引用也指向了 a 创建的那个对象。此时他们的值都为 { n: 1 }。</p><img src="/legacy/2021/08/08/fe-interview-object-ref/ref1.png" class="" title="a，b对象的引用"><p>最磨人的这行代码来了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>首先根据 js 编译器解析代码原则，会先在作用域中依次寻找 a 和 a.x 是否已经声明过。如果没有则会创建对应的变量。（见：你不知道的 Javascript 上卷[p7]）</p><p>因为 a 我们已经创建过了，但 a.x 没有，则会在那个创建对象内部声明 x（其值 undefined）</p><img src="/legacy/2021/08/08/fe-interview-object-ref/ref2.png" class="" title="a.x为undefined"><p><strong>注意一点：此时 a 引用是最开始在堆内存里创建的对象</strong>（这理解很重要，会影响能否读懂这题）</p><p>当代码被 js 引擎执行起来后，会从右往左依次进行赋值运算，即代码的优先级会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x &#x3D; (a &#x3D; &#123; n: 2 &#125;);</span><br></pre></td></tr></table></figure><p>第一次 a = { n: 2 } 进行赋值：</p><p>变量 a 重新在堆内存申请了一个对象地址，其值为 { n: 2 }：</p><img src="/legacy/2021/08/08/fe-interview-object-ref/ref3.png" class="" title="a的新指向"><p>第二次赋值 a.x = a：</p><p>的确 a.x 的值是为 {n: 2}，但不同的是：这里的 a.x 的 a 是老对象引用（引用并没有被释放掉），a.x 指向了 a 的新地址 {n: 2}：</p><img src="/legacy/2021/08/08/fe-interview-object-ref/ref4.png" class="" title="区分a引用"><p>所以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; n: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123; n: 1, x: &#123; n: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>a.x 为 undefined：因为 a 新的引用地址（{n: 2}）的对象中没有 x 属性。</p><p>a 为 { n: 2 }：因为 a 为新的引用地址。</p><p>b 为 { n: 1, x: { n: 2 } }：因为 b 还是指向 a 的旧引用地址，但 a.x 指向了 a 的新引用地址。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>似乎豁然开朗，没明白就多看几遍吧。虽然日常不可能写这样会引起 bug 的代码，但的确能测试回答这问题人的水平，反正我面试是挂了，水平像个刚入门的新生一样。</p><p>（本篇在循环播放 <strong>米津玄师的 Loser</strong> 中完成）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/102085119" target="_blank" rel="noopener">js 连续赋值及 js 引用类型指针(赋值从右往左)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何定制化网站主题色</title>
      <link href="/legacy/2021/06/24/website-dynamic-theme-replacer/"/>
      <url>/legacy/2021/06/24/website-dynamic-theme-replacer/</url>
      
        <content type="html"><![CDATA[<h1 id="如何切换主题色"><a href="#如何切换主题色" class="headerlink" title="如何切换主题色"></a>如何切换主题色</h1><p>首先抛个问题，我们根据什么来辨别同类型的网站？</p><p>我觉得是网站的“主题色”，试想下把淘宝的橘红色换成京东的红色，是不是就和后者一样了。</p><blockquote><p>可以说：主题色作为网站辨识度最高的设计元素之一。</p></blockquote><p>实际工作场景中，一个 web 项目可能改个主题色及页面内容，就可以给不同业务方使用。对于如今的前端开发来说，即使有着成熟的 UI 组件框架，比如 <strong>Ant Design</strong> ，<strong>Element UI</strong> 等，<br>但为了变出不同主题色系的网站风格，我们往往会创建新的主题样式来覆盖原有的 UI ，工作量仍然巨大，稍有疏忽就会有遗漏。</p><blockquote><p>那有没有省时省力的方式来定制化 UI 组件色系呢？</p></blockquote><p>肯定有。下面就举例 <strong><a href="https://github.com/vueComponent/ant-design-vue-pro" target="_blank" rel="noopener">Ant Design Pro</a></strong> （一款基于 <strong>Vue</strong> 和 <strong>Ant Design</strong> 的中后台前端框架），看下它是基于什么实现的？</p><h1 id="Ant-Design-Pro-到底有什么魔法？"><a href="#Ant-Design-Pro-到底有什么魔法？" class="headerlink" title="Ant Design Pro 到底有什么魔法？"></a>Ant Design Pro 到底有什么魔法？</h1><p>我们通过 <strong>npm run serve</strong> 启动项目，进入主页后，在页面右侧的设置按钮来切换主题色，能看到页面颜色也跟着发生了改变：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/antd-theme-replacer.gif" class=""><p>试着找些明面上能看到的东西：</p><p>打开调试工具，重新刷新页面，看到浏览器发送了一个 <strong>/css/theme-colors-xxx.css</strong> 的请求，响应内容为一大段样式代码：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/theme-fetch.png" class=""><p>审查页面有关主题颜色的元素，发现利用了 <strong>样式覆盖</strong> 的特性让新颜色起了效果：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/theme-cover.png" class=""><p>这些新的样式代码被定义在一个 <strong>style</strong> 标签内：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/theme-style-tag.png" class=""><p>如此，将覆盖原先 UI 组件的颜色样式，从而将达到主题色切换的目的。不知所以然的你，肯定就会有如下问题：</p><ul><li><strong>css</strong> 样式代码根据什么规则生成的？</li><li>请求 <strong>/css/theme-colors-xxx.css</strong> 哪里发起的？</li><li>主题色的切换，页面怎么快速做样式更新的？</li></ul><p>这些都围绕着 <strong>webpack-theme-color-replacer</strong> 展开，下面就进入代码来一探究竟。</p><h1 id="主题样式代码生成规则？"><a href="#主题样式代码生成规则？" class="headerlink" title="主题样式代码生成规则？"></a>主题样式代码生成规则？</h1><p>翻阅 <strong>Ant Design Pro</strong> 中 <strong>webpack</strong> 配置，发现有个和主题颜色配置相关的 <strong>plugins</strong> 逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createThemeColorReplacerPlugin = <span class="built_in">require</span>(<span class="string">"./config/plugin.config"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">vueConfig.configureWebpack.plugins.push(createThemeColorReplacerPlugin());</span><br></pre></td></tr></table></figure><p><strong>createThemeColorReplacerPlugin</strong> 返回的就是 <strong>webpack-theme-color-replacer</strong> 插件对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeColorReplacer = <span class="built_in">require</span>(<span class="string">"webpack-theme-color-replacer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> themePluginOption = &#123;</span><br><span class="line">  fileName: <span class="string">"css/theme-colors-[contenthash:8].css"</span>,</span><br><span class="line">  matchColors: getAntdSerials(<span class="string">"#1890ff"</span>), <span class="comment">// 主色系列</span></span><br><span class="line">  changeSelector(selector) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createThemeColorReplacerPlugin = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> ThemeColorReplacer(themePluginOption);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = createThemeColorReplacerPlugin;</span><br></pre></td></tr></table></figure><p>注意到：<strong>themePluginOption</strong> 中的 <strong>fileName</strong> 和主题样式请求地址一样（和问题二有关）；另外 <strong>matchColors</strong> 默认通过 <strong>getAntdSerials</strong> 把 <strong>#1890ff</strong> 转化为一组蓝色系的主题色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;#1890ff&quot;, &quot;#2f9bff&quot;, &quot;#46a6ff&quot;, &quot;#5db1ff&quot;, &quot;#74bcff&quot;, &quot;#8cc8ff&quot;, &quot;#a3d3ff&quot;, &quot;#badeff&quot;, &quot;#d1e9ff&quot;,</span><br><span class="line">  &quot;#e6f7ff&quot;, &quot;#bae7ff&quot;, &quot;#91d5ff&quot;, &quot;#69c0ff&quot;, &quot;#40a9ff&quot;,</span><br><span class="line">  &quot;#1890ff&quot;, &quot;#096dd9&quot;, &quot;#0050b3&quot;, &quot;#003a8c&quot;, &quot;#002766&quot;,</span><br><span class="line">  &quot;24,144,255&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>webpack plugins 运行时，则调用 <strong>ThemeColorReplacer.apply</strong> 方法，并触发 <strong>Handler.handler</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeColorReplacer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = <span class="keyword">new</span> Handler(options);</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.handler.handle(compilation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Handler</strong> 中，会先初始化一个文件提取器 <strong>AssetsExtractor</strong> ，通过内部 <strong>extractAssets</strong> 方法来提取主题样式代码到 <strong>output</strong>，最后调用 <strong>addToEntryJs</strong> 方法，将提取结果加到每个入口文件里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.assetsExtractor = <span class="keyword">new</span> AssetsExtractor(<span class="keyword">this</span>.options);</span><br><span class="line">  &#125;</span><br><span class="line">  handle(compilation) &#123;</span><br><span class="line">    <span class="keyword">var</span> output = <span class="keyword">this</span>.assetsExtractor.extractAssets(compilation.assets);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.addToEntryJs(outputName, compilation, output);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AssetsExtractor</strong> 内部逻辑过于复杂，代码流程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssetsExtractor</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.extractor = <span class="keyword">new</span> Extractor(options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.extractAssets = <span class="function"><span class="keyword">function</span> (<span class="params">assets</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 遍历 assets 文件对象</span></span><br><span class="line">    <span class="keyword">var</span> srcArray = <span class="keyword">this</span>.extractToArray(assets);</span><br><span class="line">    <span class="keyword">var</span> output = dropDuplicate(srcArray).join(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.extractToArray = <span class="function"><span class="keyword">function</span> (<span class="params">assets</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> cssSrcs = [];</span><br><span class="line">    <span class="built_in">Object</span>.keys(assets).map(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> asset = assets[fn];</span><br><span class="line">      cssSrcs = cssSrcs.concat(that.extractAsset(fn, asset));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cssSrcs;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.extractAsset = <span class="function"><span class="keyword">function</span> (<span class="params">fn, asset</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> cssSrcs = [];</span><br><span class="line">    <span class="comment">// 2. 解析 js module 中符合 cssReg 的 css 代码</span></span><br><span class="line">    <span class="keyword">var</span> CssCodeReg = Css_Loader_Reg_UGLY;</span><br><span class="line">    src.replace(CssCodeReg, (match, $<span class="number">1</span>) =&gt; &#123;</span><br><span class="line">      cssSrcs = cssSrcs.concat(<span class="keyword">this</span>.extractor.extractColors($<span class="number">1</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cssSrcs;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Extractor</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 3. 通过指针逐个遍历符合条件的内容，重新组装层复合 css 语法的代码，并提取到 ret 数组中</span></span><br><span class="line">  <span class="keyword">this</span>.extractColors = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">    src = src.replace(Reg_Lf_Rem, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">var</span> nameStart,</span><br><span class="line">      nameEnd,</span><br><span class="line">      cssEnd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      ret.push(selector + <span class="string">"&#123;"</span> + rules.join(<span class="string">";"</span>) + <span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 <strong>compilation.assets</strong> 下每个资源内容，通过正则 <strong>CssCodeReg</strong> 将符合 <strong>css</strong> 代码的内容抓取出来。这些代码就是图中【绿色】中的内容：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/cssSrc-replace.png" class=""><p>再通过 <strong>extractColors</strong> 方法逐行解析，得到一个有关主题色的 <strong>css</strong> 数组：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/cssSrc-ret.png" class=""><p>最后将结果输出到 <strong>theme-colors-xxx.css</strong> 中。</p><p>这里就回答其中一个问题：</p><blockquote><p><strong>css</strong> 样式代码根据什么规则生成的？</p></blockquote><p>不能遗漏的是：添加样式代码到入口文件时，相关 <strong>themePluginOption</strong> 配置将被赋值到 <strong>window.__theme_COLOR_cfg</strong> 作为入口文件的一部分代码，供客户端使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getEntryJs(outputName, assetSource, cssCode) &#123;</span><br><span class="line">  <span class="keyword">var</span> config = &#123;<span class="attr">url</span>: outputName, <span class="attr">colors</span>: <span class="keyword">this</span>.options.matchColors&#125;</span><br><span class="line">  <span class="keyword">var</span> configJs = <span class="string">'\n(typeof window==\'undefined\'?global:window).__theme_COLOR_cfg='</span> + <span class="built_in">JSON</span>.stringify(config) + <span class="string">';\n'</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ConcatSource(assetSource, configJs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主题样式请求怎么发起？"><a href="#主题样式请求怎么发起？" class="headerlink" title="主题样式请求怎么发起？"></a>主题样式请求怎么发起？</h1><p>我们以页面的主题设置为入口，看下 <strong>SettingDrawer</strong> 组件内部的功能。</p><p>首先该组件提供了这些配置选项：</p><img src="/legacy/2021/06/24/website-dynamic-theme-replacer/settingDrawer.png" class="" title="UI展示"><p>在该项目中，会发现有 <strong>config\themePluginConfig.js</strong> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config\themePluginConfig.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  theme: [</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">"#F5222D"</span>,</span><br><span class="line">      fileName: <span class="string">"#F5222D.css"</span>,</span><br><span class="line">      modifyVars: &#123;</span><br><span class="line">        <span class="string">"@primary-color"</span>: <span class="string">"#F5222D"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      key: <span class="string">"#FA541C"</span>,</span><br><span class="line">      fileName: <span class="string">"#FA541C.css"</span>,</span><br><span class="line">      modifyVars: &#123;</span><br><span class="line">        <span class="string">"@primary-color"</span>: <span class="string">"#FA541C"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你熟悉 <strong>Ant Design Pro</strong>，那么在 <strong><a href="https://pro.ant.design/docs/dynamic-theme-cn" target="_blank" rel="noopener">动态主题</a></strong> 中也能看到一样的配置，其通过 <strong>umi-plugin-antd-theme</strong> 进行设置。</p><p>这些配置在程序启动时，就挂载至 <strong>window.umi_plugin_ant_themeVar</strong> 下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">window</span>.umi_plugin_ant_themeVar = themePluginConfig.theme;</span><br></pre></td></tr></table></figure><p>作为页面主题的调色板元数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getThemeList = <span class="function"><span class="keyword">function</span> <span class="title">getThemeList</span>(<span class="params">i18nRender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="built_in">window</span>.umi_plugin_ant_themeVar || [];</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  list.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = (item.modifyVars || &#123;&#125;)[<span class="string">"@primary-color"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    lightColorList.push(</span><br><span class="line">      _objectSpread(</span><br><span class="line">        &#123;</span><br><span class="line">          color: color,</span><br><span class="line">        &#125;,</span><br><span class="line">        item</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    colorList: &#123;</span><br><span class="line">      dark: darkColorList,</span><br><span class="line">      light: lightColorList,</span><br><span class="line">    &#125;,</span><br><span class="line">    themeList: themeList,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当主题颜色修改时，则会触发更新主题方法 <strong>updateTheme()</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleChangeSetting</span>(<span class="params">key, value, hideMessageLoading</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">"primaryColor"</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新主色调</span></span><br><span class="line">    updateTheme(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>updateTheme</strong> 会调用 <strong>themeColor.changeColor</strong> 方法，生成新的主题色系 <strong>newColors</strong> ，再交给 <strong>webpack-theme-color-replacer/client</strong> 处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> themeColor = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  changeColor: <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">newColor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">      newColors: <span class="keyword">this</span>.getAntdSerials(newColor),</span><br><span class="line">      <span class="comment">// new colors array, one-to-one corresponde with `matchColors`</span></span><br><span class="line">      changeUrl: <span class="function"><span class="keyword">function</span> <span class="title">changeUrl</span>(<span class="params">cssUrl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span>.concat(cssUrl); <span class="comment">// while router is not `hash` mode, it needs absolute path</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> client.changer.changeColor(options, <span class="built_in">Promise</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>webpack-theme-color-replacer/client</strong> 中定义了如何更改主题色的逻辑，注意这里会用到前面 <strong>plugins</strong> 中定义的 <strong>__theme_COLOR_cfg</strong> 变量，如此确认了主题色系 <strong>oldColors</strong> 和样式请求地址 <strong>cssUrl</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-theme-color-replacer\client\themeColorChanger.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  changeColor: <span class="function"><span class="keyword">function</span> (<span class="params">options, promiseForIE</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">if</span> (!theme_COLOR_config) &#123;</span><br><span class="line">        theme_COLOR_config = win().__theme_COLOR_cfg;</span><br><span class="line">        <span class="keyword">var</span> later = retry();</span><br><span class="line">        <span class="comment">//重试直到theme_COLOR_config加载</span></span><br><span class="line">        <span class="keyword">if</span> (later) <span class="keyword">return</span> later;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> oldColors = options.oldColors || theme_COLOR_config.colors || [];</span><br><span class="line">      <span class="keyword">var</span> newColors = options.newColors || [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> cssUrl = theme_COLOR_config.url || options.cssUrl;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      setCssText(last, cssUrl, resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>setCssText</strong> 方法中，会去寻找 <strong>id</strong> 为 <strong>css_xxx</strong> 的 <strong>style</strong> 标签，并调用 <strong>getCssString()</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCssText</span>(<span class="params">last, url, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="string">"css_"</span> + +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  elStyle = <span class="built_in">document</span></span><br><span class="line">    .querySelector(options.appendToEl || <span class="string">"body"</span>)</span><br><span class="line">    .appendChild(<span class="built_in">document</span>.createElement(<span class="string">"style"</span>));</span><br><span class="line"></span><br><span class="line">  elStyle.setAttribute(<span class="string">"id"</span>, id);</span><br><span class="line"></span><br><span class="line">  _this.getCssString(</span><br><span class="line">    url,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">cssText</span>) </span>&#123;</span><br><span class="line">      setCssTo(cssText);</span><br><span class="line">      _urlColors[url] = &#123; <span class="attr">id</span>: id, <span class="attr">colors</span>: newColors &#125;;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;,</span><br><span class="line">    reject</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getCssString()</strong> 内通过 <strong>xhr</strong> 来发动主题样式文件的请求。从而回答了第二个问题：</p><blockquote><p>请求 <strong>/css/theme-colors-xxx.css</strong> 哪里发起的？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getCssString: <span class="function"><span class="keyword">function</span> (<span class="params">url, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> css = win().__theme_COLOR_css;</span><br><span class="line">    <span class="keyword">if</span> (css) &#123;</span><br><span class="line">      <span class="comment">// css已内嵌在js中</span></span><br><span class="line">      win().__theme_COLOR_css = <span class="string">""</span>;</span><br><span class="line">      resolve(css);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    xhr.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用完 <strong>getCssString</strong> 后，将得到 <strong>cssText</strong> 代码。然后通过 <strong>setCssTo</strong> 替换新老颜色，这就回答了最后个问题：</p><blockquote><p>主题色的切换，页面怎么快速做样式更新的？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCssTo</span>(<span class="params">cssText</span>) </span>&#123;</span><br><span class="line">  cssText = _this.replaceCssText(cssText, oldColors, newColors);</span><br><span class="line">  elStyle.innerText = cssText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceCssText</span>(<span class="params">cssText, oldColors, newColors</span>) </span>&#123;</span><br><span class="line">  oldColors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">color, t</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//#222、#222223、#22222350、222, 255,3 =&gt; #333、#333334、#33333450、211,133,53、hsl(27, 92.531%, 52.745%)</span></span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">      color.replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>).replace(<span class="regexp">/,/g</span>, <span class="string">",\\s*"</span>) +</span><br><span class="line">        <span class="string">"([\\da-f]&#123;2&#125;)?(\\b|\\)|,|\\s)"</span>,</span><br><span class="line">      <span class="string">"ig"</span></span><br><span class="line">    );</span><br><span class="line">    cssText = cssText.replace(reg, newColors[t] + <span class="string">"$1$2"</span>); <span class="comment">// 255, 255,3</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> cssText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有个好处，有关主题颜色的样式文件只在首次加载，后续通过替换 <strong>style</strong> 标签内容，从而达到主题切换。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>webpack-theme-color-replacer</strong> 是个很小众的库，github 才 200 个 Star。但它的确解决了产品上某些问题。</p><p>有时候我们每天忙碌于业务代码的“搬砖”中，枯燥乏味。作为一个软件程序员，除了完成需求外，还需要更多的思考业务，来促使代码有更多的扩展性。</p><p>如果你说业务固定不变，或者离我太远，也可以发现开发中的“重复性劳动”，将 ctrl C/V 最大程度地程序化。什么页面可视化搭建，低代码平台可不光光是 KPI 产物，我觉得它们能促使开发人员有更多时间思考，去挖掘更高的价值。</p><p>最后，还是需要不断纵向学习，本篇只简单说了该插件的工作过程。但它内部有关生成调色板的逻辑，怎么解析 css 代码，怎么和 webpack 融合都没有呈现出来，更多需要你去深究，别想用到时方恨少。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在 hexo 博客中，集成 gitalk 评论插件</title>
      <link href="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/"/>
      <url>/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的 <strong>hexo</strong> 站点跑了 2 年多，自从多说凉了后，就没法看到访客的反馈。</p><p>有幸前阵子看到了 <strong>gitalk</strong>，一款和 <strong>gitment</strong> 一样的评论插件，评论数据都被国人骚操存储在 <strong>github issues</strong> 中，也免去管理后台查看，很是方便。</p><p>这篇就来看下， <strong>hexo</strong> 如何集成 <strong>gitalk</strong> 吧。</p><h1 id="Github-添加-OAuth-Apps-授权应用"><a href="#Github-添加-OAuth-Apps-授权应用" class="headerlink" title="Github 添加 OAuth Apps 授权应用"></a>Github 添加 OAuth Apps 授权应用</h1><ol><li><p>登录 <strong>Github</strong> ，右键头像，在下拉菜单中，选择“<strong>Settings</strong>”选项</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-oauth-setting-1.png" class="" title="github授权应用设置1"></li><li><p>在左侧菜单选择“<strong>Developer settings</strong>”选项，进入开发者页面</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-oauth-setting-2.png" class="" title="github授权应用设置2"></li><li><p>选择 <strong>OAuth Apps</strong> ，并点击“<strong>New OAuth App</strong>”创建新授权应用</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-oauth-setting-3.png" class="" title="github授权应用设置3"></li><li><p>设置该应用相关信息</p><ul><li>Application name 应用名称</li><li>Homepage URL 博客主页</li><li>Authorization callback URL 授权回调页面（同 Homepage URL）</li></ul><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-oauth-setting-4.png" class="" title="github授权应用设置4"></li><li><p>保存好 <strong>Client ID</strong> 和 <strong>Client secrets</strong>，后续初始化 <strong>gitalk</strong> 需要</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-oauth-setting-5.png" class="" title="github授权应用设置5"></li></ol><h1 id="Hexo-添加-gitalk-模板"><a href="#Hexo-添加-gitalk-模板" class="headerlink" title="Hexo 添加 gitalk 模板"></a>Hexo 添加 gitalk 模板</h1><p>为了在每篇文章底部嵌入评论模块，需要在 <strong>hexo</strong> 对应的主体 <strong>post</strong> 模板中添加相关代码。</p><p>进入到 <strong>themes\next\layout_macro\post.swig</strong>（我的博客是基于 Next，如果有差异，替换路径中的 next 即可），添加 <strong>gitalk</strong> 模板文件的导入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &#123;### Line 357，如果行数有差异，只需要在 POST END 文章结束后添加即可 ###&#125; --&gt;</span></span><br><span class="line">&#123;% if theme.git_talk.enabled and not is_index %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;% include 'git-talk.swig' %&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>因为需要用到 <strong>Client ID</strong> 和 <strong>Client secrets</strong>，可以在对应主题的配置文件 <strong>themes\next_config.yml</strong> 中，将这两个参数配置化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">git_talk:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">clientID:</span> <span class="string">xxxxxxxxx</span></span><br><span class="line">  <span class="attr">clientSecret:</span> <span class="string">xxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure><p>然后添加 <strong>git-talk.swig</strong> 文件（<strong>themes\next\layout_macro\git-talk.swig</strong>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span></span><br><span class="line"><span class="actionscript">    clientID: <span class="string">"&#123;&#123;theme.git_talk.clientID&#125;&#125;"</span>,</span></span><br><span class="line"><span class="actionscript">    clientSecret: <span class="string">"&#123;&#123;theme.git_talk.clientSecret&#125;&#125;"</span>,</span></span><br><span class="line"><span class="actionscript">    repo: <span class="string">"eminoda.github.io"</span>, <span class="comment">// 博客仓库地址</span></span></span><br><span class="line"><span class="actionscript">    owner: <span class="string">"eminoda"</span>, <span class="comment">// github 用户名</span></span></span><br><span class="line"><span class="actionscript">    admin: [<span class="string">"eminoda"</span>], <span class="comment">// github 用户名</span></span></span><br><span class="line">    perPage: 20,</span><br><span class="line"><span class="actionscript">    id: location.pathname.slice(<span class="number">0</span>, <span class="number">50</span>), <span class="comment">// 查找 issus 的条件，后面将对 id 有针对逻辑</span></span></span><br><span class="line"><span class="actionscript">    title: <span class="string">"&#123;&#123;page.title&#125;&#125;"</span>,</span></span><br><span class="line"><span class="actionscript">    body: <span class="string">"🚀 "</span> + location.href + <span class="string">"\n\n欢迎通过 issues 留言 ，互相交流学习😊"</span>, <span class="comment">// 初始化后，issues 的内容</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  gitalk.render(<span class="string">"gitalk-container"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>gitalk</strong> 插件的逻辑是这样的：</p><p>首先，查询该 <strong>repo</strong> 仓库里 <strong>issues</strong> 中是否有 <strong>id</strong> 的记录，如果没有，则需要对应管理员 <strong>admin</strong> （也就是博主）来进行 <strong>issue</strong> 的创建。</p><p>当对应 <strong>admin</strong> 在页面点击创建后，<strong>gitalk</strong> 将在 <strong>issues</strong> 新增一条记录（该 <strong>issue</strong> 的内容就是 <strong>new Gitalk</strong> 中的 <strong>body</strong>）：</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-issue.png" class="" title="新增 issue"><p>如果 <strong>issue</strong> 已创建，当前授权的访客将通过 <strong>gitalk</strong> 做评论回复。我们整个博客地评论体系就达成了。</p><h1 id="历史文章批量初始化"><a href="#历史文章批量初始化" class="headerlink" title="历史文章批量初始化"></a>历史文章批量初始化</h1><p>对于一个刚起步的博客站点没有任何问题，新增一篇文章，初始化下 <strong>issue</strong>，顺手的事情。</p><p>但对于一个历史站点，里面可能有百篇文章，如果希望看到别人阅读的回复，则需要人工每篇进行初始化，不太现实，则需要程序来批量初始化。</p><p>这里需要注意：</p><ul><li><strong>gitalk</strong> 初始化中的 <strong>id</strong> 参数，需要通过 <strong>hash</strong> 算法计算一个相对准确的唯一摘要，用于判断 <strong>issue</strong> 是否初始化过</li><li>需要调用 Github API 来得知目前 <strong>issues</strong> 的情况，接口调用有 <a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting" target="_blank" rel="noopener">频率限制</a>，对于未授权的接口 60 个/小时，授权接口 5000 个/小时</li><li>开启 <strong>OAuth</strong> 认证，需要在 <strong>Developer Setting</strong> 开启 <strong>Personal access tokens</strong></li></ul><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/github-token.png" class="" title="token设置"><p>下面新建 <strong><a href="https://github.com/eminoda/myBlog/blob/master/eminoda.github.io/gittalk-batch.js" target="_blank" rel="noopener">gittalk-batch.js</a></strong> 来批量初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">"axios"</span>);</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">"blueimp-md5"</span>);</span><br><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">"yaml-js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// github 配置</span></span><br><span class="line"><span class="keyword">const</span> github = &#123;</span><br><span class="line">  token: <span class="string">""</span>, <span class="comment">// 创建 Personal access tokens 得到（需要保护好）</span></span><br><span class="line">  clientID: <span class="string">"f5e934819613a06d3a38"</span>,</span><br><span class="line">  clientSecret: <span class="string">"f9ff1926fed5174d6f6e438e5e37dd5341af81fe"</span>,</span><br><span class="line">  owner: <span class="string">"eminoda"</span>,</span><br><span class="line">  repo: <span class="string">"eminoda.github.io"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ISSUES_API = <span class="string">"https://api.github.com/repos/"</span> + github.owner + <span class="string">"/"</span> + github.repo + <span class="string">"/issues"</span>;</span><br><span class="line"><span class="keyword">const</span> POST_DIR = path.join(__dirname, <span class="string">"/source/_posts"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 Rate Limiting 限速问题（目前没用）</span></span><br><span class="line"><span class="keyword">const</span> lazyTimer = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> fn();</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化创建 Issues</span></span><br><span class="line"><span class="keyword">const</span> createIssues = <span class="keyword">async</span> (&#123; title, id, filePath, hrefTitle &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> errMsg = [];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 是否初始化过</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>: issues &#125; = <span class="keyword">await</span> axios.get(ISSUES_API, &#123;</span><br><span class="line">      params: &#123; <span class="attr">labels</span>: [<span class="string">"Gitalk"</span>, id].join(<span class="string">","</span>) &#125;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        Authorization: <span class="string">"token "</span> + github.token,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!issues || issues.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(filePath, <span class="string">"正在创建 issues ..."</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开始初始化</span></span><br><span class="line">        <span class="keyword">await</span> axios.post(</span><br><span class="line">          ISSUES_API,</span><br><span class="line">          &#123;</span><br><span class="line">            body: <span class="string">"🚀 "</span> + <span class="string">"https://eminoda.github.io"</span> + hrefTitle + <span class="string">"\n\n欢迎通过 issues 留言 ，互相交流学习😊"</span>,</span><br><span class="line">            labels: [<span class="string">"Gitalk"</span>, id],</span><br><span class="line">            title,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            headers: &#123;</span><br><span class="line">              Authorization: <span class="string">"token "</span> + github.token,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">console</span>.log(filePath, <span class="string">"创建完毕"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(filePath, <span class="string">"创建失败"</span>);</span><br><span class="line">        errMsg.push(&#123; filePath, <span class="attr">msg</span>: <span class="string">"生成 issues 错误"</span>, err &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(filePath, <span class="string">"已存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(filePath, <span class="string">"查询失败"</span>);</span><br><span class="line">    errMsg.push(&#123; filePath, <span class="attr">msg</span>: <span class="string">"新建 issues 错误"</span>, err &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> errMsg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pFn = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 post 文件夹，判断有多少文章需要创建评论模块</span></span><br><span class="line">fs.readdirSync(POST_DIR).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = path.join(POST_DIR, item);</span><br><span class="line">  <span class="keyword">const</span> stat = fs.statSync(filePath);</span><br><span class="line">  <span class="keyword">if</span> (stat &amp;&amp; !stat.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">const</span> str = fs.readFileSync(filePath).toString();</span><br><span class="line">    <span class="keyword">const</span> yamlStr = str.split(<span class="string">"---"</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (yamlStr) &#123;</span><br><span class="line">      <span class="keyword">const</span> title = yaml.load(yamlStr).title;</span><br><span class="line">      <span class="keyword">const</span> hrefTitle = <span class="string">"/"</span> + item.slice(<span class="number">0</span>, <span class="number">10</span>).replace(<span class="regexp">/-/g</span>, <span class="string">"/"</span>) + <span class="string">"/"</span> + item.slice(<span class="number">11</span>).split(<span class="string">".md"</span>)[<span class="number">0</span>] + <span class="string">"/"</span>;</span><br><span class="line">      <span class="keyword">const</span> id = md5(hrefTitle);</span><br><span class="line">      pFn.push(<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</span><br><span class="line">        lazyTimer(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">          <span class="keyword">await</span> createIssues(&#123; title, id, filePath, hrefTitle &#125;);</span><br><span class="line">          next();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// pFn.push(createIssues(&#123; title, id, filePath &#125;));</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次发送请求，copy koa-compose</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">pFns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = pFns[i];</span><br><span class="line">      <span class="comment">// 最后次</span></span><br><span class="line">      <span class="keyword">if</span> (i == pFns.length) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(pFn)(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"over"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次修改 <strong>git-talk.swig</strong>，根据上面的 <strong>id</strong> 调整 <strong>gitalk</strong> 中 <strong>id</strong> 值，通过 <strong>md5</strong> 算出页面地址对应的 <strong>hash</strong> 值作为 <strong>issue</strong> 主键：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 前端页面添加 md5 文件（blueimp-md5） --&gt;</span></span><br><span class="line">&#123;% set md5_js_uri = url_for('/lib/md5/md5.min.js') %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; md5_js_uri &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">    id: md5(<span class="string">"&#123;&#123;url_for(page.path)&#125;&#125;"</span>),</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// ...</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  gitalk.render(<span class="string">"gitalk-container"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="安全授权问题"><a href="#安全授权问题" class="headerlink" title="安全授权问题"></a>安全授权问题</h1><p>由于用户评论需要通过 <strong>Github OAuth</strong> 授权给 <strong>gitalk</strong>，中间 <strong>gitalk</strong> 会在浏览器的 <strong>localStorage</strong> 中保存 <strong>GT_ACCESS_TOKEN</strong>，这个 <strong>token</strong> 权限过于粗大。</p><p>对于 <a href="https://www.v2ex.com/t/535608" target="_blank" rel="noopener">不怀好意</a> 的博客站点，可能会利用这个 <strong>token</strong> 做一些我们预料不到的事情，甚至于删库跑路。</p><p>目前解决方案过于复杂，完全背离使用这个插件的便利性，无论对博主还是访客。所以对于访客还需甄别 <strong>网站的质量</strong>。</p><p>为了避免访客的顾虑问题，我在 <strong>git-talk.swig</strong> 模板中添加了跳转 github issues 的链接选项（这里不过多展开，有兴趣<a href="https://github.com/eminoda/myBlog/blob/master/eminoda.github.io/themes/next/layout/_macro/git-talk.swig" target="_blank" rel="noopener">可以看下</a>）</p><img src="/legacy/2021/06/16/hexo-gitalk-comment-plugins-in-github-issue/gitalk-safe.png" class=""><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://iochen.com/post/use-gitalk-in-hexo/" target="_blank" rel="noopener">Hexo 中 Gitalk 配置使用教程-可能是目前最详细的教程</a></li><li><a href="https://blog.jijian.link/2020-01-10/hexo-gitalk-auto-init/" target="_blank" rel="noopener">hexo gitalk 评论自动初始化</a></li><li><a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">报错出现 Error: Validation Failed.</a></li><li><a href="https://hexo.io/zh-cn/docs/variables.html#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">hexo 全局页面变量</a></li><li><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting" target="_blank" rel="noopener">Github Rate limiting</a></li><li><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#oauth2-token-sent-in-a-header" target="_blank" rel="noopener">Github oauth2-token</a></li><li><a href="https://www.v2ex.com/t/535608" target="_blank" rel="noopener">建议大家弃用 Gitalk 和 Gitment 等权限过高的 Github OAuth App</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gitalk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧，如何使用 webpack 降低前端资源文件维护成本</title>
      <link href="/legacy/2021/04/29/webpack-extract-node-modules-files/"/>
      <url>/legacy/2021/04/29/webpack-extract-node-modules-files/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端现在开发某个常见功能，直接会在 <strong>npm</strong> 找到合适的包，这些包存在于 <strong>node_modules</strong> 目录下。</p><p>如何减少包体积，用下 CDN 加速，或者这个模块只有 <strong>script</strong> 标签导入方式时，直接从 <strong>node_modules</strong> 拷贝文件到项目 <strong>public</strong> 资源目录中是常见的<strong>懒操作</strong>，久而久之，那个目录文件会非常多，尤其当这个项目成为“历史项目”后，那堆文件会变得让后人难以维护。</p><p>下面将介绍 2 个小技巧，如何使用 <strong>webpack</strong> 的 <strong>copy-webpack-plugin</strong> 和 <strong>script-loader</strong> 来优化 <strong>node_modules</strong> 文件和项目依赖关系，来降低日后的维护成本。</p><h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><p>这是个简单的文件复制工具插件，用于把某文件从 A 目录 copy 到 B 目录。</p><p>原先我们手工拷贝流程如下：</p><ol><li>在资源文件夹（dist/public）新建 <strong>libs/js/jquery</strong> 目录</li><li>把 <strong>node_modules</strong> 下的 jquery 相关依赖复制到上述目录中</li></ol><img src="/legacy/2021/04/29/webpack-extract-node-modules-files/copy-old.png" class=""><p>似乎没什么问题，一两个文件影响不了项目可读性，但对于一个老项目来说乱七八糟的 js 依赖，以及完全脱离工程化的构建方式是极具风险的，万一哪天谁删资源跑路，都是隐患。</p><p>我不会告诉你，我在 pdfjs-dist 中引入 cmaps 文件夹提交了多少文件，强迫症表示接受不了。</p><p>对于 <strong>copy-webpack-plugin</strong> 使用也非常简单，毕竟现在 <strong>webpack</strong> 都到 5 了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CopyPlugin(&#123;</span><br><span class="line">    <span class="comment">// 输出路径默认 output.path 下</span></span><br><span class="line">    patterns: [&#123; <span class="attr">from</span>: <span class="string">'node_modules/jquery/dist'</span>, <span class="attr">to</span>: <span class="string">'js/libs/jquery'</span> &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><img src="/legacy/2021/04/29/webpack-extract-node-modules-files/copy-new.png" class=""><p>这样，项目目录就变得清爽多了，也不用了继续维护相关的资源文件内容了，每次打包构建都交给 <strong>webpack</strong> 帮我们从 <strong>node_modules</strong> 找到资源文件。</p><p>并且，根据需要可以详细设置目标文件的路径，使项目以后可以灵活调整，减少维护成本。</p><p>哦对了，如果你还在用 <strong>webpack4</strong> ，此插件不要使用 7 和 8 两个版本。</p><h2 id="script-loader"><a href="#script-loader" class="headerlink" title="script-loader"></a>script-loader</h2><p>上面使用 <strong>copy-webpack-plugin</strong> 插件只是变相的对项目进行<strong>工程化管理</strong>，实际输出到资源目录的文件还是一样；但下面说的 <strong>script-loader</strong> 将减少实际资源目录物理文件数量，从而使项目文件量“瘦身”。</p><p>以通过 <strong>webpack</strong> 的 <strong>externals</strong> 引入 <strong>jquery</strong> 模块举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    jquery: <span class="string">'jQuery'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure><p>像上述用法会在 <strong>html</strong> 中额外添加 <strong>script</strong> 以加载 <strong>jquery</strong> 文件，同时对应的资源文件目录会有这个 <strong>jquery.js</strong> 文件存在，但有时我们希望减少这样的物理文件的存在，更希望把 <strong>node_modules</strong> 中的依赖集中打包到项目 <strong>bundle.js</strong> 中。</p><p><strong>webpack</strong> 的 <strong>loader</strong> 提供 <a href="https://webpack.js.org/concepts/loaders/#inline" target="_blank" rel="noopener"><strong>Inline</strong> 方式</a>，使之我们不用再 <strong>module</strong> 中编写对应的规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'script-loader!jquery/dist/jquery.js'</span>;</span><br></pre></td></tr></table></figure><p>这样，我们减少了物理文件数，同时<strong>使某些插件功能更集中在业务代码中，减少某些外界变化导致依赖功能的不可用</strong>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面两个方法都很常见，我最近在看 <strong>pdfjs-dist</strong> 模块的 <strong>Demo</strong> 时看到了这样的使用便拿来和大家分享。</p><p>有时候我们追求不是技术的高深和多样，能用最简单的技术方案在某个场景解决问题才是有经验开发者应该具备的能力。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用 cavans 实现签名手写板</title>
      <link href="/legacy/2021/04/21/canvas-signature/"/>
      <url>/legacy/2021/04/21/canvas-signature/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>web 手写板是个比较常见的需求了，多用在需要用户进行签名认证的业务中。</p><p><strong>canvas</strong> 作为 H5 的新标签，适用于 <strong>动态绘制</strong> 复杂的 <strong>高分辨率</strong> 图形，是此类需求的最好方案。</p><p>但在实际开发中，遇到了几个问题：</p><ul><li>如何用 canvas 做笔迹跟随？</li><li>有没有第三方签名插件？</li><li>横竖屏切换问题？</li></ul><p>这篇围绕这几个问题进行解答说明。</p><h1 id="canvas-笔迹跟随"><a href="#canvas-笔迹跟随" class="headerlink" title="canvas 笔迹跟随"></a>canvas 笔迹跟随</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">MDN 提供了 Canvas 入门的详细文档</a>，基本常用 API 的都能直接找到。</p><h2 id="创建-canvas-画布及画笔样式"><a href="#创建-canvas-画布及画笔样式" class="headerlink" title="创建 canvas 画布及画笔样式"></a>创建 canvas 画布及画笔样式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvasEl = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvasEl.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> rootEl = <span class="built_in">document</span>.getElementById(<span class="string">'signature'</span>);</span><br><span class="line">rootEl.appendChild(canvasEl);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.strokeStyle = <span class="string">'#000'</span>;</span><br><span class="line">ctx.lineWidth = <span class="number">5</span>;</span><br><span class="line">ctx.lineCap = <span class="string">'round'</span>;</span><br><span class="line">ctx.lineJoin = <span class="string">'round'</span>;</span><br><span class="line">ctx.shadowBlur = <span class="number">1</span>;</span><br><span class="line">ctx.shadowColor = <span class="string">'#000'</span>;</span><br></pre></td></tr></table></figure><h2 id="定义“画笔”事件"><a href="#定义“画笔”事件" class="headerlink" title="定义“画笔”事件"></a>定义“画笔”事件</h2><p>首先，结合 getBoundingClientRect 能获取画笔在画布中的坐标值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touches = event.touches[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> rect = canvasEl.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">var</span> x = touches.clientX - rect.left;</span><br><span class="line">  <span class="keyword">var</span> y = touches.clientY - rect.top;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据画笔绘制过程，拆分为三个状态：开始绘制（记录 canvas 起始点），笔迹跟随，绘制完成（事件释放）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ctx.beginPath.apply(ctx, getPoint(event));</span><br><span class="line">  canvasEl.addEventListener(<span class="string">'touchmove'</span>, drawSign, <span class="literal">false</span>);</span><br><span class="line">  canvasEl.addEventListener(<span class="string">'touchend'</span>, removeEvent, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轨迹移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  canvasEl.removeEventListener(<span class="string">'touchmove'</span>, drawSign, <span class="literal">false</span>);</span><br><span class="line">  canvasEl.removeEventListener(<span class="string">'touchend'</span>, removeEvent, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSign</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> point = getPoint(event);</span><br><span class="line">  ctx.lineTo.apply(ctx, point);</span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvasEl.addEventListener(<span class="string">'touchstart'</span>, startEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h2><img src="/legacy/2021/04/21/canvas-signature/canvas-demo.gif" class="" title="笔迹跟随"><h1 id="jSignature"><a href="#jSignature" class="headerlink" title="jSignature"></a>jSignature</h1><p>上面虽然完成了功能，只是简单的 Demo，实际更偏向使用更稳定的第三方插件： <strong>jSignature</strong> 是个比较好的选择。</p><p>它依赖 <strong>jQuery</strong> ，对于不支持 <strong>canvas</strong> 的浏览器有降级处理，同时对笔迹绘制，图形导出有优化，对比我们 Demo，其有更好的稳定性和扩展性。</p><p><strong>jSignature</strong> 提供了<a href="http://brinley.github.io/jSignature/" target="_blank" rel="noopener">线上 demo</a>，可以直接看效果。</p><p>伪代码如下（Vue）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 画布 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"signature"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 操作栏... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      submit() &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 获取签名图片</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = $(<span class="string">'#signature'</span>).jSignature(<span class="string">'getData'</span>, <span class="string">'image'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> base64Img = <span class="string">'data:'</span> + data.join(<span class="string">','</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 渲染画布</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $sigdiv = $(<span class="string">'#signature'</span>).jSignature(&#123; <span class="attr">height</span>: height + <span class="string">'px'</span>, <span class="attr">width</span>: width + <span class="string">'px'</span> &#125;);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后页面效果如下：</p><img src="/legacy/2021/04/21/canvas-signature/jsign-demo.png" class="" title="jSignature-demo"><h1 id="屏幕旋转问题"><a href="#屏幕旋转问题" class="headerlink" title="屏幕旋转问题"></a>屏幕旋转问题</h1><h2 id="如何切换横屏"><a href="#如何切换横屏" class="headerlink" title="如何切换横屏"></a>如何切换横屏</h2><p>这个问题很简单，对 css 添加个属性 <strong>transform</strong> 旋转属性便可，但会发现旋转 90° 后页面出现了异常：</p><img src="/legacy/2021/04/21/canvas-signature/rotate-error.gif" class="" title="旋转异常"><p>顶部导航栏栏，按钮操作栏都消失了，画布也错位。</p><h2 id="旋转后，页面显示异常"><a href="#旋转后，页面显示异常" class="headerlink" title="旋转后，页面显示异常"></a>旋转后，页面显示异常</h2><p>这是因为旋转的整个元素按着页面中心进行旋转（横竖屏切换），之后需要重新对页面旋转后的宽高进行置换：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">360px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">640px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于宽高调整后，旋转的中心改变了，需要对偏移量进行修复。</p><img src="/legacy/2021/04/21/canvas-signature/rotate-device.png" class="" title="旋转中心"><p>这个偏移量起始先对未旋转前的页面计算旋转中心点（已重置过宽高），假设坐标原点在左上角，那么坐标值为：(320,180)</p><p>当旋转 90° 后，坐标值更换为：(180，320)，需要对 320-180=140 进行偏移重置。那么 css 样式更新为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">360px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">640px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">140px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">140px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后旋转后的页面将恢复正常：</p><img src="/legacy/2021/04/21/canvas-signature/rotate-fix.png" class="" title="偏移重置后"><h2 id="画布错位"><a href="#画布错位" class="headerlink" title="画布错位"></a>画布错位</h2><p>当绘制签名时，会发现画布显示异常，绘制位置和实际笔迹出现的位置不同（被旋转 90°），而且画布也非旋转后的大小。</p><img src="/legacy/2021/04/21/canvas-signature/rotate-canvas-error.gif" class="" title="画布错位"><p>旋转后画布实际区域如下：</p><img src="/legacy/2021/04/21/canvas-signature/rotate-error.png" class="" title="画布实际区域"><p>虽然 <strong>画板区域</strong> 是在页面旋转后生成，但画布所挂载的节点受旋转的影响。所以对于画布需要“撤销”旋转的 90° 影响，同时画布在生成前需要根据旋转后实际呈现的高宽指定生成。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算画布宽高（去除顶部和底部导航*系数）</span></span><br><span class="line">calcBoard(isHorizontal, ratio = <span class="string">'0.8'</span>) &#123;</span><br><span class="line">    <span class="comment">// 顶部，底部导航</span></span><br><span class="line">    <span class="keyword">const</span> titleRect = $(<span class="string">'.van-nav-bar'</span>)[<span class="number">0</span>].getBoundingClientRect();</span><br><span class="line">    <span class="keyword">const</span> bottomRect = $(<span class="string">'#tools'</span>)[<span class="number">0</span>].getBoundingClientRect();</span><br><span class="line">    <span class="comment">// 横版</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isHorizontal) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            height: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">            width: (<span class="built_in">window</span>.innerWidth - titleRect.width - bottomRect.width) * ratio,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 竖版</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        height: (<span class="built_in">window</span>.innerHeight - titleRect.height - bottomRect.height) * ratio,</span><br><span class="line">        width: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 反转画布绘制区域</span></span><br><span class="line">canvanRevert(isHorizontal, boardHeight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHorizontal) &#123;</span><br><span class="line">        <span class="comment">// 固定旋转点</span></span><br><span class="line">        <span class="comment">// 偏移画布高度+title高度</span></span><br><span class="line">        <span class="keyword">const</span> titleRect = $(<span class="string">'.van-nav-bar'</span>)[<span class="number">0</span>].getBoundingClientRect();</span><br><span class="line">        $(<span class="string">'#signature .jSignature'</span>).css(&#123;</span><br><span class="line">            transform: <span class="string">'rotate(-90deg)'</span>,</span><br><span class="line">            position: <span class="string">'absolute'</span>,</span><br><span class="line">            <span class="string">'transform-origin'</span>: <span class="string">`0 0`</span>,</span><br><span class="line">            <span class="comment">// header + 画板高度</span></span><br><span class="line">            top: titleRect.width + boardHeight + <span class="string">'px'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">'#signature .jSignature'</span>).css(&#123;</span><br><span class="line">            transform: <span class="string">'none'</span>,</span><br><span class="line">            position: <span class="string">'unset'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取画板宽高</span></span><br><span class="line"><span class="keyword">const</span> &#123; height, width &#125; = <span class="keyword">this</span>.calcBoard(isHorizontal);</span><br><span class="line"><span class="comment">// 绘制画板</span></span><br><span class="line">$(<span class="string">'#signature'</span>).jSignature(&#123; <span class="attr">height</span>: height + <span class="string">'px'</span>, <span class="attr">width</span>: width + <span class="string">'px'</span> &#125;);</span><br><span class="line"><span class="comment">// 反转画布绘制区域</span></span><br><span class="line"><span class="keyword">this</span>.canvanRevert(<span class="keyword">this</span>.isHorizontal, width);</span><br></pre></td></tr></table></figure><p>最后，签名绘制和笔迹呈现保持了一致。</p><h2 id="tip-弹框错位"><a href="#tip-弹框错位" class="headerlink" title="tip 弹框错位"></a>tip 弹框错位</h2><p>虽然上面对画布区域进行了“额外处理”使整个页面显示正常，但实际交互中会有一些 tip 或者弹框提示，这些元素由于是新挂载到页面某些节点上的，没有受旋转影响，就会有如下非预期展示：</p><img src="/legacy/2021/04/21/canvas-signature/tip.png" class="" title="tip异常"><p>而我们不可能见一个修改一个，需要全局的观察这类元素变动，进行错位展示的重置。</p><p>这时我们可以借助 <strong>MutationObserver</strong> 来对这些元素进行监听，来反转 90° 重置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">listenElementChange() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">        mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mutation.type == <span class="string">'attributes'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> targetEl = $(<span class="string">'.van-toast'</span>);</span><br><span class="line">            <span class="comment">// 匹配 toast</span></span><br><span class="line">            <span class="keyword">if</span> (targetEl[<span class="number">0</span>] == mutation.target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mutation.target.getAttribute(<span class="string">'class'</span>).indexOf(<span class="string">'van-fade'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                targetEl.css(&#123;</span><br><span class="line">                    transform: self.isHorizontal ? <span class="string">'rotate(90deg)'</span> : <span class="string">''</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    observer.observe(<span class="built_in">window</span>.document.body, &#123;</span><br><span class="line">        subtree: <span class="literal">true</span>,</span><br><span class="line">        childList: <span class="literal">true</span>,</span><br><span class="line">        attributes: <span class="literal">true</span>,</span><br><span class="line">        attributeFilter: [<span class="string">'style'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决上述几个问题后，最后效果如下：</p><img src="/legacy/2021/04/21/canvas-signature/jsign-rotate-demo.gif" class="" title="完整效果">]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助 wireshark 网络分析工具，剖析 TCP 三次握手流程</title>
      <link href="/legacy/2021/03/17/tcp-protocol/"/>
      <url>/legacy/2021/03/17/tcp-protocol/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP（传输控制协议）"><a href="#TCP（传输控制协议）" class="headerlink" title="TCP（传输控制协议）"></a>TCP（传输控制协议）</h1><blockquote><p><strong>TCP：传输控制协议（Transmission Control Protocol）</strong> 是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。</p></blockquote><p>通常我们听到 <strong>TCP/IP 协议（族）</strong> 那么种称呼，其作用如下：</p><blockquote><p>TCP/IP 提供了点对点链接的机制，将资料应该如何封装、寻址、传输、路由以及在目的地如何接收，都加以标准化。<br>它将软件通信过程抽象化为 <strong>四个抽象层</strong>，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，分别归属到这四个层次结构之中，常视为是 <strong>简化的七层 OSI 模型</strong>。</p></blockquote><p>那什么是 <strong>七层 OSI 模型</strong> ？下图展示了 <strong>OSI 模型</strong> 的结构：</p><img src="/legacy/2021/03/17/tcp-protocol/osi.png" class="" title="七层OSI模型"><p>了解了 <strong>OSI 模型</strong> 后，再来看下 <strong>TCP/IP 四层模型</strong> 的对比：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-ip-layer.png" class="" title="TCP&#x2F;IP四层模型"><p><strong>TCP/IP 模型</strong> 中，将 <strong>OSI</strong> 的应用层，表示层，会话层抽象为一个大应用层。</p><h1 id="WireShake"><a href="#WireShake" class="headerlink" title="WireShake"></a>WireShake</h1><p>相信各位肯定看了很多遍类似这样的图：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp_open_close.jpg" class="" title="tcp握手图例"><p>但我一直没有真真实实地看到 <strong>TCP</strong> 创建和断开连接这样的过程，希望能像 <strong>Chrome Develop Tool</strong> 直观看到接口的请求和响应。而不是根据别人的文章所云的进行机械的记忆。</p><p>为了了解 <strong>TCP</strong> 协议怎么进行握手的？这里就需要用到一个网络分析工具： <strong>WireShake</strong>。</p><p>下面在说明 <strong>三次握手</strong> 和 <strong>四次挥手</strong> 时，会结合在 <strong>WireShake</strong> 看到的实际结果来理解 TCP 的连接过程。</p><h1 id="三次握手（three-way-handshake）"><a href="#三次握手（three-way-handshake）" class="headerlink" title="三次握手（three-way handshake）"></a>三次握手（three-way handshake）</h1><p>在开始 TCP 说如何创建连接之前，先看下一些关键名词解释：</p><ul><li><strong>seq（Sequence Number）</strong>：端与端之间通讯的（初始化）序列号</li><li><strong>SYN（Synchronize Sequence Numbers）</strong>：每次通讯需要对上述序列号（seq）进行 <strong>同步操作</strong>，以 <strong>解决网络包乱序问题</strong>（reordering）。</li><li><strong>ACK（Acknowledgement Number）</strong>：用于确定接收到包后的回复确认，<strong>解决不丢包的问题</strong>。</li></ul><p>了解了上述名词后，再来看 <strong>三次握手</strong> 的过程图：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-connect.png" class="" title="TCP创建连接"><p>上图已经已经很清晰地展示了创建连接的过程。现在我们实际发送一个 Http 请求，并结合 <strong>WireShake</strong> 看下具体步骤细节：</p><ol><li><p>首先，我们访问一个网站（<a href="http://www.eminoda.com/elsa），在" target="_blank" rel="noopener">http://www.eminoda.com/elsa），在</a> Http 请求之前，先有了三次 TCP 的请求记录：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-create-1.png" class=""></li><li><p>第 1 次：客户端向正常工作的服务端（<strong>LISTEN</strong> 状态）发送同步序列号请求（seq=x），同时客户端状态进入 <strong>SYN_SENT</strong></p><img src="/legacy/2021/03/17/tcp-protocol/tcp-create-2.png" class=""></li><li><p>第 2 次：服务端收到后，创建 <strong>ACK</strong> 应答码作为收到确认信息（值为接受到的 seq+1，即：ACK=x+1），并创建新的序列号（seq=y），再一同发送给客户端。并进入 <strong>SYN_RCVD</strong> 状态</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-create-3.png" class=""></li><li><p>第 3 次：客户端收到后，也创建 <strong>ACK</strong> 应答码作为收到确认信息（值为接受到的 seq+1，即：ACK=y+1），再发送给服务端，并进入 <strong>ESTABLISHED</strong> 状态</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-create-4.png" class=""></li><li><p>最后，服务端收到后，进入 <strong>ESTABLISHED</strong> 状态，此时 <strong>TCP</strong> 连接创建成功，</p></li></ol><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>四次挥手和三次握手相反，用于 TCP 连接后的断开，下面是过程图：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close.png" class="" title="TCP关闭连接"><p>结合 <strong>WireShake</strong> 也看下步骤：</p><ol><li><p>首先，在 <strong>WireShake</strong> 找到对应四次挥手的 TCP 请求：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close-1.png" class=""></li><li><p>第 1 次：客户端准备 <strong>序列号（seq=4710）</strong> 和 <strong>应答码（ACK=1245）</strong>，并设置 <strong>FIN</strong> 标识（示意没有数据传输了，要求释放连接）发送给服务端后，进入 <strong>FIN_WAIT_1</strong> 状态</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close-2.png" class=""></li><li><p>第 2 次：服务端收到后，准备 <strong>序列号（seq=1245）</strong> 和 <strong>应答码（ACK=4710+1）</strong> 发送给客户端，进入 <strong>CLOSE_WAIT</strong> 状态</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close-3.png" class=""></li><li><p>客户端收到后，确认了服务端同意关闭连接请求，并进入 <strong>FIN_WAIT_2</strong> 状态。此状态中将等待服务端再次发送的请求，已让客户端可以关闭连接。</p></li><li><p>第 3 次：过些“时间”后，服务端像客户端第一次发送的数据类似，发送 <strong>序列号（seq=1245）</strong> 和 <strong>应答码（ACK=4711）</strong>，并设置 <strong>FIN</strong> 标识，并进入 <strong>LAST_ACK</strong> 状态</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close-4.png" class=""></li><li><p>第 4 次：客户端收到后，发送 <strong>序列号（seq=4711）</strong> 和<strong>应答码（ACK=1245+1）</strong>，进入 <strong>TIME_WAIT</strong> 状态，如果服务端收到后将关闭。之后客户端等待 2MSL 时间后还没收到服务端数据也将关闭，至此整个 <strong>TCP</strong> 连接中断。</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-close-5.png" class=""></li></ol><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><h2 id="为什么握手是三次，而不是二次？"><a href="#为什么握手是三次，而不是二次？" class="headerlink" title="为什么握手是三次，而不是二次？"></a>为什么握手是三次，而不是二次？</h2><p>减少次数，看上去更能提高通讯效率，但同样会增加连接的不确定性。详见下图：</p><img src="/legacy/2021/03/17/tcp-protocol/doc.png" class=""><p>总结下，就是端与端之间需要单独一次一来一回的通讯（以确认 <strong>seq</strong> 是否串台）来防止非预期的连接错误，加上首次的 <strong>SYN</strong> 请求总共三次。</p><h2 id="那为何挥手是四次？"><a href="#那为何挥手是四次？" class="headerlink" title="那为何挥手是四次？"></a>那为何挥手是四次？</h2><p>因为 <strong>TCP</strong> 是双工通讯，某一端要向另一端发送关闭连接请求都是需要发送一次 FIN 请求，和接受一次针对 <strong>FIN</strong> 请求的应答确认。此时一端处于半连接状态（还可以发送数据），则需要反过来发送一次 <strong>FIN</strong> ，和接口一次 <strong>ACK</strong> 应答，最后两端才能都关闭。</p><h2 id="TCP-数据包长什么样？"><a href="#TCP-数据包长什么样？" class="headerlink" title="TCP 数据包长什么样？"></a>TCP 数据包长什么样？</h2><p>先来看下 <strong>TCP</strong> 数据表的结构：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-data-pkg1.png" class="" title="tcp数据结构"><p>但凡网络课程睡觉的同学看到这表格可能和我一样蒙，但又说不出的熟悉，这里使用 <strong>WireShake</strong> 来读懂这个数据结构。</p><p>先看下和 <strong>标准网络 OSI 模型</strong> 的映射关系：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-ref.png" class="" title="和OSI模型的映射关系"><p>下面逐步对这个数据包进行拆分查看，首先是 <strong>Frame</strong> ：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-pkg-1.png" class="" title="Frame"><p>能看到整个数据包大小为 753 字节，其数据就和上图下方的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000   c8 a7 76 d2 08 52 80 30 49 26 62 97 08 00 45 00   ..v..R.0I&amp;b...E.</span><br><span class="line">0010   02 e3 32 be 40 00 80 06 38 9b c0 a8 11 3f 2f 67   ..2.@...8....?&#x2F;g</span><br><span class="line">0020   8b 6d c7 c7 00 50 bb a1 d5 70 b3 2f 4b 04 50 18   .m...P...p.&#x2F;K.P.</span><br><span class="line">0030   02 01 0e 63 00 00 47 45 54 20 2f 65 6c 73 61 2f   ...c..GET &#x2F;elsa&#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着看以太网 <strong>Ethernet</strong> 内容：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-pkg-2.png" class="" title="Ethernet"><p>以太网帧头部为 14 字节（你可以双击 Ethernet 那栏，然后在底部看到“c8 a7 76 d2 08 52 80 30 49 26 62 97 08 00”被选中），并能看到 2 个通讯方的 Mac 地址，以及了解网卡是哪个厂家生产的。</p><p>最后注意有个 <strong>Type</strong> 字段，标识上层协议是 <strong>IPV4</strong> 。</p><p>然后是 <strong>Internet Protocol</strong> 内容：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-pkg-3.png" class="" title="Internet Protocol"><p>IP 协议层头部为 20 字节内容，这里你能具体看到两个 IP 地址值。</p><p>再是 <strong>Transmission Control Protocol</strong> （TCP）传输层的内容：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-pkg-4.png" class="" title="Transmission Control Protocol"><p>在这里能看到数据包大小（<strong>TCP Segment Len</strong>）为 699 字节（753-14-20），这个值比较重要，因为下一次服务端将用 ACK=700（699+1）作为应答码发送给客户端。</p><p>另外，因为连接已经创建，这次 <strong>TCP</strong> 报文中的标识符除了上面见过的 <strong>FIN</strong> ， <strong>ACK</strong> ， <strong>SYN</strong> 外，还出现了 <strong>PUSH</strong> （指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满）。</p><p>再提个，能在底部看到一个 iRTT（Initial Round Trip Time）参数，他是个计算 TCP Window 窗口滑动的参数之一（有兴趣可以在底部参考链接里查阅）。</p><p>最后就是我们再熟悉不过的 <strong>http</strong> 协议：</p><img src="/legacy/2021/03/17/tcp-protocol/tcp-pkg-5.png" class="" title="http"><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文结合 <strong>wireshake</strong> 工具的使用，泛泛讲了下一些 TCP 协议的知识点，更多深入的内容可以查阅如下参考文章。</p><p><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上/下）</a><br><a href="https://www.jianshu.com/p/c793a279f698" target="_blank" rel="noopener">计算机网络漫谈：OSI 七层模型与 TCP/IP 四层（参考）模型</a><br><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解 TCP 协议的三次握手和四次分手</a><br><a href="https://github.com/JeffyLu/JeffyLu.github.io/issues/22" target="_blank" rel="noopener">好文推荐：计算机网络篇</a><br><a href="https://blog.csdn.net/ahafg/article/details/51039584" target="_blank" rel="noopener">Wireshark-TCP 协议分析（包结构以及连接的建立和释放）</a><br><a href="https://blog.packet-foo.com/2014/07/determining-tcp-initial-round-trip-time/" target="_blank" rel="noopener">Determining TCP Initial Round Trip Time</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现 WebSocket 反向代理？</title>
      <link href="/legacy/2021/03/15/web-socket-proxy/"/>
      <url>/legacy/2021/03/15/web-socket-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>为什么要代理 WebSocket？</p></blockquote><p>是这样的，因为我们有个基于 <strong>electron</strong> 的桌面应用，他在本地提供 <strong>http</strong> 和 <strong>websocket</strong> 两个服务，客户端（浏览器）可以使用这些服务来完成一些核心业务需要。</p><p>问题是，目前该应用只支持 <strong>windows</strong> 平台，虽然生产环境对环境有所要求，但部分开发却是 <strong>mac</strong> 电脑，无法安装该客户端，总不能要求开发者安装个虚拟机，或者尽快开发个 <strong>mac</strong> 版，无论硬件还是软件，搭建开发环境的成本都太高。</p><p>于是设想在一台 <strong>windows</strong> 电脑上共享桌面应用服务，在测试环境做请求代理，以便持有 <strong>mac</strong> 或者安装应用有问题的同学进行无障碍快速接入。</p><p>这篇就讲下如何配置 <strong>webpack</strong> 和 <strong>nginx</strong> 来完成这样的“小工程”。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p>下图主要示意了如下几个方面：</p><ul><li>桌面服务被安装在可用的 windows 机器上</li><li>开发环境通过配置 <strong>webpack</strong> 进行请求转发</li><li>对于 <strong>mac</strong> 平台及不适配的情况，统一通过 <strong>nginx</strong> 进行请求转发</li></ul><img src="/legacy/2021/03/15/web-socket-proxy/%E7%8E%AF%E5%A2%83%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class="" title="跨平台 socket 代理策略"><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>项目基于 <strong>vue-cli</strong>，首先需要对 <strong>vue.config.js</strong> 中 <strong>webpack</strong> 的代理部分进行修改。</p><p>先设置 <strong>VUE_APP_PROXY_URL</strong>，定义目标转发环境的（IP）地址，再添加 <strong>VUE_APP_PROXY_PLATFORM</strong> 决定是否开启转发功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> env.local</span></span><br><span class="line">VUE_APP_PROXY_PLATFORM = mac</span><br><span class="line">VUE_APP_PROXY_URL = 192.168.1.x:81</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">var</span> proxy = &#123;</span><br><span class="line">  <span class="comment">// 后端服务</span></span><br><span class="line">  [<span class="string">'/api'</span>]: &#123;</span><br><span class="line">    target: process.env.VUE_PROXY_API,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (VUE_APP_PROXY_PLATFORM == <span class="string">'mac'</span>) &#123;</span><br><span class="line">  proxy = <span class="built_in">Object</span>.assign(proxy, &#123;</span><br><span class="line">    <span class="comment">// 桌面应用 http 服务</span></span><br><span class="line">    [<span class="string">'/app-api'</span>]: &#123;</span><br><span class="line">      target: <span class="string">'http://'</span> + process.env.VUE_APP_PROXY_URL,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 桌面应用 websocket 服务</span></span><br><span class="line">    [<span class="string">'/app-ws'</span>]: &#123;</span><br><span class="line">      target: <span class="string">'ws://'</span> + process.env.VUE_APP_PROXY_URL,</span><br><span class="line">      ws: <span class="literal">true</span>, <span class="comment">//开启 websocket 支持</span></span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/app-ws'</span>: <span class="string">'/'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    port: port,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    proxy: proxy,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来只要在业务代码中，添加对应 <strong>/app**</strong> 前缀来匹配代理规则即可。</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><strong>nginx</strong> 端配置简单，只需要对协议进行升级即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  81;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> http 代理</span></span><br><span class="line">  location /app-api/ &#123;</span><br><span class="line">    proxy_pass http://192.168.1.y:18455/;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> websocket 代理</span></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://192.168.1.y:18455/;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">    proxy_set_header Connection "Upgrade";</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文主要记录我在遇到这个问题时，实施的解决方案，但不具备通用性。不过也希望为有遇到类似场景问题的同学提供一个方向的解决思路。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> nginx </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 和 linux 平台上安装 nginx</title>
      <link href="/legacy/2021/03/12/nginx-install/"/>
      <url>/legacy/2021/03/12/nginx-install/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然多数前端开发在团队中定位只是 <strong>切图仔</strong>，每天忙碌于和后端的接口联调。但随着越来越 <strong>内卷</strong>，“被迫”要学习（了解）很多非前端的技术栈，<del>把搞得我们越来越“全栈”。（当个玩笑看吧！手动狗头 🐶）</del>。</p><p>认真的说，学习是要主动自发的，你可以说这些技术栈和 js 没有关系，比如这篇是讲 <strong>nginx</strong> 的安装。相信只要公司不要太差，总有运维帮我们搭建好环境，团队中总有人帮我们梳理好开发文档。</p><p>如今 2021 了，即使前端生态已经趋于稳定，起个 <strong>webpack server</strong> 光靠 <strong>http-proxy-middleware</strong> 就可以玩转各类代理需要，<strong>但真的不去接触可以吗？</strong></p><p>站在我的角度，有学习的必要性。虽然这篇只涉及环境的安装，但总有一天你会站在运维，或者团队管理的角色去解决复杂问题。<strong>总之，技多不压身</strong>。</p><p>说了那么多，下面就开始吧。</p><h1 id="windows-平台"><a href="#windows-平台" class="headerlink" title="windows 平台"></a>windows 平台</h1><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p>在 <strong>nginx.org</strong> 的 download 页面，下载对应的 windows exe 执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html</span><br></pre></td></tr></table></figure><img src="/legacy/2021/03/12/nginx-install/windows-download.png" class="" title="下载 windows 包"><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>解压对应的下载文件，将会得到如下目录：</p><img src="/legacy/2021/03/12/nginx-install/windows-folds.png" class="" title="文件目录"><h2 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h2><p>因为 <strong>nginx</strong> 已经帮我们写好了配置文件骨架，所以并不需要我们“白手起家”：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> D:\devtool\nginx-1.19.7\conf\nginx.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line">http&#123;</span><br><span class="line">    #...</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接点击 <strong>nginx.exe</strong> 后，访问：<a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a> 就能看到成功页：</p><img src="/legacy/2021/03/12/nginx-install/windows-hello.png" class="" title="成功页"><h2 id="示意一个简单的转发"><a href="#示意一个简单的转发" class="headerlink" title="示意一个简单的转发"></a>示意一个简单的转发</h2><p>比如，本地有个 koa 服务（端口：3000），那怎么通过 <strong>nginx</strong> 来进行反向代理呢？（如果有类似跨域的问题）</p><p>增加解析后端服务的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> conf/includes/koa.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen  82;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 nginx.conf include 导入上述文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> conf/nginx.conf</span></span><br><span class="line">...</span><br><span class="line">http&#123;</span><br><span class="line">    ...</span><br><span class="line">    include conf/includes/*.conf;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此 <strong>windows</strong> 平台的安装教程到此结束，下面来讲下 <strong>linux</strong> 平台。</p><h1 id="linux-平台"><a href="#linux-平台" class="headerlink" title="linux 平台"></a>linux 平台</h1><p><strong>linux</strong> 也很容易，可以参考<a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener">官网说明文档</a></p><h2 id="配置-yum-repo"><a href="#配置-yum-repo" class="headerlink" title="配置 yum repo"></a>配置 yum repo</h2><p>如果 <strong>yum install nginx</strong> 出现如下提示，需要配置 <strong>nginx</strong> 仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">No package nginx available.</span><br><span class="line">Error: Nothing to do</span><br></pre></td></tr></table></figure><p>编辑 <strong>repo</strong> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/nginx.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件如下</span></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure><p>最后再使用 <strong>yum</strong> 重新安装 <strong>nginx</strong> 即可。</p><h2 id="nginx-装在哪？"><a href="#nginx-装在哪？" class="headerlink" title="nginx 装在哪？"></a>nginx 装在哪？</h2><p>通过 <strong>whereis</strong> 找到 <strong>nginx</strong> 相关文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br><span class="line"></span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz</span><br></pre></td></tr></table></figure><p>然后我们就知道，<strong>nginx</strong> 对应的资源，依赖，及启动文件的路径：</p><img src="/legacy/2021/03/12/nginx-install/linux-folds.png" class="" title="成功页"><h2 id="配置-amp-启动-1"><a href="#配置-amp-启动-1" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h2><p>同 <strong>windows</strong> ，这里的 <strong>nginx</strong> 也不需要配置，我们只需要直接启用即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首次启动</span></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>对应如果有配置更改，或者想要重启可以参考如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这和代码 HelloWorld 一样，只是一篇简单的环境安装文章，主要示范如何从官方渠道下载 <strong>nginx</strong> 包然后安装到服务端。希望能帮到卡在入门安装的同学。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YApi 接口管理服务及 Mock.js</title>
      <link href="/legacy/2021/02/19/mockjs-and-yapi/"/>
      <url>/legacy/2021/02/19/mockjs-and-yapi/</url>
      
        <content type="html"><![CDATA[<h1 id="YApi"><a href="#YApi" class="headerlink" title="YApi"></a>YApi</h1><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>首先，先看下在 <strong>前后端分离</strong> 模式下，前端开发同学一直面临着这些问题：</p><ul><li>文档编写难以开展，更难以维护</li><li>缺少接口文档，前端开发时间点滞后，<strong>影响项目进度</strong></li><li>没有一个即时调用的后端服务，需要不断在页面中写假数据，<strong>增加开发量</strong></li><li>即使有了接口文档，往往因为不清晰的描述，无法准确使用字段，<strong>增加沟通成本</strong></li></ul><h2 id="什么是-YApi"><a href="#什么是-YApi" class="headerlink" title="什么是 YApi"></a>什么是 YApi</h2><blockquote><p>旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API。</p></blockquote><p>它的 <strong>可视化的接口管理界面</strong>，<strong>集成 Mock 服务</strong>，足够轻松解决上述这些问题。</p><p>Github 上 20k 的 Star 数足以证明它在接口管理领域大家对它的认可。</p><img src="/legacy/2021/02/19/mockjs-and-yapi/github.png" class=""><p>同时，它还有如下出众的特性：</p><ul><li>支持 <strong>权限管理</strong>，<strong>私有化部署</strong>：方便，安全的在公司内部进行搭建，和人员管理</li><li>支持 <strong>数据导入</strong>：对于导入 Swagger、Postman 数据，方便迁移历史项目文档</li><li>支持 <strong>自动化测试</strong>：为测试团队进行赋能</li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>因为 YApi 主技术栈为前端，只要准备好 <strong>nodejs</strong> 和 <strong>mongodb</strong> 环境即可通过 <strong><a href="https://www.npmjs.com/package/yapi-cli" target="_blank" rel="noopener">yapi-cli</a></strong> 方便的完成，这里不做赘述。</p><p>更多详见：<a href="https://hellosean1025.github.io/yapi/devops/index.html#%e5%ae%89%e8%a3%85" target="_blank" rel="noopener">Yapi 安装</a></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>成功安装后，下面展示如何简单的维护一个接口 api：</p><ol><li><p>首先在指定空间下新建一个新项目</p><img src="/legacy/2021/02/19/mockjs-and-yapi/1.png" class=""></li><li><p>为新项目设置统一的接口前缀等基础信息</p><img src="/legacy/2021/02/19/mockjs-and-yapi/2.png" class=""></li><li><p>对不同模块的接口设置不同的文件夹进行分类</p><img src="/legacy/2021/02/19/mockjs-and-yapi/3.png" class=""></li><li><p>创建第一个接口</p><p>定义接口的 <strong>Http 方法</strong> 和 <strong>请求 URL</strong>（还有所属分类，以及接口名称）</p><img src="/legacy/2021/02/19/mockjs-and-yapi/4.png" class=""></li><li><p>编写参数</p><p>按照 Http 协议（主要是 <strong>Content-Type</strong> ），定义后端需要的请求参数和响应参数</p><img src="/legacy/2021/02/19/mockjs-and-yapi/5.png" class=""></li><li><p>运行</p><p>这里的运行是基于 YApi 的 Mock 服务，依靠此服务，能让完全前端独立出来，不在依赖后端服务</p><img src="/legacy/2021/02/19/mockjs-and-yapi/6.png" class=""></li><li><p>预览</p><p>作为文档供所有开发人员阅览</p><img src="/legacy/2021/02/19/mockjs-and-yapi/7.png" class=""></li></ol><h1 id="数据-Mock"><a href="#数据-Mock" class="headerlink" title="数据 Mock"></a>数据 Mock</h1><h2 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h2><p>参考“基本使用”，只是完成了接口文档的阅读，及基础调用。下面来介绍 YApi 的核心功能：<strong>数据 Mock</strong>。</p><p>数据 Mock 的功能基于 Mock.js 实现，是由 <a href="https://github.com/nuysoft" target="_blank" rel="noopener">墨智</a>大佬 打造的。</p><p>下面配合一些使用场景来看下 <strong>Mock.js 与 YApi 的进阶使用方法</strong>：</p><h2 id="Mock-占位符"><a href="#Mock-占位符" class="headerlink" title="Mock 占位符"></a>Mock 占位符</h2><p>Mock.js 内置很多 <strong>Random</strong> 功能，便于我们能快速定义一些有意义的假数据。</p><p>比如：</p><ul><li>@boolean: 返回一个随机的布尔值</li><li>@natural: 返回一个随机的自然数（大于等于 0 的整数）。</li><li>@integer: 返回一个随机的整数。</li><li>@string: 返回一个随机字符串。</li><li>@word: 随机生成一个单词。</li><li>@province: 随机生成一个（中国）省（或直辖市、自治区、特别行政区）。</li><li>@email: 随机生成一个邮件地址。</li><li>@id: 随机生成一个 18 位身份证。</li><li>…</li></ul><p>以上这些都可以在 <a href="https://github.com/nuysoft/Mock/wiki/Mock.Random" target="_blank" rel="noopener">https://github.com/nuysoft/Mock/wiki/Mock.Random</a> 快速查阅到。</p><p>比如有一个 <strong>“用户列表”</strong> 接口，含有用户名，年龄，用户 id 等字段。当我们没有 mock 时，将返回如下数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Lorem adipisicing in"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">18412897.588101894</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"r"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"eiusmod"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"ut eiusmod in"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">68070733.33913586</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"culpa quis"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"min"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述数据在实际使用毫无意义。我们更期望得到如下数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"是说林"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">64</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"non dolor magna minim sed"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"c970CE5A-B1b4-1faF-c52e-1171Cc6b946A"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"物南来"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">57</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"enim"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"4EC6Ec4b-b88A-d6Df-78A7-2457Af249Fb2"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面示意，<strong>如何使用 mock 占位符对字段进行修饰</strong>：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-basic-1.png" class=""><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-basic-2.png" class=""><p>运行后，将得到 <strong>“看得懂”</strong> 的数据，这样维护的文档对前端和测试人员的体验感将提升很多：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-basic-3.png" class=""><h2 id="高级-Mock"><a href="#高级-Mock" class="headerlink" title="高级 Mock"></a>高级 Mock</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>比如在 <strong>用户登录场景</strong>，我们希望输入 <strong>A 账户</strong> 可以正常登录，其他账户则登录失败。</p><p>但在开发阶段，后端接口逻辑都没实现，甚至数据库连表都不存在，那前端怎么做？</p><p>这时就可以使用 YApi 的 <strong>高级 Mock 期望</strong> 特性：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-adv-1.png" class=""><p>通过定义 <strong>参数过滤</strong> 来指定可以正常登录的账户信息：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-adv-2.png" class=""><p>在运行界面，当 username/password 为 eminoda/123456 时才返回预期的成功报文：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-adv-3.png" class=""><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>单靠 Mock 内置的占位符，和简单的期望规则无法模拟出实际预期的效果。</p><p>比如，希望在 <strong>“用户列表”</strong> 接口中 company 字段从某个数组集合中挑选某个作为返回结果值。</p><p>这时就需要开发掌握一些 Mock.js 技巧以及 javascript 的语法来完成模拟逻辑（但这些对于经历过 jsp 的后端来说都不是问题，这和前端如今 vue，react 扯不上关系）：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-adv-4.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mockJson.code = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">params.page = params.page || <span class="number">1</span>;</span><br><span class="line">params.pageSize = params.pageSize || <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildData = <span class="function"><span class="keyword">function</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> list = [];</span><br><span class="line">  <span class="keyword">while</span> (c &lt; size) &#123;</span><br><span class="line">    list.push(&#123;</span><br><span class="line">      name: Random.cword(<span class="number">3</span>),</span><br><span class="line">      age: Random.natural(<span class="number">10</span>, <span class="number">99</span>),</span><br><span class="line">      id: Random.guid(),</span><br><span class="line">      company: Random.pick([<span class="string">'alibaba'</span>, <span class="string">'bytedance'</span>, <span class="string">'tencent'</span>]),</span><br><span class="line">    &#125;);</span><br><span class="line">    c++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (params.page &lt; <span class="number">2</span>) &#123;</span><br><span class="line">  mockJson.data = buildData(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mockJson.data = buildData(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，将得到如下数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"六查山"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"67d2f1Fe-D276-fBF2-AdBF-b1FEBA28Dee3"</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"bytedance"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"次养打"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"cbfF7e85-3CCB-98c4-5ff0-f4F2ee0D5ED6"</span>,</span><br><span class="line">      <span class="attr">"company"</span>: <span class="string">"tencent"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高级 Mock 脚本中定义了些全局变量，我们可以从 header、params、cookie 中拿到请求头，和请求参数信息；以及可以通过 mockJson、resHeader、httpCode… 自定义响应数据。</p><p><a href="https://hellosean1025.github.io/yapi/documents/adv_mock.html#%E8%87%AA%E5%AE%9A%E4%B9%89-mock-%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener">点击了解更多</a></p><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><p>这块内容将更多涉及测试（开发）人员，一个项目迭代多次，没有人会知道哪些接口对哪些功能造成什么后果，一个 <strong>高覆盖率的测试用例+可自动化的脚本</strong> 将为项目迭代提供保障。</p><p>多数公司的测试都偏向于“人肉”，必然会有不确定性，不稳定性。YApi 为我们提供了一套“可操作”的自动化测试方案：<strong>期望/脚本+自动化执行（报告）</strong></p><h2 id="添加用例"><a href="#添加用例" class="headerlink" title="添加用例"></a>添加用例</h2><p>示意简单的用例创建</p><ol><li><p>在测试集合中关联对应接口</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-1.png" class=""></li><li><p>针对“登录接口”，定义一个能登录成功的请求数据</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-2.png" class=""></li><li><p>编写 Test，验证预期结果</p><p>不用担心怎么写，在右侧都有快捷方式（点一下，即可在左侧代码区生成代码）</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-3.png" class=""><p><strong>这样就完成了一个用例的编写。</strong></p></li><li><p>参照上述步骤，再定义一个“登录失败”的用例（用于对比）</p><p>请求参数填写“错误”的值，在 Test 验证错误的预期判断</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-4.png" class=""></li></ol><h2 id="用例-comb"><a href="#用例-comb" class="headerlink" title="用例 comb"></a>用例 comb</h2><p>比如我们有个“删除用户接口”，遵循 Restful 规范，通过 path 作为 id 参数来删除目标用户。</p><p>而实际这个 id 需要从“用户列表接口”返回的用户集合中取一条获得，这时删除接口就要依赖列表接口。</p><p>YAapi 也提供了 <strong>变量参数</strong> 对应这样的场景：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-5.png" class=""><p>通过特定表达式，来获取上个接口的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">.4822.body.data[0].id</span></span><br></pre></td></tr></table></figure><p>而这个 4822 就是测试集合中的 key 值（用户列表）：</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-6.png" class=""><p><a href="https://hellosean1025.github.io/yapi/documents/case.html#%e7%ac%ac%e4%ba%8c%e6%ad%a5%ef%bc%8c%e7%bc%96%e8%be%91%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b" target="_blank" rel="noopener">点击了解更多</a></p><h2 id="自动化测试用例"><a href="#自动化测试用例" class="headerlink" title="自动化测试用例"></a>自动化测试用例</h2><p>当完成一批的测试集合用例后，可以批量进行自动化测试，从而看接口服务的目前情况。</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-7.png" class=""><p>如果我们数据 Mock 足够真实，用例 Test 定义的足够完善，基本可以应对每次系统的迭代发布。一旦用例不通过，只会有两种情况：接口逻辑发生变化、用例写错。</p><p>另外，YApi 提供了服务端测试，我们可以获取到用例测试的报告（全量的接口信息，整体响应的时间等维度结果）</p><img src="/legacy/2021/02/19/mockjs-and-yapi/mock-test-8.png" class=""><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文只起抛砖引玉作用，示例了小部分的 Mock.js 使用以及 YApi 的实际使用场景，更多的需要开发和相关人员到 YApi 及相关站点阅读更多资料。</p><p>另外，可惜的是 YApi 可能不在进行维护，需要额外更多功能的团队就需要二次开发，或者寻找其他适合的工具。</p><img src="/legacy/2021/02/19/mockjs-and-yapi/yapi-author.png" class=""><p>当然也感谢这些大佬对社区的贡献。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hellosean1025.github.io/yapi/" target="_blank" rel="noopener">yapi</a></li><li><a href="https://github.com/nuysoft/Mock/wiki" target="_blank" rel="noopener">Mock.js</a></li><li><a href="http://nodejs.cn/api/assert.html" target="_blank" rel="noopener">nodejs assert</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mock.js </tag>
            
            <tag> yapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何管理 npm 版本号：语义化版本策略 SemVer</title>
      <link href="/legacy/2021/01/29/npm-semver-strategy/"/>
      <url>/legacy/2021/01/29/npm-semver-strategy/</url>
      
        <content type="html"><![CDATA[<h1 id="语义化版本（SemVer）"><a href="#语义化版本（SemVer）" class="headerlink" title="语义化版本（SemVer）"></a>语义化版本（SemVer）</h1><h2 id="什么是-SemVer"><a href="#什么是-SemVer" class="headerlink" title="什么是 SemVer"></a>什么是 SemVer</h2><p>由于软件开发中会依赖各式各样的依赖库（包），随着数量的增多，以及版本的不断迭代，项目管理者必然面对这样的问题：如何正确的管理这些包的版本？</p><p>那通过什么来约定呢？所以就有了 SemVer：</p><blockquote><p>SemVer（Semantic Versioning），语义化版本控制。</p></blockquote><p>SemVer 通过不同的语法规则来约定不同版本间的升级方案，最终使得我们可以“随心所欲”的更新版本。</p><p>比如，前端项目 <strong>package.json</strong> 中包版本定义就是基于 SemVer 规范（npm 中实现了它）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@vue/cli-plugin-babel"</span>: <span class="string">"~4.5.0"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-plugin-eslint"</span>: <span class="string">"~4.5.0"</span>,</span><br><span class="line">    <span class="attr">"@vue/cli-service"</span>: <span class="string">"~4.5.0"</span>,</span><br><span class="line">    <span class="attr">"babel-eslint"</span>: <span class="string">"^10.1.0"</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"^6.7.2"</span>,</span><br><span class="line">    <span class="attr">"eslint-plugin-vue"</span>: <span class="string">"^6.2.2"</span>,</span><br><span class="line">    <span class="attr">"less"</span>: <span class="string">"^4.1.0"</span>,</span><br><span class="line">    <span class="attr">"less-loader"</span>: <span class="string">"^7.3.0"</span>,</span><br><span class="line">    <span class="attr">"vue-template-compiler"</span>: <span class="string">"^2.6.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就来看看这些语义化规范和语法规则。</p><h2 id="语义化规范"><a href="#语义化规范" class="headerlink" title="语义化规范"></a>语义化规范</h2><p>为了下面能更好的理解规则，首先了解下相关语义化的含义：</p><h3 id="版本号格式"><a href="#版本号格式" class="headerlink" title="版本号格式"></a>版本号格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.Y.Z; <span class="comment">//主版本号.次版本号.修订号</span></span><br></pre></td></tr></table></figure><p>标准的版本号<strong>必须</strong>为 X.Y.Z 的格式，且都为非负的整数。禁止数字前面补零（比如：02）</p><p>X 是主版本号（major version）、Y 是次版本号（minor version）、而 Z 为修订号（patch version）</p><p>版本只能每次 +1 的往上自然增加（比如：1.9.0 -&gt; 1.10.0 -&gt; 1.11.0）</p><p>另外，还有一些先行版版本号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.Y.Z-alpha<span class="number">.1</span></span><br></pre></td></tr></table></figure><p>约定先行版本号是在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。</p><p>标识符必须由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成。比如：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</p><h3 id="更新-X、Y、Z-的场景"><a href="#更新-X、Y、Z-的场景" class="headerlink" title="更新 X、Y、Z 的场景"></a>更新 X、Y、Z 的场景</h3><ol><li><p>修订号 Z（patch version）</p><p>必须做向下兼容的修复时才递增（例如：修复 bug）</p></li><li><p>次版本号 Y（minor version）</p><p>必须向下兼容的新功能出现时递增，当某些功能被弃用也必须递增；</p><p>另外，当有大量新功能和改动时，也可以递增此版本号。</p><p>注：每次递增，修订号必须归零。</p></li><li><p>主版本号 X（major version）</p><p>必须在有任何不兼容的修改被加入公共 API 时递增。</p><p>注：每次递增，次版本号和修订号必须归零。</p></li></ol><h2 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h2><h3 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h3><ul><li><strong>&lt;2.0.0</strong> 小于某版本</li><li><strong>&lt;=2.0.0</strong> 小于 or 等于某版本</li><li><strong>&gt;2.0.0</strong> 大于 or 等于某版本</li><li><strong>&gt;=2.0.0</strong> 大于 or 等于某版本</li><li><strong>=2.0.0</strong> 精确等于某版本</li></ul><p>上面这些规则都很好理解，简单看下下面例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"moment"</span>: <span class="string">"2.20.0"</span>,</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"&lt;0.19.4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么执行 <strong>npm install</strong> 后，我们将准确得到版本为 <strong>2.20.0</strong> 的 <strong>moment</strong> 包，<br>以及最接近 <strong>0.19.4</strong> 版本为 <strong>0.19.2</strong> <strong>axios</strong> 包</p><p>你有可能会问为什么不是 <strong>0.19.3</strong>？</p><p>我们可以通过 <strong>npm view</strong> 来查询有关 <strong>axios</strong> 所有的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view axios versions</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">'0.18.0'</span>,</span><br><span class="line">  <span class="string">'0.18.1'</span>,</span><br><span class="line">  <span class="string">'0.19.0-beta.1'</span>,</span><br><span class="line">  <span class="string">'0.19.0'</span>,</span><br><span class="line">  <span class="string">'0.19.1'</span>,</span><br><span class="line">  <span class="string">'0.19.2'</span>,</span><br><span class="line">  <span class="string">'0.20.0-0'</span>,</span><br><span class="line">  <span class="string">'0.20.0'</span>,</span><br><span class="line">  <span class="string">'0.21.0'</span>,</span><br><span class="line">  <span class="string">'0.21.1'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>能看到压根没有 <strong>0.19.3</strong>，直接跳到了 <strong>0.20.0-0</strong>。</p><h3 id="高级规则"><a href="#高级规则" class="headerlink" title="高级规则"></a>高级规则</h3><p>实际开发中，我们更多的是见到以下这些规则：</p><h4 id="破折号策略（-）"><a href="#破折号策略（-）" class="headerlink" title="破折号策略（-）"></a>破折号策略（-）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2</span><span class="number">.3</span> - <span class="number">2.3</span><span class="number">.4</span> <span class="comment">// 代表 &gt;=1.2.3 &lt;=2.3.4 之间的版本，包含左右版本。</span></span><br></pre></td></tr></table></figure><p>如果起始版本（左侧的版本）有空缺，将以 0 补位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2</span> - <span class="number">2.3</span><span class="number">.4</span> <span class="comment">// 代表 &gt;=1.2.0 &lt;=2.3.4</span></span><br></pre></td></tr></table></figure><p>如果结尾版本（右侧的版本）有空缺，将以 0 补位，并且递增非 0 版本号作为最大版本号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2</span><span class="number">.3</span> - <span class="number">2.3</span> <span class="comment">// &gt;=1.2.3 &lt;2.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span><span class="number">.3</span> - <span class="number">2</span> <span class="comment">// &gt;=1.2.3 &lt; 3.0.0</span></span><br></pre></td></tr></table></figure><h4 id="泛版本策略（-）"><a href="#泛版本策略（-）" class="headerlink" title="泛版本策略（*）"></a>泛版本策略（*）</h4><p>可以使用 X, x, or * 来作为某个版本号的占位符，来示意所有可能的版本号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* <span class="comment">// 代表 &gt;=0.0.0 (所有版本)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>x <span class="comment">// 代表 &gt;=1.0.0 &lt;2.0.0 (主版本限定为 1 的版本号)</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>.x <span class="comment">// 代表 &gt;=1.2.0 &lt;1.3.0 (主版本+次版本限定为 1.2 的版本号)</span></span><br></pre></td></tr></table></figure><p>如果我们版本号有缺损，将为我们自动以占位符填充：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span> (empty string) <span class="comment">// 代表 * 即 &gt;=0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="comment">// 代表 1.x.x 即 &gt;=1.0.0 &lt;2.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> <span class="comment">// 代表 1.2.x 即 &gt;=1.2.0 &lt;1.3.0</span></span><br></pre></td></tr></table></figure><h4 id="波浪策略（-）"><a href="#波浪策略（-）" class="headerlink" title="波浪策略（~）"></a>波浪策略（~）</h4><p>当前版本号为起始版本，以倒数第二个版本号+1（次版本号 Y）为递增版本，可更新 <strong>[起始，结束)</strong> 范围内的所有版本号。</p><p>如有版本号有空缺，将自动补 0，并以最近的空缺版本之前的版本号+1 作为递增的最大版本号。</p><p>对于 0.Y.Z 的开发阶段的版本号，将递增 0 后面的版本号作为递增的最大版本号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">1.2</span><span class="number">.3</span> <span class="comment">// 代表 &gt;=1.2.3 &lt;1.(2+1).0 即 &gt;=1.2.3 &lt;1.3.0</span></span><br><span class="line"></span><br><span class="line">~<span class="number">1.2</span> <span class="comment">// 代表 &gt;=1.2.0 &lt;1.(2+1).0 即 &gt;=1.2.0 &lt;1.3.0 (等同 1.2.x)</span></span><br><span class="line"></span><br><span class="line">~<span class="number">1</span> <span class="comment">// 代表 &gt;=1.0.0 &lt;(1+1).0.0 即 &gt;=1.0.0 &lt;2.0.0 (等同 1.x)</span></span><br><span class="line"></span><br><span class="line">~<span class="number">0.2</span><span class="number">.3</span> <span class="comment">// 代表 &gt;=0.2.3 &lt;0.(2+1).0 即 &gt;=0.2.3 &lt;0.3.0</span></span><br><span class="line"></span><br><span class="line">~<span class="number">0.2</span> <span class="comment">// 代表 &gt;=0.2.0 &lt;0.(2+1).0 即 &gt;=0.2.0 &lt;0.3.0 (等同 0.2.x)</span></span><br><span class="line"></span><br><span class="line">~<span class="number">0</span> <span class="comment">// 代表 &gt;=0.0.0 &lt;(0+1).0.0 即 &gt;=0.0.0 &lt;1.0.0 (等同 0.x)</span></span><br><span class="line"></span><br><span class="line">~<span class="number">1.2</span><span class="number">.3</span>-beta<span class="number">.2</span> <span class="comment">// 代表 &gt;=1.2.3-beta.2 &lt;1.3.0</span></span><br></pre></td></tr></table></figure><h4 id="倒三角策略（-）"><a href="#倒三角策略（-）" class="headerlink" title="倒三角策略（^）"></a>倒三角策略（^）</h4><p>更新主版本号，如果版本号为 0，则往下取非 0 版本号递增，作为最大版本号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1.2</span><span class="number">.3</span> <span class="comment">// 代表 &gt;=1.2.3 &lt;2.0.0</span></span><br><span class="line">^<span class="number">0.2</span><span class="number">.3</span> <span class="comment">// 代表 &gt;=0.2.3 &lt;0.3.0</span></span><br><span class="line">^<span class="number">0.0</span><span class="number">.3</span> <span class="comment">// 代表 &gt;=0.0.3 &lt;0.0.4</span></span><br><span class="line">^<span class="number">1.2</span><span class="number">.3</span>-beta<span class="number">.2</span> <span class="comment">// 代表 &gt;=1.2.3-beta.2 &lt;2.0.0</span></span><br><span class="line">^<span class="number">0.0</span><span class="number">.3</span>-beta <span class="comment">// 代表 &gt;=0.0.3-beta &lt;0.0.4</span></span><br></pre></td></tr></table></figure><p>对于泛版本，以及空缺版本的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1.2</span>.x <span class="comment">// 代表 &gt;=1.2.0 &lt;2.0.0</span></span><br><span class="line">^<span class="number">0.0</span>.x <span class="comment">// 代表 &gt;=0.0.0 &lt;0.1.0</span></span><br><span class="line">^<span class="number">0.0</span> <span class="comment">// 代表 &gt;=0.0.0 &lt;0.1.0</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1.</span>x <span class="comment">// 代表 &gt;=1.0.0 &lt;2.0.0</span></span><br><span class="line">^<span class="number">0.</span>x <span class="comment">// 代表 &gt;=0.0.0 &lt;1.0.0</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这篇只是简单说下 <strong>package.json</strong> 中版本号的更新规则，或许你每次 <strong>install</strong> 后从不关心版本升级策略，但随着项目功能迭代的增多，总会遇到团队某个开发人员安装了某个包后用了新特性，但在你的电脑上频繁报错。</p><p>可能你会在依赖包中“锁定”版本，但我们不能因噎废食，尽可能依靠灵活的版本升级策略，依靠社区为我们项目提供“生命力”。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#dependencies" target="_blank" rel="noopener">npm package.json#dependencies</a></li><li><a href="https://docs.npmjs.com/cli/v6/using-npm/semver" target="_blank" rel="noopener">npm semver</a></li><li><a href="https://semver.org/" target="_blank" rel="noopener">semver</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> semver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库日期类型在 sequelize 的使用</title>
      <link href="/legacy/2020/11/15/sequelize-datetime-type/"/>
      <url>/legacy/2020/11/15/sequelize-datetime-type/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于前端虽说有 Node.js 加持，能胜任多平台的产品开发，但因为不是主攻后端，一些数据库知识点偏弱，加上使用 sequelize 等库开箱即用的 api，使得某些细节处理不当很容易导致一些问题。</p><p>这篇就谈谈时间（时区）相关的概念，数据库中日期类型，以及结合 sequelize 的实际使用心得。</p><h1 id="几种时间约定"><a href="#几种时间约定" class="headerlink" title="几种时间约定"></a>几种时间约定</h1><h2 id="GMT-格林威治标准时间"><a href="#GMT-格林威治标准时间" class="headerlink" title="GMT 格林威治标准时间"></a>GMT 格林威治标准时间</h2><blockquote><p>格林尼治平均时间（Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。</p></blockquote><p>为了形象理解，找了张时区的地理图：</p><img src="/legacy/2020/11/15/sequelize-datetime-type/timezone.jpg" class=""><p>能看到整个地球被划分为 24 个时区，以本初子午线为分割点（0 时区），以左为西时区，以右为东时区，我国为东 8 区。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">Sun Nov <span class="number">15</span> <span class="number">2020</span> <span class="number">09</span>:<span class="number">00</span>:<span class="number">00</span> GMT+<span class="number">0800</span> (中国标准时间)</span><br></pre></td></tr></table></figure><h2 id="UTC-协调世界时"><a href="#UTC-协调世界时" class="headerlink" title="UTC 协调世界时"></a>UTC 协调世界时</h2><blockquote><p>以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。<strong>比 GMT 更为精确</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。</span></span><br><span class="line"><span class="keyword">const</span> offsetZone = <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset() / <span class="number">60</span>; <span class="comment">// -8</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toUTCString(); <span class="comment">// "Sun, 15 Nov 2020 01:00:00 GMT"</span></span><br></pre></td></tr></table></figure><h2 id="ISO-8601"><a href="#ISO-8601" class="headerlink" title="ISO 8601"></a>ISO 8601</h2><blockquote><p>国际标准 ISO 8601，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。</p></blockquote><p>格式：<strong>YYYY-MM-DDTHH:mm:ss.sssZ</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(); <span class="comment">// "2020-11-15T01:00:00.000Z"</span></span><br></pre></td></tr></table></figure><p>熟悉下 iso 规范的时间，实际本地时间是多少？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="keyword">const</span> isoDate = <span class="string">'2020-11-09T13:25:32.000Z'</span>;</span><br><span class="line"></span><br><span class="line">moment(isoDate).format(<span class="string">'YYYY-MM-DD HH:mm:hh'</span>); <span class="comment">//2020-11-09 21:25:09</span></span><br></pre></td></tr></table></figure><h1 id="数据库中的日期类型"><a href="#数据库中的日期类型" class="headerlink" title="数据库中的日期类型"></a>数据库中的日期类型</h1><p>先看下数据库有日期类型，以及他们的特点：</p><table><thead><tr><th>类型</th><th>长度</th><th>日期格式</th><th>日期范围</th><th>特殊</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>不涉及时区（依照数据源原样存储）</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>19700101080001 ~ 20380119111407</td><td>涉及时区（将当地时间转为 UTC 储存）</td></tr><tr><td>TIME</td><td>3 bytes</td><td>HH:MM:SS</td><td>-838:59:59~838:59:59</td><td>-</td></tr><tr><td>DATE</td><td>3 bytes</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-31</td><td>-</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>YYYY</td><td>1901 ~ 2155</td><td>-</td></tr></tbody></table><p>能看到对 <strong>DATETIME</strong> 和 <strong>TIMESTAMP</strong> 做了特殊说明，他们两者在和 <strong>sequelize</strong> 一起使用时必然会遇到些问题，下面通过一个例子来说明。</p><h1 id="sequelize-中的日期类型"><a href="#sequelize-中的日期类型" class="headerlink" title="sequelize 中的日期类型"></a>sequelize 中的日期类型</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>首先创建 <strong>time_diff</strong> 表，创建不同的日期类型字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+-------------+------+-----+---------+----------+</span><br><span class="line">| Field       | Type        | Null | Key | Default | Extra    |</span><br><span class="line">+-------------+-------------+------+-----+---------+----------+</span><br><span class="line">| source_time | varchar(<span class="number">60</span>) | YES  |     | NULL    |          |</span><br><span class="line">| t_date      | date        | YES  |     | NULL    |          |</span><br><span class="line">| t_datetime  | datetime    | YES  |     | NULL    |          |</span><br><span class="line">| t_timestamp | timestamp   | YES  |     | NULL    |          |</span><br><span class="line">+-------------+-------------+------+-----+---------+----------+</span><br></pre></td></tr></table></figure><p>然后通过 <strong>Model.create</strong> 往该表插入一条数据（每列赋值均为 <strong>new Date</strong> ）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模型定义</span></span><br><span class="line"><span class="keyword">const</span> TimeDiff = sequelize.define(</span><br><span class="line">  <span class="string">'TimeDiff'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    sourceTime: DataTypes.STRING,</span><br><span class="line">    tDate: DataTypes.DATE,</span><br><span class="line">    tDatetime: DataTypes.DATE,</span><br><span class="line">    tTimestamp: DataTypes.DATE,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    freezeTableName: <span class="literal">true</span>,</span><br><span class="line">    tableName: <span class="string">'time_diff'</span>,</span><br><span class="line">    timestamps: <span class="literal">false</span>,</span><br><span class="line">    underscored: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'time'</span>, time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增记录</span></span><br><span class="line">TimeDiff.create(&#123;</span><br><span class="line">  sourceTime: time.toString(),</span><br><span class="line">  tDate: time,</span><br><span class="line">  tDatetime: time,</span><br><span class="line">  tTimestamp: time,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果能看到虽然在 sequelize 中对每列的值设置都一样,但实际却不同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| source_time                                   | t_date     | t_datetime          | t_timestamp         |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00) | 2020-11-09 | 2020-11-09 13:25:32 | 2020-11-09 21:25:32 |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br></pre></td></tr></table></figure><p>能看到 <strong>t_date</strong> 只展示了年月日 <strong>YYYY-MM-DD</strong> ， <strong>t_datetime</strong> 和 <strong>t_timestamp</strong> 虽然日期格式都为 <strong>YYYY-MM-DD HH:mm:ss</strong> ，但之间相差 8 小时，那怎么将他们入库时时区相同呢？</p><h2 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h2><p>那就要在 <strong>sequelize</strong> 设置制定时区了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  database: <span class="string">'ebone'</span>,</span><br><span class="line">  username: <span class="string">'root'</span>,</span><br><span class="line">  password: <span class="string">'root'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  dialect: <span class="string">'mysql'</span>,</span><br><span class="line">  timezone: <span class="string">'+08:00'</span>, <span class="comment">// 时区设置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(config.database, config.username, config.password, options);</span><br></pre></td></tr></table></figure><p>设置完毕后，我们再插入一条数据将发现这两个字段时区相同了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| source_time                                   | t_date     | t_datetime          | t_timestamp         |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00) | 2020-11-09 | 2020-11-09 13:25:32 | 2020-11-09 21:25:32 |</span><br><span class="line">| Mon Nov 09 2020 21:37:20 GMT+0800 (GMT+08:00) | 2020-11-09 | 2020-11-09 21:37:20 | 2020-11-09 21:37:20 |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br></pre></td></tr></table></figure><h2 id="查询结果的“不同”"><a href="#查询结果的“不同”" class="headerlink" title="查询结果的“不同”"></a>查询结果的“不同”</h2><p>除了插入行数据，当我们查询记录时，能看到更有意思的现象（<strong>不设置 sequelize 时区选项</strong>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimeDiff.findAll(&#123;</span><br><span class="line">  raw: <span class="literal">true</span>,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">// 未设置时区时，新增的数据</span></span><br><span class="line">  &#123;</span><br><span class="line">    sourceTime: <span class="string">'Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">    tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">    tDatetime: <span class="string">'2020-11-09T13:25:32.000Z'</span>, <span class="comment">// ？？？</span></span><br><span class="line">    tTimestamp: <span class="string">'2020-11-09T13:25:32.000Z'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 已设置时区时，新增的数据</span></span><br><span class="line">  &#123;</span><br><span class="line">    sourceTime: <span class="string">'Mon Nov 09 2020 21:37:20 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">    tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">    tDatetime: <span class="string">'2020-11-09T21:37:20.000Z'</span>, <span class="comment">// ？？？</span></span><br><span class="line">    tTimestamp: <span class="string">'2020-11-09T13:37:20.000Z'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>而当我们 <strong>sequelize</strong> 设置时区（+8:00）后，看下取值的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    sourceTime: <span class="string">'Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">    tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">    tDatetime: <span class="string">'2020-11-09T05:25:32.000Z'</span>,</span><br><span class="line">    tTimestamp: <span class="string">'2020-11-09T13:25:32.000Z'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    sourceTime: <span class="string">'Mon Nov 09 2020 21:37:20 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">    tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">    tDatetime: <span class="string">'2020-11-09T13:37:20.000Z'</span>,</span><br><span class="line">    tTimestamp: <span class="string">'2020-11-09T13:37:20.000Z'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>对比时区设置前后的查询结果，能看到通过 sequelize 查询到的这两条数据有这几个特点：</p><ol><li><strong>sequelize</strong> 帮我们把 <strong>tDatetime</strong> 和 <strong>tTimestamp</strong> 统一为 iso 时间格式</li><li>未设置时区，<strong>DateTime</strong> 类型的值直接取出显示，设置后，将对设置时区进行偏移后再显示</li><li>对 <strong>Timestamp</strong> 类型的值始终相同</li></ol><h1 id="为何会有这样的不同呢？"><a href="#为何会有这样的不同呢？" class="headerlink" title="为何会有这样的不同呢？"></a>为何会有这样的不同呢？</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>我们设置时间类型的字段都会通过 <strong>sequelize</strong> 进行转义，并进入 <strong>_applyTimezone</strong> 方法。如果我们没有设置过时区，默认时区为 +00:00（options.timezone 判断非空）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DATE</span> <span class="keyword">extends</span> <span class="title">ABSTRACT</span> </span>&#123;</span><br><span class="line">  _applyTimezone(date, options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.timezone) &#123;</span><br><span class="line">      <span class="keyword">if</span> (momentTz.tz.zone(options.timezone)) &#123;</span><br><span class="line">        <span class="keyword">return</span> momentTz(date).tz(options.timezone);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// moment(date).utcOffset('+00:00')</span></span><br><span class="line">      <span class="keyword">return</span> (date = moment(date).utcOffset(options.timezone));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> momentTz(date);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <strong>utcOffset</strong> 起什么作用呢？首先看下默认情况下 <strong>utcOffset</strong> （不设置参数时），utc 时区的偏移量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().utcOffset(); <span class="comment">// 480(480/60=8小时) +08:00</span></span><br></pre></td></tr></table></figure><p><strong>当未设置时区时（+00:00）:</strong></p><p>如果设置 <strong>2020-11-09 21:25:32</strong> （ 本地+08:00 时间）值时，通过 <strong>utcOffset(+00:00)</strong> 方法偏移后，对于 <strong>DateTime</strong> 将落库 <strong>2020-11-09 13:25:32</strong> （<strong>2020-11-09 21:25:32</strong> 减去 8 小时）；</p><p>由于数据库 mysql 设置的时区为本地时间，实际落库为 <strong>2020-11-09 21:25:32</strong>（<strong>2020-11-09 13:25:32</strong> 多加 8 小时），最终<br>为：<strong>2020-11-09 21:25:32</strong></p><p><strong>当设置时区时（+08:00）：</strong></p><p>通过 <strong>utcOffset(+08:00)</strong> 偏移，由于时区和本地一致，所以偏移“无效”，<strong>DateTime</strong> 类型的值将为 <strong>2020-11-09 21:25:32</strong>；</p><p>同时和 mysql 时区一致，对于 <strong>TimeStamp</strong> 的落库值也为：<strong>2020-11-09 21:25:32</strong></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>通过 <strong>seqeulize</strong> 从 <strong>mysql</strong> 查询时，会对取到结果进行解析，对于 <strong>DateTime</strong> 类型的字段会执行 <strong>parse</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Datetime</span></span><br><span class="line"><span class="comment">// sequelize\lib\dialects\mysql\data-types.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DATE</span> <span class="keyword">extends</span> <span class="title">BaseTypes</span>.<span class="title">DATE</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 2020-11-09 13:25:32</span></span><br><span class="line">  <span class="keyword">static</span> parse(value, options) &#123;</span><br><span class="line">    value = value.string();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (moment.tz.zone(options.timezone)) &#123;</span><br><span class="line">      value = moment.tz(value, options.timezone).toDate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// new Date("2020-11-09 13:25:32 +08:00")</span></span><br><span class="line">      value = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> <span class="subst">$&#123;options.timezone&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们设置了 <strong>options.timezone</strong> ，则会在最后添加时区值。</p><p>对于 <strong>Timestamp</strong> 类型，会选择 <strong>mysql2</strong> 模块内置的方法进行解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql2\lib\parsers\text_parser.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCodeFor</span>(<span class="params">type, charset, encodingExpr, config, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> Types.DATE:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`packet.parseDate('<span class="subst">$&#123;timezone&#125;</span>')`</span>;</span><br><span class="line">    <span class="keyword">case</span> Types.DATETIME:</span><br><span class="line">    <span class="keyword">case</span> Types.TIMESTAMP:</span><br><span class="line">      <span class="keyword">if</span> (helpers.typeMatch(type, dateStrings, Types)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'packet.readLengthCodedString("ascii")'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`packet.parseDateTime('<span class="subst">$&#123;timezone&#125;</span>')`</span>;</span><br><span class="line">    <span class="keyword">case</span> Types.TIME:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'packet.readLengthCodedString("ascii")'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql2\lib\packets\packet.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Packet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// +08:00</span></span><br><span class="line">  parseDateTime(timezone) &#123;</span><br><span class="line">    <span class="comment">// 2020-11-09 21:25:32</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="keyword">this</span>.readLengthCodedString(<span class="string">'binary'</span>);</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timezone || timezone === <span class="string">'local'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new Date("2020-11-09 21:25:32+08:00")</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">`<span class="subst">$&#123;str&#125;</span><span class="subst">$&#123;timezone&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述两种类型选择对应解析方法都功能都是相同的，那为何会有上面查询出结果“不同”的现象？原因还是 <strong>DateTime，TimeStamp 和时区的关系</strong>。</p><p>我们以这条记录，在不同时区设置的查询结果进行分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| source_time                                   | t_date     | t_datetime          | t_timestamp         |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br><span class="line">| Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00) | 2020-11-09 | 2020-11-09 13:25:32 | 2020-11-09 21:25:32 |</span><br><span class="line">+-----------------------------------------------+------------+---------------------+---------------------+</span><br></pre></td></tr></table></figure><p><strong>当没有设置过时区（+00:00）时：</strong></p><p>如果 <strong>DateTime</strong> 库值为 <strong>2020-11-09 13:25:32</strong>，最终通过 parse 方法，将返回 new Date(‘2020-11-09 13:25:32+00:00’)，转为 iso 格式，即为：<strong>2020-11-09T13:25:32.000Z</strong>；</p><p>如果 <strong>TimeStamp</strong> 库值为 <strong>2020-11-09 21:25:32</strong>，由于时区不一致，首先 mysql 会根据时区转为 UTC 时间（少 8 小时）为：<strong>2020-11-09 13:25:32</strong>，再进行解析，最终和上面的 <strong>DateTime</strong> 类型的结果一样。</p><p><strong>sequelize</strong> 插叙查询结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  sourceTime: <span class="string">'Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">  tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">  tDatetime: <span class="string">'2020-11-09T13:25:32.000Z'</span>, <span class="comment">// ？？？</span></span><br><span class="line">  tTimestamp: <span class="string">'2020-11-09T13:25:32.000Z'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>而当设置时区后（+08:00）后：</strong></p><p>对于 <strong>DateTime</strong> 类型，对应返回 new Date(‘2020-11-09 13:25:32+08:00’)，转为 iso 格式，即为：<strong>2020-11-09T05:25:32.000Z</strong>；</p><p>而由于 <strong>sequelize</strong> 和 <strong>mysql</strong> 时区一致（+08:00），<strong>TimeStamp</strong> 取出的值直接为：<strong>2020-11-09 21:25:32</strong>，对应返回 new Date(‘2020-11-09 21:25:32+08:00’)，转为 iso 格式，即为：<strong>2020-11-09T13:25:32.000Z</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  sourceTime: <span class="string">'Mon Nov 09 2020 21:25:32 GMT+0800 (GMT+08:00)'</span>,</span><br><span class="line">  tDate: <span class="string">'2020-11-09'</span>,</span><br><span class="line">  tDatetime: <span class="string">'2020-11-09T05:25:32.000Z'</span>,</span><br><span class="line">  tTimestamp: <span class="string">'2020-11-09T13:25:32.000Z'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为时区涉及数据库 和 sequelize 的设置，同时对于不同时区的客户端解析 ISO 格式时间也会不同，所以有几个最佳实践：</p><ul><li>对 DateTime 类型的字段要小心处理</li><li>sequelize 的时区设置要和数据库保持一致</li><li>服务端相关时间做好服务端解析后，再输出给客户端，减少客户端对时间的操作</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/datetime.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/datetime.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sequelize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack import 循环引用，导致引用变量 undefined</title>
      <link href="/legacy/2020/10/29/webpack-circular-import/"/>
      <url>/legacy/2020/10/29/webpack-circular-import/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得两三年前，刚试手用 <strong>webpack</strong> 构建一个 <strong>web</strong> 项目，就遇到了个坑：<strong>import 的 js 文件其引用居然是 undefined</strong>。</p><p>那时工期也不是很充裕，为了解决 <strong>bug</strong>，把导入的 <strong>js</strong> 直接 copy 到当前文件，代码肯定是冗余了，但至少解决了问题。谁知，今年居然遇到了两次类似的问题（死鱼脸），还是印证了那句：</p><blockquote><p>出来混的，有些债迟早要还的！</p></blockquote><p>我尝试百度了下，都没有靠谱的解决方案，很崩溃：</p><img src="/legacy/2020/10/29/webpack-circular-import/baidu.png" class=""><p>那么现在探究下其中的原因了。</p><h1 id="Demo-示例"><a href="#Demo-示例" class="headerlink" title="Demo 示例"></a>Demo 示例</h1><p>抛开复杂的项目结构，用简单的代码示例来还原问题场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a:'</span>, a); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 会导致在此文件中，相关与 a 的操作不符合预期</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>相信各位看了，基本猜到问题的点了：没错，就是 <strong>循环引用</strong> 。</p><p><strong>webpack</strong> 的入口文件为 <strong>main.js</strong>，随后他们的引用方式为： main.js –&gt; a.js –&gt; <strong>b.js –&gt; a.js –&gt; b.js</strong></p><p>问题就出在 <strong>a.js</strong> 被循环引用了，<strong>b.js</strong> 中导入的 <strong>a.js</strong>，其引用值为 <strong>undefined</strong>，虽然我们希望它得到最后的 <strong>1</strong> 结果。</p><p>接下来就看 <strong>webpack</strong> 是如何处理文件的 <strong>import</strong> 导入，以及循环引用为何会引发这样的问题。</p><h1 id="webpack-是如何解析文件的？"><a href="#webpack-是如何解析文件的？" class="headerlink" title="webpack 是如何解析文件的？"></a>webpack 是如何解析文件的？</h1><p>首先，我们的整个 Demo 会被 <strong>webpack</strong> 解析成如下代码结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;; <span class="comment">// The require function</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;&#125; <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="string">'./src/main.js'</span>));</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./src/a.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="string">'./src/b.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="string">'./src/main.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是个立即执行函数，当浏览器加载该 js 后将被触发执行。</p><p>将入口 <strong>entry</strong> 文件 <strong>main.js</strong> 作为入参，执行 <strong>__webpack_require__</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125; <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: <span class="literal">false</span>,</span><br><span class="line">    exports: &#123;&#125;,</span><br><span class="line">  &#125;); <span class="comment">// Execute the module function</span></span><br><span class="line"></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__); <span class="comment">// Flag the module as loaded</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>; <span class="comment">// Return the exports of the module</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125; <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br></pre></td></tr></table></figure><p>在这个 <strong>__webpack_require__</strong> 中，无非就改了如下几件事：</p><ul><li>判断全局 <strong>installedModules</strong> 是否有对应的 <strong>moduleId</strong> 值，有的话就导出其引用</li><li>如果没有，就执行 <strong>modules[moduleId]</strong> 方法，最后返回该模块 module 的引用</li></ul><p>我们可以打几个断点，更细致的看下其中的过程：</p><ol><li><p>进入 <strong>bundle</strong> 文件，执行立即函数，调用 <strong>__webpack_require__</strong> 方法，并传入参数：<strong>‘./src/main.js’</strong></p><img src="/legacy/2020/10/29/webpack-circular-import/w1.png" class=""><p>由于初次调用，<strong>installedModules[moduleId]</strong> 肯定为空，接着通过 <strong>modules[moduleId].call</strong> 借用函数调用。</p><p>被 <strong>call</strong> 的函数就是最开始，传入立即执行函数的参数，根据 <strong>moduleId</strong> 来对应的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'./src/a.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, **webpack_exports**, **webpack_require**</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="string">'./src/b.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, **webpack_exports**, **webpack_require**</span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="string">'./src/main.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, **webpack_exports**, **webpack_require**</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>随后执行对应的 <strong>call</strong> 函数</p><img src="/legacy/2020/10/29/webpack-circular-import/w2.png" class=""><p>能看到 <strong>main.js</strong> 里导入了 <strong>a.js</strong>，则又会调用 <strong>__webpack_require__</strong> 方法</p><img src="/legacy/2020/10/29/webpack-circular-import/w3.png" class=""><p>注意，这里对 <strong>a.js</strong> 的调用并没有结束（返回值还没有拿到），由于 <strong>a.js</strong> 中又导入了 <strong>b.js</strong>，所以又会同上述步骤再执行 <strong>b.js</strong> 对应的函数。</p></li><li><p>前面 <strong>webpack</strong> 执行过程大概是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webpack_require(main.js)</span><br><span class="line">    modules[main.js].call</span><br><span class="line">        # import a from './a.js'</span><br><span class="line">        webpack_require(a.js)</span><br><span class="line">            modules[a.js].call</span><br><span class="line">                # import b from './b.js'</span><br><span class="line">                 webpack_require(b.js)</span><br><span class="line">                    modules[b.js].call</span><br><span class="line">                        # 打住，这里开始要注意了</span><br><span class="line">                        # import a from './a.js'</span><br><span class="line">                        webpack_require(a.js)</span><br></pre></td></tr></table></figure><p>但到 <strong>modules[b.js].call</strong> 时就不同了，<strong>b.js</strong> 文件中导入了 <strong>a.js</strong> 文件，导致 <strong>a.js</strong> 作为参数又会进入到 <strong>__webpack_require__</strong> 方法。</p><p>因为先前 <strong>webpack_require(a.js)</strong> 被执行过了，所以在 <strong>modules[b.js].call</strong> 环节执行 <strong>webpack_require(a.js)</strong> 中，<strong>installedModules[moduleId]</strong> 判断为 <strong>true</strong> 了：</p><img src="/legacy/2020/10/29/webpack-circular-import/w4.png" class=""><p>而最开始第一次导入 <strong>a.js</strong> 时，其返回值还没有拿到，所以此时为 <strong>true</strong> 后，返回值就为 <strong>undefined</strong> ，这就是问题的出现原因。</p></li></ol><h1 id="怎么避免"><a href="#怎么避免" class="headerlink" title="怎么避免"></a>怎么避免</h1><p>现在前端项目也很复杂，多少有几率会遇到这样重复循环引用的情况，那怎么发现排查，或者怎么从设计上避免过去？</p><h2 id="circular-dependency-plugin"><a href="#circular-dependency-plugin" class="headerlink" title="circular-dependency-plugin"></a>circular-dependency-plugin</h2><p>推荐一个 npm 模块：<strong>circular-dependency-plugin</strong>，我们可以在 webpack 配置文件中添加对应的 plugins 设置，在构建时抛出这样的错误引用链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CircularDependencyPlugin = <span class="built_in">require</span>(<span class="string">'circular-dependency-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CircularDependencyPlugin(&#123;</span><br><span class="line">      <span class="comment">// exclude detection of files based on a RegExp</span></span><br><span class="line">      exclude: <span class="regexp">/a\.js|node_modules/</span>,</span><br><span class="line">      <span class="comment">// include specific files based on a RegExp</span></span><br><span class="line">      include: <span class="regexp">/src/</span>,</span><br><span class="line">      <span class="comment">// add errors to webpack instead of warnings</span></span><br><span class="line">      failOnError: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// allow import cycles that include an asyncronous import,</span></span><br><span class="line">      <span class="comment">// e.g. via import(/* webpackMode: "weak" */ './file.js')</span></span><br><span class="line">      allowAsyncCycles: <span class="literal">false</span>,</span><br><span class="line">      <span class="comment">// set the current working directory for displaying module paths</span></span><br><span class="line">      cwd: process.cwd(),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后，我们的控制台就能看到如下错误引用的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR in Circular dependency detected:</span><br><span class="line">src\b.js -&gt; src\a.js -&gt; src\b.js</span><br></pre></td></tr></table></figure><h2 id="切断引用链"><a href="#切断引用链" class="headerlink" title="切断引用链"></a>切断引用链</h2><p>首先就上面 <strong>b.js -&gt; a.js -&gt; b.js</strong> 无非就是中间 <strong>a.js</strong> 是个问题模块，如果 <strong>a.js</strong> 中不 <strong>import</strong> <strong>b.js</strong> 那么就不会出现这问题。</p><p>我们可以修改 <strong>a.js</strong> 中的引用文件，重新创建一个 <strong>c.js</strong> 专门提供某一个功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import b from './b';</span></span><br><span class="line"><span class="comment">// export default b;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> c <span class="keyword">from</span> <span class="string">'./c'</span>;</span><br><span class="line">c = c + <span class="number">1</span>; <span class="comment">// 假设有一定的转换规则</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> c;</span><br></pre></td></tr></table></figure><p>a 不找 b，那么 b 也不会引用 a 了，这样中间的环节就被切断了。</p><p>如果 <strong>a.js</strong>，<strong>b.js</strong> 中间有一些重复功能，我们可以提取公共功能然后作为第三方文件导入（但需要注意不要再自己创造循环嵌套），这样一方面可以解耦代码，另一方面可以规避循环引用。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>webpack 作为工具，我一直不放精力去研读里面的条条道道，当然也搞不清 loader，plugins 之类的原理。你说搞清一个工具，或者某个库，甚至框架重不重要？但就上面这个问题，已经让我不得不去观察 webpack 运行中的一些机制。</p><p>还有很多路要走，别把解决问题当做终点，这样会让债越堆越多，别在某天上线时候让你来 debugger 调试。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的渲染</title>
      <link href="/legacy/2020/10/03/html-render/"/>
      <url>/legacy/2020/10/03/html-render/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前端代码离不开浏览器环境，理解 js、css 代码如何在浏览器中工作是非常重要的。</p><p>如何优化渲染过程中的回流，重绘？script 脚本在页面中是怎么个加载顺序？了解这些对前端性能优化起着非常大的作用。</p><p>借着这篇文章，让自己对这块知识的理解更深一步。</p><h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><h2 id="渲染树（Render-Tree）"><a href="#渲染树（Render-Tree）" class="headerlink" title="渲染树（Render Tree）"></a>渲染树（Render Tree）</h2><p>浏览器通过解析 HTML 和 CSS 后，形成对应的 DOM 树和 CSSOM 树。</p><p>从根节点开始解析 DOM 树节点并匹配对应的 CSSOM 样式规则，选择<strong>可见的</strong>的节点，最终结合成一颗<strong>渲染树</strong>。</p><img src="/legacy/2020/10/03/html-render/render-tree-construction.png" class=""><p>从上图能看到渲染树的特点：</p><ul><li>渲染树中不包含 head、script、link、meta 之类不可见的节点</li><li>CSS 定义的样式规则将和实际的 DOM 匹配，并且被 <strong>display:none</strong> 修饰的节点最终不会出现在渲染树中</li></ul><h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><img src="/legacy/2020/10/03/html-render/render-order.png" class=""><p>根据上图，整个渲染阶段分为三部分：</p><ul><li>渲染树的形成：通过 DOM 和 CSSOM 形成渲染树</li><li>布局 Layout（自动重排 Reflow）：基于页面的流式布局，遍历渲染树节点，不断计算节点最终的位置，几何信息，样式等属性后，输出一个“盒模型”</li><li>绘制 Paint（栅格化）：将节点位置，大小根据屏幕的窗口大小换算成真实的像素，同颜色等属性一同“画到”页面上</li></ul><h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>回流 Reflow：某些元素位置、几何形状的更改需要浏览器重新计算相关元素。</li><li>重绘 Repaint：将回流重排好的元素绘制到页面上，但也因某些 js、css 的修改导致渲染树发生变化，浏览器需要再次绘制页面。</li></ul><p>两者的关系：<strong>触发回流一定会触发重绘, 而触发重绘却不一定会触发回流</strong></p><p>下图很形象的展示了 Mozilla 页面的渲染过程。</p><img src="/legacy/2020/10/03/html-render/Mozilla.gif" class=""><h3 id="触发回流条件"><a href="#触发回流条件" class="headerlink" title="触发回流条件"></a>触发回流条件</h3><ul><li>首次布局渲染页面</li><li>改变浏览器窗口大小</li><li>改变字体</li><li>网页内容变化</li><li>触发 CSS 伪类</li><li>操作 DOM</li><li>style 样式表发生变化</li><li>调用 DOM 元素的 offsetXX, clientXX，scrollXX，getClientRects 等属性方法，获取元素当前的位置度量信息（<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">参见</a>）</li></ul><h3 id="如何测试网页性能"><a href="#如何测试网页性能" class="headerlink" title="如何测试网页性能"></a>如何测试网页性能</h3><p>都知道频繁的渲染过程会影响网页性能，但怎么知道网页开始渲染内容了呢？</p><p>我们可以通过 Chrome 的 F12，选择 Rendering 来查看网页的性能。</p><img src="/legacy/2020/10/03/html-render/performance1.png" class=""><img src="/legacy/2020/10/03/html-render/performance2.png" class=""><ul><li>Paint flashing: 以绿色高亮重绘区域</li><li>Layout Shift Regions: 以蓝色高亮布局发生变化的区域</li></ul><p>结合上面的方法，用 <strong>一个简单的 Demo</strong> 来示意：</p><img src="/legacy/2020/10/03/html-render/performance.gif" class=""><p>能从图中看到，这些操作 <strong>触发了浏览器的重绘</strong>：</p><ul><li>鼠标移至按钮上，触发了默认的 hover 效果（出现绿框）</li><li>改变元素 color 属性（出现绿框）</li><li>修改元素 top 属性，不断改变元素位置影响布局（出现绿框，蓝框）</li></ul><h3 id="提升渲染性能"><a href="#提升渲染性能" class="headerlink" title="提升渲染性能"></a>提升渲染性能</h3><p><strong>布局/回流</strong> 和 <strong>绘制/重绘</strong> 是页面渲染必须会经过的两个过程，不断触发它们肯定会增加性能的消耗。</p><p>浏览器会对这些操作做优化（把它们放到一个队列，批量进行操作），但如果我们调用上面提到的 offsetXX, clientXX，scrollXX，getClientRects 等属性方法就会强制刷新这个队列，导致这些队列批量优化无效。</p><p>下面列举一些简单优化方式：</p><ul><li><p>不要使用 table 布局<br>table 布局会破坏 HTML 流式解析过程，甚至内部元素改动会触发整个 table 重绘</p></li><li><p>将需更改的 class 放到最里层<br>明确元素位置，减少父类元素不必要渲染判断</p></li><li><p>使用 fixed、absolute 属性修饰复杂多变的处理（动画）<br>将改变范围降到最低程度，避免影响到父级元素</p></li><li><p>合并，减少 DOM 操作；通过虚拟 DOM 来代替</p></li></ul><h1 id="脚本的加载"><a href="#脚本的加载" class="headerlink" title="脚本的加载"></a>脚本的加载</h1><h2 id="link-和-script-加载文件的差异"><a href="#link-和-script-加载文件的差异" class="headerlink" title="link 和 script 加载文件的差异"></a>link 和 script 加载文件的差异</h2><p><strong>注：均放在 head 标签内。</strong></p><blockquote><p>考个问题：CSS 定义在 head 中，其需加载 5 秒，请问页面加载后内容会先优先展示吗？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 延迟5秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/css/demo.css?t=5000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span>我被渲染出来了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我原先以为页面内容会优先渲染，CSS 加载完成后才改变内容样式。其实这是错的。</p><img src="/legacy/2020/10/03/html-render/link.gif" class=""><p>从上图看到，页面加载后，body 内元素就已经解析好了，只是没有渲染到页面上。随后 CSS 文件加载后，带有样色的内容才被渲染到页面上。</p><p><strong>延迟的 link 的加载阻断了页面渲染，但并没有影响 HTML 的解析</strong>，当 CSS 加载后，DOM 完成解析，CSSOM 和 DOM 形成渲染树，最后将内容渲染到页面上。</p><blockquote><p>反问，将 link 替换成 script 效果也一样吗？</p></blockquote><img src="/legacy/2020/10/03/html-render/script.gif" class=""><p>与 link 不同，<strong>script 的加载会阻断页面 HTML 的解析</strong>，浏览器解析完 script 后，会等待 js 文件加载完后，页面才开始后续的解析，body 内容才出现。</p><h2 id="head-和-body-中的-script-标签"><a href="#head-和-body-中的-script-标签" class="headerlink" title="head 和 body 中的 script 标签"></a>head 和 body 中的 script 标签</h2><p>学前端时相信都听过这样的名言：</p><blockquote><p>CSS 写在 head 里，js 写在 body 结束标签前</p></blockquote><p>知道了上面 <strong>link 和 script</strong> 的区别后，应该明白前半句的含义，下面来解释下后半句。</p><p><strong>下面 script 均在 body 中</strong>。</p><h3 id="页面渲染-和-script-加载"><a href="#页面渲染-和-script-加载" class="headerlink" title="页面渲染 和 script 加载"></a>页面渲染 和 script 加载</h3><p>先看下脚本在 body 中的一般情况：</p><p>在 body 内部的首位分别加载两个 js 文件，前者延迟 3 秒，后者延迟 5 秒，为了清楚他们的“工作”情况，在 head 中添加了定时器示意。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> t = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">        t++;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'已加载 '</span>, t, <span class="string">' 秒'</span>);</span></span><br><span class="line">        if (t == 10) &#123;</span><br><span class="line">          clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 1 * 1000);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> foo = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'init foo'</span>, foo);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addTen.js?t=3000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我被渲染了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addOne.js?t=5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2020/10/03/html-render/script-load1.gif" class=""><p>能看到 body 中定义的内联脚本首先工作，初始化 foo 变量。</p><p>随后加载 addTen.js，并阻断页面渲染。3 秒后，输出 js 内容（foo 赋值为 10），页面并重新开始解析，展示 div 内容。</p><p>最后加载 addOne.js ，继续等待 2 秒后，输出 js 内容（foo 赋值为 11）。</p><img src="/legacy/2020/10/03/html-render/script-load2.png" class=""><h3 id="多个-script-文件的加载"><a href="#多个-script-文件的加载" class="headerlink" title="多个 script 文件的加载"></a>多个 script 文件的加载</h3><blockquote><p>如果前一个 js 文件加载慢于后一个，会有怎么个效果？</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addTen.js?t=5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我被渲染了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addOne.js?t=1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两个 script 标签并行加载，1 秒后 addOne.js 首先加载完毕，等待 4s 秒后，addTen.js 加载完后，页面直接渲染（因为 script 已经全部完成）。</p><img src="/legacy/2020/10/03/html-render/script-load3.png" class=""><h3 id="简单总结下"><a href="#简单总结下" class="headerlink" title="简单总结下"></a>简单总结下</h3><ol><li>无论在 head 还是 body 中，浏览器会等待 script 文件的加载（阻断页面解析渲染）</li><li>多个 script 的文件加载是异步的，不存在互相影响（后一个文件不需要等待前一个加载完后才下载），<strong>执行顺序同定义顺序</strong></li></ol><p>所以建议 script 放在 body 结束标签之前，确保页面内容全部解析完成并开始渲染。</p><h2 id="DOM-的-DOMContentLoaded-事件"><a href="#DOM-的-DOMContentLoaded-事件" class="headerlink" title="DOM 的 DOMContentLoaded 事件"></a>DOM 的 DOMContentLoaded 事件</h2><p><strong>DOMContentLoaded</strong> 事件可以来确定整个 DOM 是否全部加载完成，下面我们简单测试下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'[ready] document'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addTen.js?t=5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我被渲染了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addOne.js?t=1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addTen.js</span><br><span class="line">foo 10</span><br><span class="line">addOne.js</span><br><span class="line">foo 11</span><br><span class="line">[ready] document</span><br></pre></td></tr></table></figure><p><strong>DOMContentLoaded</strong> 事件的定义是异步回调方式，当 DOM 加载完成后触发，即使写在最前面，也会等待后面的 script 加载完成后才触发。</p><p>这里顺便提个 <strong>window.onload</strong> ：</p><p><strong>window.onload</strong> 和 <strong>DOMContentLoaded</strong> 不同，前者会等待页面中所有的资源加载完毕后再调用执行（比如：img 标签），后者在 DOM 加载完毕后即触发。</p><h2 id="“真正的异步脚本”——动态脚本"><a href="#“真正的异步脚本”——动态脚本" class="headerlink" title="“真正的异步脚本”——动态脚本"></a>“真正的异步脚本”——动态脚本</h2><p>能看到无论 script 放在那个位置，浏览器都会等待他们直至 body 内的文件全部加载完。</p><p>那有什么 <strong>真正的异步</strong> 脚本加载吗？（不会阻断页面解析）</p><blockquote><p>那就是 <strong>动态脚本</strong>。</p></blockquote><p>如果你接触过第三方网页统计脚本，那将比较了解，下面给段示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'[ready] document'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">  newScript.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">  newScript.src = <span class="string">'/js/dynamicScript.js?t=8000'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(newScript);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 脚本加载完毕</span></span></span><br><span class="line">  if (newScript.readyState) &#123;</span><br><span class="line"><span class="actionscript">    newScript.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (newScript.readyState == <span class="string">'loaded'</span> || newScript.readyState == <span class="string">'complete'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'dynamicScript.js loaded'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">    newScript.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'dynamicScript.js loaded'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addTen.js?t=5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我被渲染了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addOne.js?t=1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">addTen.js</span><br><span class="line">afoo 10</span><br><span class="line">addOne.js</span><br><span class="line">foo 11</span><br><span class="line">[ready] document</span><br><span class="line">已加载  5  秒</span><br><span class="line">已加载  6  秒</span><br><span class="line">已加载  7  秒</span><br><span class="line">已加载  8  秒</span><br><span class="line">dynamicScript.js is running</span><br><span class="line">dynamicScript.js loaded</span><br><span class="line">已加载  9  秒</span><br><span class="line">已加载  10  秒</span><br></pre></td></tr></table></figure><img src="/legacy/2020/10/03/html-render/script-load4.png" class=""><p>定义了需要加载 8 秒的 dynamicScript.js 文件，所有的 script 加载方式依旧异步，但 dynamicScript.js 在 <strong>DOMContentLoaded</strong> 触发后，最后才执行，浏览器并没有等待它的加载完成后才渲染页面。</p><p>我们也可以将它放在 head 中。这种通过脚本来动态修改 DOM 结构的加载方式是 <strong>无阻塞式</strong> 的，不受其他脚本加载的影响。</p><h2 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h2><p>我们可以在 script 定义 <strong>defer</strong> 、 <strong>async</strong> ，使整个脚本加载方式更加友好。比如：<strong>被修饰的脚本在 head 中，将不会阻断 body 内容的展示</strong>。</p><p>注意： <strong>defer</strong> 修饰的脚本将延迟到 body 中所有定义的脚本之后，<strong>DOM（页面内容）加载完之前触发</strong>； <strong>async</strong> 不会像 <strong>defer</strong> 一样等待 body 中的脚本，而是当前脚本一加载完毕就触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果上面没有其他响应慢的脚本，解析到此处加载完后将立马执行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/scriptAsync.js?t=3000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1 秒，延迟到 DOM 加载完毕 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"/js/scriptDefer.js?t=1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'[ready] document'</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> newScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    newScript.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">    newScript.src = <span class="string">'/js/dynamicScript.js?t=8000'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(newScript);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 脚本加载完毕</span></span></span><br><span class="line">    if (newScript.readyState) &#123;</span><br><span class="line"><span class="actionscript">      newScript.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (newScript.readyState == <span class="string">'loaded'</span> || newScript.readyState == <span class="string">'complete'</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'dynamicScript.js loaded'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">      newScript.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'dynamicScript.js loaded'</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'init foo'</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> foo = <span class="number">0</span>;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addTen.js?t=5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我被渲染了<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/addOne.js?t=1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">已加载  1  秒</span><br><span class="line">已加载  2  秒</span><br><span class="line">scriptAsync.js</span><br><span class="line">已加载  3  秒</span><br><span class="line">已加载  4  秒</span><br><span class="line">addTen.js</span><br><span class="line">foo 10</span><br><span class="line">addOne.js</span><br><span class="line">foo 11</span><br><span class="line">scriptDefer.js</span><br><span class="line">[ready] document</span><br><span class="line">已加载  5  秒</span><br><span class="line">已加载  6  秒</span><br><span class="line">已加载  7  秒</span><br><span class="line">已加载  8  秒</span><br><span class="line">dynamicScript.js is running</span><br><span class="line">dynamicScript.js loaded</span><br><span class="line">已加载  9  秒</span><br><span class="line">已加载  10  秒</span><br></pre></td></tr></table></figure><h1 id="浏览器的进程和线程"><a href="#浏览器的进程和线程" class="headerlink" title="浏览器的进程和线程"></a>浏览器的进程和线程</h1><p>进程和线程不是一个概念。一个进程内可能包含多个线程。</p><p>通常一个浏览器（chrome） tab 页面的开启会创建一个进程，我们能在任务管理器中看到。同时每个页面从 HTML 的解析到最终页面的呈现，以及后台的工作会通过多个线程协同进行配合。</p><p>这些线程有：</p><ul><li>Main Thread （主线程）</li><li>Worker Thread</li><li>Compositor Thread（排版线程）</li><li>Raster Thread（光栅线程）</li></ul><p>首先像上面提到的浏览器渲染过程（布局，绘制）都是在 <strong>Main Thread</strong> 中完成。</p><p>当浏览器的渲染进程收到 HTML 后，<strong>Main Thread</strong> 会开始解析 HTML，并生成 DOM 节点，中间解析到 script 标签后将停止解析，直至它加载并运行完成（因为它可能会改动 DOM 节点，这大概就是为何 link 标签不会阻断 HTML 解析的原因）。</p><p>不断计算 CSSOM 和 DOM，将他们生成渲染树，<strong>Main Thread</strong> 会通知 <strong>Compositor Thread</strong> 线程进行合成加工，把结果交给 <strong>Raster Thread</strong> ，<strong>Raster Thread</strong> 处理后会交给 GPU 进行显示。</p><h1 id="感谢-amp-参考"><a href="#感谢-amp-参考" class="headerlink" title="感谢&amp;参考"></a>感谢&amp;参考</h1><ul><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn" target="_blank" rel="noopener">渲染树构建、布局及绘制</a></li><li><a href="https://anran758.github.io/blog/2018/01/15/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E6%B1%87/" target="_blank" rel="noopener">性能优化 - 回流与重绘的调试与优化</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Layout" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li><a href="https://juejin.im/post/6844903569087266823" target="_blank" rel="noopener">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">图解浏览器的基本工作原理</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标签 script 加载机制</title>
      <link href="/legacy/2020/05/23/js-script-loading/"/>
      <url>/legacy/2020/05/23/js-script-loading/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们平时“搬砖”只关注业务代码，页面脚本现在都由 webpack 帮我们自动组装，可能会忽略页面 script 的一些细节。</p><p>下面列了有关 script 标签的几个小问题，可以来自测下：</p><ul><li>script 标签放在 header 和 body 的区别？</li><li>script 中的 defer、async 属性有什么作用？</li><li>多脚本加载时间不同，会影响其执行顺序么？</li><li>document.ready 和 window.load 在 script 加载中的作用？</li><li>什么是动态脚本加载？</li></ul><p>不太明白没有关系，必须承认我做了那么多年也对这块朦朦胧胧（没有具体实践过），下面会从简单的 demo 帮大家捋清这些概念。</p><p><strong>demo 说明</strong></p><p>利用 koa 起一个简单的 server 服务，通过 koa-static 实现资源文件的加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> lazyLoadScript(ctx.path);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">static</span>(path.join(__dirname, <span class="string">'public'</span>))(ctx, next);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>使用 setTimeout 简单实现一个延迟加载功能的方法，用来模拟 js 脚本加载很慢的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadScript</span>(<span class="params">path, time = <span class="number">3000</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// js 文件将被特意延迟 3 秒</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/\/js\/test\d+\.js/</span>.test(path)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`拦截 <span class="subst">$&#123;path&#125;</span>，<span class="subst">$&#123;time&#125;</span> 秒后返回`</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`响应 <span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">          resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125;, time);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的 html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>script 加载机制<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>script 加载机制<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面会改动 html 和延迟加载的逻辑，来说明相关的概念，现在开始吧。</p><h2 id="脚本在页面的位置"><a href="#脚本在页面的位置" class="headerlink" title="脚本在页面的位置"></a>脚本在页面的位置</h2><p>script 通常被放在 header 或者 body 标签中，但位置的不同对于页面的加载效果也不一样。</p><h3 id="放在-header-中"><a href="#放在-header-中" class="headerlink" title="放在 header 中"></a>放在 header 中</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;script 加载机制&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src='/</span>js/test1.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script src='</span>/js/test2.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script src='</span>/js/test3.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2020/05/23/js-script-loading/header.gif" class="" title="效果图"><p>你能看到 html <strong>第一时间被加载进来</strong>，但页面 body 内容迟迟没有渲染出来。因为在等待 header 标签中 script 脚本的加载，3 秒后，整个页面渲染完成。</p><h3 id="放在-body-底部"><a href="#放在-body-底部" class="headerlink" title="放在 body 底部"></a>放在 body 底部</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h2&gt;script 加载机制&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src='/</span>js/test1.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script src='</span>/js/test2.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script src='</span>/js/test3.js<span class="string">'&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2020/05/23/js-script-loading/body.gif" class="" title="效果图"><p>这次 html 内容第一时间渲染完成，随后等待 js 的加载。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>脚本会阻塞页面的渲染</strong>，所以推荐将其放在 body 底部，因为当解析到 script 标签时，通常页面的大部分内容都已经渲染完成，让用户马上能看到一个非空白页面。</p><p>另外你能看到多个脚本之间都是异步向服务器请求，他们之间不互相依赖，最终只等待 3 秒，而非 3+3+3 秒。</p><h2 id="脚本延迟时间不同会影响执行顺序吗？"><a href="#脚本延迟时间不同会影响执行顺序吗？" class="headerlink" title="脚本延迟时间不同会影响执行顺序吗？"></a>脚本延迟时间不同会影响执行顺序吗？</h2><p>一般我们都是按如下方式编写 script 脚本顺序的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个脚本输出一个简单逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1'</span>);</span><br></pre></td></tr></table></figure><p>如果资源请求没有问题，通常脚本的执行顺序都符合预期，能看控制台看到对应的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br></pre></td></tr></table></figure><p>为了模拟复杂的网络环境，假定每个请求都有所延迟（<strong>最先请求最晚响应</strong>），他们的执行执行顺序是否受影响？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="string">'/js/test1.js'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * <span class="number">000</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path == <span class="string">'/js/test2.js'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// await lazyLoadScript(ctx.path);</span></span><br><span class="line">  <span class="keyword">await</span> lazyLoadScript(ctx.path, setTime(ctx.path));</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">static</span>(path.join(__dirname, <span class="string">'public'</span>))(ctx, next);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>和之前的结果一致。多个脚本异步加载，虽然脚本间响应时间不同，但最终执行顺序和请求顺序一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 3 秒后</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">test3</span><br></pre></td></tr></table></figure><p>同时也应证了上面提到的，多个脚本之间不互相阻塞。</p><img src="/legacy/2020/05/23/js-script-loading/loaded.gif" class="" title="效果图"><h2 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h2><p>这两个要放在一起讨论，因为都有延迟作用。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>最开始提到了 script 的放置位置（header 和 body），defer 属性就可以解决这样的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"/js/test1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"/js/test2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"/js/test3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标记 defer 的脚本标签，即使写在 header 位置，也不会阻塞页面的加载。但先于 document 加载完之前。</p><p>同时，这些脚本执行顺序依旧和他们书写的一致，不受延迟时间不同的影响。</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 和 defer 类似，但有如下两点不同：</p><ul><li>先加载完的脚本，先执行</li><li>document 全部加载完后，才执行 async 标记的脚本</li></ul><p>我们前面已经知道了：脚本之间不受延迟时间的影响，执行顺序和他们请求顺序一致。</p><p>如果我们在 test1.js 定义了一个全局变量，即使此脚本会延迟响应很久，但在之后 test3.js 运行时依旧能取到值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟 3 秒</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1'</span>);</span><br><span class="line"><span class="keyword">var</span> globalNum = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟 1 秒</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test3'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(globalNum);</span><br></pre></td></tr></table></figure><p>不过，放在 async 标记的脚本中，执行顺序就不同了：</p><img src="/legacy/2020/05/23/js-script-loading/async.gif" class="" title="效果图"><p>能看到，最先响应回来的脚本先执行，此时 test1.js 定义的全局变量还没有声明，就会报错。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>defer 和 async 主要功能类似，都是为了不阻塞页面内容的渲染。</p><p>但在使用 async 属性时，需要特别注意。因为他会脱离脚本之间约定好的顺序，<strong>建议在和业务代码不相干的脚本中使用，避免发生脚本之间互相依赖的问题</strong>。</p><h2 id="document-ready-和-window-onload"><a href="#document-ready-和-window-onload" class="headerlink" title="document.ready 和 window.onload"></a>document.ready 和 window.onload</h2><p>document.ready 是 jQuery 里实现的方法，内部其实是对 document 的 DOMContentLoaded 事件做监听。这里就以 document.ready 来示意。</p><p>下面，测试他们之间的执行顺序（script 至于 body 底部）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'window ready'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'document  ready'</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/test3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>脚本加载和 document.ready 与 window.onload 的顺序如下：</p><img src="/legacy/2020/05/23/js-script-loading/ready.png" class="" title="顺序"><p>先加载脚本，脚本全部执行后，触发 document 的 DOMContentLoaded 事件，最后执行 window.onload。</p><h3 id="那-document-ready-和-window-onload-有什么区别？"><a href="#那-document-ready-和-window-onload-有什么区别？" class="headerlink" title="那 document.ready 和 window.onload 有什么区别？"></a>那 document.ready 和 window.onload 有什么区别？</h3><p>首先顺序上，window.onload 晚于 document.ready；另外，如果页面有异步资源（图片），window.onload 会等待图片资源响应完后再触发。</p><img src="/legacy/2020/05/23/js-script-loading/image.gif" class="" title="顺序"><p>能看到 image 图片加载完后，window.onload 才被调用。</p><h3 id="使用-async-时的不同"><a href="#使用-async-时的不同" class="headerlink" title="使用 async 时的不同"></a>使用 async 时的不同</h3><p>使用 defer 不会对他们之间的执行顺序造成影响，脚本执行先于 document.ready 执行。</p><p>而 async 却会对原先的执行过程有 <strong>大改变</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'window ready'</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'document  ready'</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/test1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/test2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/test3.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2020/05/23/js-script-loading/ready-async.png" class="" title="顺序"><p>document.ready 不再等待脚本的加载完成，页面渲染完后则会被触发。async 标识的脚本延迟加载，加载完后立马执行。</p><h2 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h2><p>直接看代码（摘自《高性能 Javascript》）:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> newScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">  newScript.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">  newScript.src = <span class="string">'/js/test1.js'</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(newScript);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 脚本加载完毕</span></span></span><br><span class="line">  if (newScript.readyState) &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// IE</span></span></span><br><span class="line"><span class="actionscript">    newScript.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (newScript.readyState == <span class="string">'loaded'</span> || newScript.readyState == <span class="string">'complete'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'loaded'</span>, newScript.src);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">    newScript.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'loaded'</span>, newScript.src);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当页面加载时，只是解析 script 标签内的代码。当 document 全部准备完毕后，将发送请求加载资源。</p><p>这样将不影响页面内容的渲染，同时上面代码将动态加载的脚本添加到 head 标签中，能够不受 body 内出现错误的影响。</p><p>事实上，应该发现百度统计代码，或者其他平台的一些脚本都是通过这种形式动态将脚本注入到我们页面中的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>之前面试时我也遇到过有面试官提过此类问题，那时我回答的很简单。</p><p>但通过这样正儿八经的实践后，觉得了解其中的道理对提升网页性能有非常大的帮助。希望同样对大家有所帮助，如果不对之处，请评论指出，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 颜色渐变</title>
      <link href="/legacy/2020/04/21/gradient/"/>
      <url>/legacy/2020/04/21/gradient/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近接私活，接触到以前公司没有特别注重的一些 css 效果，比如：颜色渐变。</p><p>虽然随便百度下能解决问题，但还是想正儿八经的整理下类似需求。</p><h1 id="边框颜色渐变"><a href="#边框颜色渐变" class="headerlink" title="边框颜色渐变"></a>边框颜色渐变</h1><p>直接使用 linear-gradient 来描述颜色即可，但这个不能作用于 border 或者 border-color 属性，需要用在 border-image 上！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 20px solid linear-gradient(red, green); //error</span><br></pre></td></tr></table></figure><p>上篇讲过 <a href="./2020-04-21-border-image">《css border-image 属性》</a>，所以如果有了这块的了解，那 border 的渐变将非常容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border</span>: 20<span class="selector-tag">px</span> <span class="selector-tag">solid</span>;</span><br><span class="line"><span class="selector-tag">border-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>) 30 30;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/gradient/border.png" class=""><h1 id="背景色渐变"><a href="#背景色渐变" class="headerlink" title="背景色渐变"></a>背景色渐变</h1><p>背景色要使用渐变色可以直接在 background 上定义，或者在 background-image 上定义。但不能再 background-color 使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">yellow</span>, <span class="selector-tag">green</span>);</span><br><span class="line"><span class="comment">/* or */</span></span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">yellow</span>, <span class="selector-tag">green</span>);</span><br><span class="line"><span class="comment">/* error */</span></span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">yellow</span>, <span class="selector-tag">green</span>);</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/gradient/background.png" class=""><h1 id="字体渐变"><a href="#字体渐变" class="headerlink" title="字体渐变"></a>字体渐变</h1><p>字体渐变会有很大不同，首先我们需要设置一个背景色，然后将字体颜色设置为 <strong>透明</strong>，这样背景色将为做文字颜色。</p><p>另外，还需要设置 background-clip 属性，这个属性将控制背景色延伸到哪个位置。</p><p>比如为 text，背景色将全用于字体（注意此值只属于 webkit）。其他还有：border-box、padding-box、content-box 等取值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">yellow</span>, <span class="selector-tag">green</span>);</span><br><span class="line"><span class="selector-tag">-webkit-background-clip</span>: <span class="selector-tag">text</span>;</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/gradient/font.png" class="">]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css border-image 属性</title>
      <link href="/legacy/2020/04/21/border-image/"/>
      <url>/legacy/2020/04/21/border-image/</url>
      
        <content type="html"><![CDATA[<h1 id="边框设置背景图"><a href="#边框设置背景图" class="headerlink" title="边框设置背景图"></a>边框设置背景图</h1><h2 id="边框设置背景图和-background-不一样"><a href="#边框设置背景图和-background-不一样" class="headerlink" title="边框设置背景图和 background 不一样"></a>边框设置背景图和 background 不一样</h2><p>首先为 border 设置背景图并不是像 background 一样，可以维护 url() 或者 color。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 20px solid url('./border-source.png'); //error</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">red</span>;</span><br><span class="line">background: url('./border-source.png');</span><br></pre></td></tr></table></figure><p>专门设置边框图片需要使用 <strong>border-image</strong> 属性，但是其中设置会有些麻烦（我刚接触这属性完全没头绪）。</p><p>下面由浅入深，尽可能这这个属性描述清楚。</p><h2 id="border-image-source-引用资源"><a href="#border-image-source-引用资源" class="headerlink" title="border-image-source 引用资源"></a>border-image-source 引用资源</h2><p>比如，我们有个这样的图片（中间画了很多颜色线条），将它放到边框 border 中作为背景图该怎么做？</p><img src="/legacy/2020/04/21/border-image/border-source.png" class=""><p>首先 <strong>border-image-source</strong> 和 <strong>background-image</strong> 一样，都是具体引用资源的属性。</p><p>思考如下代码，<strong>会有怎么样的显示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-linear</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 20px solid red;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    border-image-source: url('./border-source.png');</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border-linear"</span>&gt;</span></span><br><span class="line">  自定义边框</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>是不是很奇怪？只出来四个角。</strong></p><img src="/legacy/2020/04/21/border-image/border-image1.png" class=""><h2 id="border-image-slice-切割素材"><a href="#border-image-slice-切割素材" class="headerlink" title="border-image-slice 切割素材"></a>border-image-slice 切割素材</h2><p>这里就要明白 <strong>border-image</strong> 一些属性概念：</p><img src="/legacy/2020/04/21/border-image/border-image.png" class=""><p>如上图，我们的（图片）资源将被切割成 9 块内容。其中 1~8 将作为边框内容，9 是在 <strong>border-image</strong> 值中出现 fill 时填充到边框内部的元素上。</p><p>1~4 （corner region）作为边框四个角，5~8 （edge region）在四条边上按照特定的方式显示。</p><p>那怎么让这个边框“正常”些呢？这里就涉及第二个属性：<strong>border-image-slice</strong>。</p><p>现在添加该属性，并设置 1px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-slice</span>: 1;</span><br></pre></td></tr></table></figure><p>应该有点味道了，<strong>但为什么全是灰色的呢？</strong></p><img src="/legacy/2020/04/21/border-image/border-image2.png" class=""><p>首先 <strong>border-image-slice</strong> 设置为 1，其表示将截取背景图 5~8 位置中 1px 的“素材”；同时，我们 border 的宽度为 30px，按照这属性的定义，这 1px 的内容将在 30px 的宽度中按照特定的方式重复。</p><p>这里提到的特定方式是指 <strong>border-image-repeat</strong> 对应的 stretch | repeat | round | space 。</p><p><strong>那怎么将图片资源按照预期显示呢？</strong></p><p>我们图片资源单边的宽度正好也是 30px，那么现在就将 <strong>border-image-slice</strong> 设置为 30px，按照预期将填充到 border 的四个 30px 宽度的边框中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-slice</span>: 30;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/border-image/border-image3.png" class=""><p><strong>border-image-slice 也可以分别设置四条边：</strong></p><p>和 padding 一样，支持：上下+左右、上+右+下+左、上+左右+下 这几种形式，我们这里就将上下的边设置的比原先图片资源的单边宽小（&lt; 30px），看效果如何：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-slice: 10 30;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/border-image/border-image4.png" class=""><p>能看到上下的边按照图片资源的宽度进行裁剪，宽度为 10px，而左右的边和原先单边宽度一致，所以就出现上图的样子。</p><h2 id="fill-填充"><a href="#fill-填充" class="headerlink" title="fill 填充"></a>fill 填充</h2><blockquote><p>9 是在 <strong>border-image</strong> 值中出现 fill 时填充到边框内部的元素上。</p></blockquote><p>下面来说下 fill 值：</p><p>其实很简单，只要在 <strong>border-image-slice</strong> 属性值上的任意位置出现 <strong>fill</strong> 字段即可，那么对于当前元素背景图的内容将使用 <strong>border-image-source</strong> 的资源。</p><p>我先把资源图的中间加些内容：</p><img src="/legacy/2020/04/21/border-image/border-source2.png" class=""><p>当设置 fill 后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-slice</span>: 30 30 <span class="selector-tag">fill</span>;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/border-image/border-image5.png" class=""><p>好像很酷，马上就有个疑问：<strong>和 background 一起使用，会怎么样？</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-slice</span>: 30 30 <span class="selector-tag">fill</span>;</span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">seagreen</span>; <span class="comment">/* 没出来*/</span></span><br><span class="line">background-image: url('./border-source.png'); /* 没出来*/</span><br></pre></td></tr></table></figure><p>最后还是以 border 的资源为主。</p><h2 id="border-image-width-和-border-width"><a href="#border-image-width-和-border-width" class="headerlink" title="border-image-width 和 border-width"></a>border-image-width 和 border-width</h2><p>上面已经涉及过 border-width 的问题了，截取的素材宽度 &lt; 边框宽度，素材将在边框中重复。</p><p>但如果我们设置了 <strong>border-image-width</strong> 呢？</p><p>下面分别设置 <strong>border-image-width</strong>：按大于、小于 border-width 看效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-width</span>: 40<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/border-image/border-image6.png" class=""><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-image-width</span>: 8<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/21/border-image/border-image7.png" class=""><p>能看到已经按照 <strong>border-image-slice</strong> 切割后的素材按照 <strong>border-image-width</strong> 进行填。</p><p>如果 <strong>border-image-width</strong> 大于 <strong>border-width</strong> 则会“侵蚀”元素 padding or content 区域；小于则会将 slice 的素材缩小到 <strong>border-image-width</strong> 的宽度中。</p><h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><p>border-image-source，border-image-slice 之类的属性是可以用 border-image 一个属性来表示的，和 background 一样。</p><p>格式如下：</p><blockquote><p>&lt;’border-image-source’&gt; || &lt;’border-image-slice’&gt; [ / &lt;’border-image-width’&gt; | / &lt;’border-image-width’&gt;? / &lt;’border-image-outset’&gt; ]? || &lt;’border-image-repeat’&gt;</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">border-image-source: url('./border-source2.png');</span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 30 30 <span class="selector-tag">fill</span>;</span><br><span class="line"><span class="selector-tag">border-image-repeat</span>: <span class="selector-tag">stretch</span>;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image: url('./border-source2.png') 30 30 fill stretch;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垂直居中里的 vertical-align</title>
      <link href="/legacy/2020/04/20/vertical-align/"/>
      <url>/legacy/2020/04/20/vertical-align/</url>
      
        <content type="html"><![CDATA[<h1 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h1><blockquote><p>属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</p></blockquote><h1 id="认识基线"><a href="#认识基线" class="headerlink" title="认识基线"></a>认识基线</h1><p>因为，<strong>行盒子的基线是个变量</strong> ；同时，vertical-align 是 <strong>相对父元素的值</strong>。</p><p>所以行内的基线会随着内部的内容而不断调整，可以对比下面几个例子体会下：</p><p>分别定义三个 span 字体不同的行内元素（20px、30px、40px），看他们在整行内如何布局？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"bl"</span>&gt;</span>baseline<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item font20"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item font30"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item font40"</span>&gt;</span>40<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/20/vertical-align/baseline1.png" class=""><p>能看到他们每个“字”的底部都在 <strong>红线</strong> 上，这条线就是 <strong>基线 baseline</strong> 。</p><p>如果通过 vertical-align 调整某个元素的垂直对齐方式，那么他们将发生变化：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.font40</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/20/vertical-align/baseline2.png" class=""><p>我们只修改 40px 的元素的对齐方式为 middle，那么其基线将在它的垂直区域的中间，前面其他元素则会按这个新基线做对齐（注意红线）。</p><p>那如果所有元素都改为 middle 呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">middle</span> <span class="attr">class</span>=<span class="string">"bl"</span>&gt;</span>baseline<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">middle</span> <span class="attr">class</span>=<span class="string">"item font20"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">middle</span> <span class="attr">class</span>=<span class="string">"item font30"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">middle</span> <span class="attr">class</span>=<span class="string">"item font40"</span>&gt;</span>40<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[middle]</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/20/vertical-align/baseline3.png" class=""><p>能看到他们彼此间都按照新的基线在对齐，像一个横过来的金字塔。</p><h1 id="看些案例"><a href="#看些案例" class="headerlink" title="看些案例"></a>看些案例</h1><h2 id="image-和-inline-element-对齐问题"><a href="#image-和-inline-element-对齐问题" class="headerlink" title="image 和 inline element 对齐问题"></a>image 和 inline element 对齐问题</h2><p><strong>为何 image 底下会有白底？</strong></p><img src="/legacy/2020/04/20/vertical-align/baseline4.png" class=""><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border: 1px solid green;"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span> /&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是 inline 元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 span 标签的文字并不是按 border 的线和 image 图片进行对齐的，行内元素未对 vertical-align 做设置前，这个基线就是行内元素内文字底部的线（它和 image 是对齐的，图中红线）。</p><p>即使 span 没有设置 padding 等属性，但它上下还会留些空白，所以造成了 image 底部有白底。</p><p><strong>怎么使得 inline element 垂直居中</strong></p><p>将 div 内中的 image 和 span 分别设置 middle ，就可以让他们垂直居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">middle</span> <span class="attr">src</span>=<span class="string">"./img.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span> /&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">middle</span>&gt;</span>我是 inline 元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里提一点：image 标签是 inline element，不同的是置换行内元素 replace inline element（此元素有其特有的显示方式，css 渲染模型不考虑对其渲染）</p><img src="/legacy/2020/04/20/vertical-align/baseline5.png" class=""><h2 id="inline-block-对齐"><a href="#inline-block-对齐" class="headerlink" title="inline-block 对齐"></a>inline-block 对齐</h2><p>试问，两个一样的行内块级元素，如果一个里面有文字，一个没有，最后对齐方式如何？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c2c2c2</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>我里面有文字<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接上图：<br><img src="/legacy/2020/04/20/vertical-align/baseline6.png" class=""></p><p>是不是很奇怪？</p><p>其实内部如何有内容的话，其基线将是按照内部 inline 元素的基线对齐；而 inline-block 元素的基线则是元素底部，所以出现了图中对齐结果。</p><p>怎么更改？</p><p>只要将有内容的元素设置 top 对齐方式，则他们两个都被挪到了父元素下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">vertical-align</span>: <span class="selector-tag">top</span>;</span><br></pre></td></tr></table></figure><img src="/legacy/2020/04/20/vertical-align/baseline7.png" class=""><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://zcfy.cc/article/vertical-align-all-you-need-to-know" target="_blank" rel="noopener">Vertical-Align，你应该知道的一切</a></li><li><a href="https://juejin.im/post/5e64ee1df265da573e6734ed" target="_blank" rel="noopener">关于 vertical-align 你应该知道的一切</a></li><li><a href="https://www.w3.org/TR/CSS21/visudet.html#inline-replaced-width" target="_blank" rel="noopener">replace inline element</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 基础：64 位双精度浮点数</title>
      <link href="/legacy/2020/01/23/js-base-64-double/"/>
      <url>/legacy/2020/01/23/js-base-64-double/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都遇到过如下计算结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span>;</span><br></pre></td></tr></table></figure><p>为什么会出现如此结果？难道不为 0.3 吗？这涉及到 js 的精度问题。</p><p>首先 js 的数字类型采用基于 <strong><a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE 754</a></strong> 标准来实现的（也称为浮点数）。其选用的精度格式是：双精度格式（64 位的二进制数）</p><p>这篇就稍稍深入了解下双精度浮点数，以及有关于数 <strong>Number</strong> 的问题。</p><h1 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h1><blockquote><p>IEEE 二进制浮点数算术标准（IEEE 754），是最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用。</p></blockquote><blockquote><p>这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number），一些特殊数值（（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。</p></blockquote><blockquote><p>规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）</p></blockquote><p>当然我们只讨论 js 中的 <strong>64 位的双精度</strong> 方式。</p><h1 id="64-位的双精度"><a href="#64-位的双精度" class="headerlink" title="64 位的双精度"></a>64 位的双精度</h1><p>下图基本解释清楚 64 位数的组成部分：</p><img src="/legacy/2020/01/23/js-base-64-double/double-number.png" class="" title="64位的双精度（维基百科）"><ul><li>sign bit（S 符号）：符号位，表示正负号（0 为负数，1 为正数）</li><li>exponent（E 指数）：表示次方数，在（二进制的）科学计数法中定义 2 的多少次幂</li><li>mantissa（M 尾数）：表示精确度（小数部分，规范中会省略个位数上的 1 ）</li></ul><p>那么一个双精度值的表达式如下：</p><img src="/legacy/2020/01/23/js-base-64-double/double-format.png" class="" title="64位的双精度（维基百科）"><p>我们下面来具体解释一下。</p><h2 id="符号位-sign"><a href="#符号位-sign" class="headerlink" title="符号位 sign"></a>符号位 sign</h2><p>符号位很容易理解，表示整个数的正负值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">-1</span>, <span class="number">1</span>); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure><p>所以用此位来示意数的正负性。</p><h2 id="尾数位-mantissa"><a href="#尾数位-mantissa" class="headerlink" title="尾数位 mantissa"></a>尾数位 mantissa</h2><p>尾数也被称为规约形式的浮点数，因为在科学计数法的显示下，分数（fraction 也是 mantissa 那个部分之一）部分最高有效为是 1 （个位数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000.001(2)</span><br><span class="line">2^3 * 1.000001(科学计数法表示)</span><br></pre></td></tr></table></figure><p>最终 mantissa 会以 000001 来示意，会被规范成 <strong>1.M 格式</strong> ，其中 1 会被隐藏掉，所以最大是表达 53 位的数（如上图，实际 mantissa 只有 52 位）。</p><h2 id="指数位-exponent"><a href="#指数位-exponent" class="headerlink" title="指数位 exponent"></a>指数位 exponent</h2><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>我知道各位都是受过义务教育的，不过我真的忘记了，简单回顾下把：</p><blockquote><p>科学记数法是一种记数的方法。把一个数表示成 a 与 10 的 n 次幂相乘的形式（1≤|a|&lt;10，n 为整数），这种记数法叫做科学记数法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 科学记数法</span></span><br><span class="line"><span class="number">100</span>; <span class="comment">// 1*10^2</span></span><br><span class="line"><span class="number">0.001</span>; <span class="comment">// 1*10^-3</span></span><br></pre></td></tr></table></figure><p>那和科学计数法有什么关系，应该注意到 <strong>指数位是 2 的 n 次幂</strong> （为何不是 10 ，因为是二进制）。</p><p>如果我们要表达 100(2)，则结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>(<span class="number">2</span>); <span class="comment">// 1*2^2</span></span><br></pre></td></tr></table></figure><h3 id="指数偏移值（exponent-bias）"><a href="#指数偏移值（exponent-bias）" class="headerlink" title="指数偏移值（exponent bias）"></a>指数偏移值（exponent bias）</h3><p>我们了解科学计数法是可以表示大于 1 ，或者小于 1 的数（小数），即：通过正负指数的值来标识显示。</p><p>由于指数位的 11 位不包括符号位，那么为了达到这样正负的效果，就引入了 <strong>指数的偏移值</strong>。</p><p>为什么要引入这个概念？我想了很久，以下这个例子或许会给你启发：</p><blockquote><p>指数如果是 1023 和 1024，到底哪个值谁大？</p></blockquote><p>首先 11 位的指数位对应的二进制最大和最小结果值为：00000000000(0) ，11111111111(2047，2^(12-1)-1)，即指数的取值范围为：<strong>[0,2047]</strong></p><p>并且我们知道指数具有 <strong>正负值</strong> （来控制小数点左右移位），那么我们按照二进制中负数的规则（取反，补位），那么指数值为 [0,1023] 区间内为正数，[1024,2047] 内为负数（二进制中负数最高位为 1 ）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 补充下：为何负数是从 1024 开始？</span></span><br><span class="line">011 11111111 # 1023</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果该二进制再继续增大，就进入了负数区域（最高位为 1）</span></span><br><span class="line">100 00000000 # 1024</span><br></pre></td></tr></table></figure><p>另外，根据 IEEE 规范， 0 和 2047 两个最值需要做特殊用途，所以这里移除，所以整个规范的指数取值范围是： <strong>[1,2046]</strong></p><p>回到这个问题，1023 和 1024 到底谁大，按照上面区间的划分，明显是 1023 &gt; 1024 （正数大于负数，但机器不那么想）。</p><p>崩溃！就我个人理解起来就很困难，更不谈实际运算了（当你看到一个大于 1023 的值，还需要引入符号位，补码之类的计算方式）。</p><p>所以引入偏移值 bias（bias = 1023），使得整个运算简单，好理解。</p><p>那么 [-1022+bias,1023+bias] 等同于 [1,2046]，这样抛去了符号位的影响， 最终：1023 就变成了 0 ，1024 变成了 1 ，明显 1 的指数值更大。</p><p>至于为何是 1023 ，我给的建议是 2046/2 （虽然这样理解是不对的），另外 32 位精度浮点数的偏移量是 127 。</p><p><a href="https://segmentfault.com/q/1010000016401244/a-1020000016446375" target="_blank" rel="noopener">参考</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.5</span> (<span class="number">10</span>) </span><br><span class="line"><span class="number">100.1</span> (<span class="number">2</span>)</span><br><span class="line"><span class="number">1.001</span> * <span class="number">2</span>^<span class="number">2</span></span><br><span class="line">符号位：<span class="number">0</span> (正数)</span><br><span class="line">指数：<span class="number">1025</span> (<span class="number">2</span>+<span class="number">1023</span>)</span><br><span class="line">尾数：<span class="number">001</span> (注意，<span class="number">1</span> 省略)</span><br></pre></td></tr></table></figure><h3 id="标准（规格）和非标准（规格）"><a href="#标准（规格）和非标准（规格）" class="headerlink" title="标准（规格）和非标准（规格）"></a>标准（规格）和非标准（规格）</h3><p>整个指数位的值分为三种情况：</p><table><thead><tr><th>名称</th><th>指数 E</th><th>加偏移值（exponent bias）</th><th>尾数 M</th><th>表示</th></tr></thead><tbody><tr><td>规格化</td><td>[1,2046]</td><td>[-1022,1023]</td><td>1.M（含有隐藏位 1）</td><td></td></tr><tr><td>非规格化</td><td>0</td><td>-1023</td><td>0</td><td>±0 非常接近 0 的数</td></tr><tr><td>非规格化</td><td>2047</td><td>1023</td><td>0</td><td>±∞</td></tr><tr><td>非规格化</td><td>2047</td><td>1023</td><td>非 0</td><td>NaN</td></tr></tbody></table><h1 id="解惑些问题"><a href="#解惑些问题" class="headerlink" title="解惑些问题"></a>解惑些问题</h1><h2 id="整数范围"><a href="#整数范围" class="headerlink" title="整数范围"></a>整数范围</h2><p>当尾数为标准模式时：1.M ，尾数位供 52 位，加上隐藏位 1 ，整个精度会是 53 位。</p><p>那么整数的取值范围是 [-2^53-1,2^53-1]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> == <span class="built_in">Number</span>.MAX_SAFE_INTEGER; <span class="comment">//9007199254740992</span></span><br><span class="line"> - (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>)) == <span class="built_in">Number</span>.MIN_SAFE_INTEGER;<span class="comment">//-9007199254740992</span></span><br></pre></td></tr></table></figure><h2 id="最小精度"><a href="#最小精度" class="headerlink" title="最小精度"></a>最小精度</h2><p>在尾数的 52 位中，使得有一个最小的位定义（1.00000~ 中间 51 个 0~00001），即 2^-52 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>) == <span class="built_in">Number</span>.EPSILON; <span class="comment">//2.220446049250313e-16</span></span><br></pre></td></tr></table></figure><h2 id="0-1-0-2-等于什么？"><a href="#0-1-0-2-等于什么？" class="headerlink" title="0.1+0.2 等于什么？"></a>0.1+0.2 等于什么？</h2><p>按照最小精度，即打满 52 位，那么像 0.1 和 0.2 最终无限循环后的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.0001100110011001100110011001100110011001100110011001101 + 0.0011001100110011001100110011001100110011001100110011010 &#x3D; 0.0100110011001100110011001100110011001100110011001100111;</span><br><span class="line"></span><br><span class="line">等于：0.30000000000000004.toString(2)</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>对于这个 IEEE 754 规范，我理解的还不是很透彻，不过对于 js 精度上的问题也算是有个初步的解答。</p><p>如果有不对之处望各位留言指正。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 中 BFC 规范</title>
      <link href="/legacy/2019/12/23/css-bfc/"/>
      <url>/legacy/2019/12/23/css-bfc/</url>
      
        <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>最近在准备面试，真巧一次面试中也涉及到 <strong>BFC</strong> 概念，当然我回答：不知道。但其实我们平时的开发中，却时刻在利用 <strong>BFC</strong> 特性在处理样式问题。</p><p><strong>BFC</strong> 又称 Block Formatting Context （块状格式化上下文）</p><p>MDN 解释：</p><blockquote><p>A block formatting context is a part of a visual CSS rendering of a web page. It’s the region in which the layout of block boxes occurs and in which floats interact with other elements.</p></blockquote><p>好吧，我看了这段解释也是似懂非懂。</p><p>大概意思是：BFC 是 css 渲染页面环节中的一部分。在块级盒子布局的范围中出现，并且它也影响着浮动元素和其他元素。</p><h1 id="哪些方式会创建-BFC-？"><a href="#哪些方式会创建-BFC-？" class="headerlink" title="哪些方式会创建 BFC ？"></a>哪些方式会创建 BFC ？</h1><p>通过以下方式，能创建一个 BFC 规范的布局（根据我熟悉的程度简单划分几类，如下）：</p><h2 id="平时常用"><a href="#平时常用" class="headerlink" title="平时常用"></a>平时常用</h2><ul><li>根元素是 html</li><li>设置 float 的元素（脱离文档流）</li><li>position: absolute | fixed（脱离文档流）</li><li>block 元素设置 overflow （非 visible，内容不被加工处理，直接显示）</li><li>display: inline-block</li><li>display: flex | inline-flex</li><li>display: grid | inline-grid</li></ul><h2 id="不常用（table-系）"><a href="#不常用（table-系）" class="headerlink" title="不常用（table 系）"></a>不常用（table 系）</h2><ul><li>display: table-cell（table 单元格 cell 默认为此样式）</li><li>display: table-caption（table caption 默认为此样式）</li><li>display: table, table-row, table-row-group, table-header-group, table-footer-group</li></ul><h2 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h2><ul><li>display: flow-root</li><li>设置 contain: layout, content, paint 的元素</li><li>column-count or column-width 不为 auto 的元素（包括 column-count: 1）</li><li>column-span: all</li></ul><h1 id="实际应用举例（摘自-MDN）"><a href="#实际应用举例（摘自-MDN）" class="headerlink" title="实际应用举例（摘自 MDN）"></a>实际应用举例（摘自 MDN）</h1><p>通过几个例子，感性的理解下 <strong>BFC</strong> 在实际场景中的作用：</p><h2 id="margin-塌陷"><a href="#margin-塌陷" class="headerlink" title="margin 塌陷"></a>margin 塌陷</h2><p>首先我们知道当在相邻的块级元素的 <strong>margin</strong> 会发生合并现象（称为：<strong>外边距折叠</strong>）</p><p>通常会发生在：相邻元素，父子元素 <strong>margin</strong> 接触处，或者一个空的块级元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.blue</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.red-inner</span> &#123;</span></span><br><span class="line">    height: 50px;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red-inner"</span> <span class="attr">style</span>=<span class="string">"background: red;"</span>&gt;</span>red inner（含高，margin）<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意到两个 div 之间的 margin 边距合并成了一个。</p><img src="/legacy/2019/12/23/css-bfc/margin-lost.png" class=""><p>怎么解决？</p><p>为目标元素外新建一个父元素，并设置 <strong>overflow: hidden</strong> 属性。</p><p>我们知道 <strong>hidden</strong> 会裁剪内容（而不是 <strong>visiable</strong> ），则父元素中的元素“们”的 <strong>margin</strong> 将“尽情释放”在父元素中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.red-outer</span> &#123;</span></span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red-outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red-inner"</span>&gt;</span>red inner（含高，margin）<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/12/23/css-bfc/margin-lost-bfc.png" class=""><p>能看到 margin 的上下边距被控制在新的父元素中了。</p><p>当然我想说：你也可以将当前元素设置为 <strong>inline-block</strong> 触发 <strong>BFC</strong> ，只要符合规范都是可行的。</p><h2 id="浮动元素丢失高度"><a href="#浮动元素丢失高度" class="headerlink" title="浮动元素丢失高度"></a>浮动元素丢失高度</h2><p>我们知道设置浮动 <strong>float</strong> 属性的元素将脱离文档流，那么包裹浮动的父级元素的高度为其中非浮动的元素，甚至直接高度“塌陷”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    background-color: rgb(224, 206, 247);</span><br><span class="line">    border: 5px solid rebeccapurple;</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>; <span class="comment">/* bfc */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* 也可以设置 display: flow-root; */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-class">.float</span> &#123;</span></span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: white;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    padding: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span>I am a floated box!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>I am content inside the container.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/12/23/css-bfc/float-escape.png" class=""><p>解决方式也很简单，参考上面的 <strong>margin</strong> 边距合并问题：我们也可以设置 <strong>overflow</strong> 来解决。</p><p>也可以设置 <strong>display: flow-root;</strong> 。</p><img src="/legacy/2019/12/23/css-bfc/float-escape-bfc.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文本章参考 <strong>MDN</strong> ，简单讲了下 css 中 <strong>BFC</strong> 的概念。</p><p>并且通过几个例子示范了如何处理元素间的常见问题（ margin 边距合并、浮动高度丢失）。</p><p>当知道了 <strong>BFC</strong> 对元素之间的影响后，就能在页面布局中更好的隔离，或者处理元素间的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从简到难，示例几则 vue 中的正则表达式</title>
      <link href="/legacy/2019/12/17/regex-practice/"/>
      <url>/legacy/2019/12/17/regex-practice/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正则一直是令我头大的问题，简单入门的那些还好，但是一旦复杂起来真是连百度都不知道他的用意，只能一小段一小段的试。</p><p>这篇会列举几个 vue 源码中的几个正则表达式，为什么选取这些呢？</p><p>因为我近段时间在深入学习 vue 的代码，同时觉得这些表达式也是非常具有实战性的，相信对我们以后实现业务逻辑会有很大的启发和帮助。</p><h1 id="几个基础概念"><a href="#几个基础概念" class="headerlink" title="几个基础概念"></a>几个基础概念</h1><p>如果你对正则表达式如下概念不熟悉，有必要的话可以再回顾下。（当然只针对下面例子涉及的概念）</p><h2 id="部分正则规则"><a href="#部分正则规则" class="headerlink" title="部分正则规则"></a>部分正则规则</h2><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>转义字符。匹配数据不想被正则规则解析</td></tr><tr><td>^</td><td>匹配输入的开始。注意，和在 [] 中定义的不同</td></tr><tr><td>\$</td><td>匹配输入的结束</td></tr><tr><td>?</td><td>0 or 1 <strong>次，等价</strong> {0,1}</td></tr><tr><td>.</td><td>换行 \n 之外的单个字符</td></tr><tr><td>x &#124; y</td><td>‘x’或者‘y’</td></tr></tbody></table><h3 id="多次匹配"><a href="#多次匹配" class="headerlink" title="多次匹配"></a>多次匹配</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>0 or 多次 <strong>等价</strong> {0,}</td></tr><tr><td>+</td><td>1 or 多次，至少出现一次。<strong>等价</strong> {1,}</td></tr><tr><td>{n}</td><td>匹配重复出现 n 次</td></tr><tr><td>{n,m}</td><td>n&lt;= 匹配出现次数 &lt;=m</td></tr></tbody></table><h3 id="任意字符"><a href="#任意字符" class="headerlink" title="任意字符"></a>任意字符</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>[xyz]</td><td>匹配方括号中的任意字符</td></tr><tr><td>[^xyz]</td><td>匹配任何没有包含在方括号中的字符（反向字符集）</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个词的边界（前后没有其他字符）</td></tr><tr><td>\s</td><td>匹配任何空白字符（空格、制表符、换页符等），<strong>等价</strong> [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。<strong>等价</strong> [^ \f\n\r\t\v]。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。<strong>等价</strong> “[A-Za-z0-9_]”。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。<strong>等价</strong> “[^a-za-z0-9_]”。</td></tr></tbody></table><h3 id="特殊规则"><a href="#特殊规则" class="headerlink" title="特殊规则"></a>特殊规则</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>(x)</td><td>捕获括号（<strong>匹配 ‘x’ 并且记住匹配项</strong>）</td></tr><tr><td>(?:x)</td><td>非捕获括号（<strong>匹配 ‘x’ 但是不记住匹配项</strong>）</td></tr><tr><td>x(?=y)</td><td>正向肯定查找</td></tr><tr><td>x(?!y)</td><td>正向否定查找</td></tr></tbody></table><h2 id="test-exec-match-区别"><a href="#test-exec-match-区别" class="headerlink" title="test exec match 区别"></a>test exec match 区别</h2><ul><li>test 不需要知道匹配内容，只需判断正则是否命中的场景</li><li>exec 进行搜索匹配，返回匹配结果</li><li>match 是 String 对象方法，和 exec 类似</li></ul><p>看几个小 demo ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">let</span> numRE = <span class="regexp">/[0-9]+/</span>;</span><br><span class="line"><span class="keyword">let</span> data2 = <span class="string">"abc123efg456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numRE.test(data2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(numRE.exec(data2)); <span class="comment">// [ '123', index: 3, input: 'abc123efg456' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(data2.match(numRE)); <span class="comment">// [ '123', index: 3, input: 'abc123efg456' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比 exec ， match</span></span><br><span class="line"><span class="keyword">let</span> numGobalRE = <span class="regexp">/[0-9]+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numGobalRE.test(data2)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(numGobalRE.exec(data2)); <span class="comment">// [ '456', index: 9, input: 'abc123efg456' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(data2.match(numGobalRE)); <span class="comment">// [ '123', '456' ]</span></span><br></pre></td></tr></table></figure><p>在全局模式下， <strong>match</strong> 不会有额外 <strong>索引 index</strong> 、 <strong>被匹配数据 input</strong> 的输出。并且只有所有匹配的数据。</p><h2 id="非括号捕获"><a href="#非括号捕获" class="headerlink" title="非括号捕获"></a>非括号捕获</h2><p>匹配 (?:x) 中 x 表达式，但不记住选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非括号捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> nonCapturingRE = <span class="regexp">/(?:abc)&#123;1&#125;/</span>;</span><br><span class="line"><span class="comment">// [ 'abc', index: 0, input: 'abc' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"abcefg"</span>.match(nonCapturingRE));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 括号捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> capturingRE = <span class="regexp">/(abc)&#123;1&#125;/</span>;</span><br><span class="line"><span class="comment">// [ 'abc', 'abc', index: 0, input: 'abcefg' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"abcefg"</span>.match(capturingRE));</span><br></pre></td></tr></table></figure><p>似乎从结果上看，这两者没什么区别。我通过调用字符串 replace 方法后，你再看下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="string">"abcefg"</span>.replace(nonCapturingRE, <span class="string">"hello $1 "</span>); <span class="comment">// hello $1 efg</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="string">"abcefg"</span>.replace(capturingRE, <span class="string">"hello $1 "</span>); <span class="comment">// hello abc efg</span></span><br></pre></td></tr></table></figure><p>你应该能看到其中的区别了吧。</p><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p><strong>replace</strong> 作为 <strong>String</strong> 对象中的方法，相比都经常使用。</p><p>但如果将 <strong>replace</strong> 第一个参数传入正则表达式，第二个参数而一个函数 <strong>Fn</strong> ，那是否知道 <strong>Fn</strong> 的参数列表有什么特殊作用吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.replace(Regexp, <span class="built_in">Function</span>);</span><br></pre></td></tr></table></figure><p><strong>Function</strong> 的参数说明：</p><ul><li>match 匹配内容</li><li>$1,$2 … 括号捕获内容</li><li>offset 匹配开始位置</li><li>string 源字符串</li></ul><p>结合 <strong>括号捕获</strong> 和 <strong>非括号捕获</strong> 应该很容易明白：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"John Smith"</span>;</span><br><span class="line"><span class="keyword">var</span> newstr = str.replace(re, <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// ["John Smith", "John", "Smith", 0, "John Smith"]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/(?:\w+)\s(\w+)/</span>; <span class="comment">// 将其中一个调整为 非括号捕获</span></span><br><span class="line"><span class="built_in">console</span>.log(args); <span class="comment">// ["John Smith", "Smith", 0, "John Smith"]</span></span><br></pre></td></tr></table></figure><h1 id="html-注释判断"><a href="#html-注释判断" class="headerlink" title="html 注释判断"></a>html 注释判断</h1><p>vue 会解析我们 html 模板，html 中的注释肯定没有任何意义，所以有必要将它过滤掉。</p><p>那怎么匹配出现的注释内容呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是个注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是个低端浏览器<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接上正则逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comment = <span class="regexp">/^&lt;!\--/</span>;</span><br><span class="line"><span class="keyword">const</span> conditionalComment = <span class="regexp">/^&lt;!\[/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配注释</span></span><br><span class="line"><span class="keyword">if</span> (comment.test(html)) &#123;</span><br><span class="line">  <span class="keyword">const</span> commentEnd = html.indexOf(<span class="string">"--&gt;"</span>); <span class="comment">// 记录注释右关闭起始位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (commentEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    advance(commentEnd + <span class="number">3</span>); <span class="comment">// 挪3位长度，即解析完整个注释</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配浏览器注释</span></span><br><span class="line"><span class="keyword">if</span> (conditionalComment.test(html)) &#123;</span><br><span class="line">  <span class="keyword">const</span> conditionalEnd = html.indexOf(<span class="string">"]&gt;"</span>); <span class="comment">// 记录注释右关闭起始位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (conditionalEnd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    advance(conditionalEnd + <span class="number">2</span>); <span class="comment">// 挪2位长度，即解析完整个注释</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面摘自 <strong>vue</strong> 中 <strong>parseHtml</strong> 方法，相对简单。</p><p>利用 <strong>test</strong> 判断当前 <strong>html</strong> 内容是否符合预期，配合“固定”注释的左右标识，记录当前注释结束为止，为下次新的 <strong>html</strong> 解析做准备。</p><h1 id="驼峰表达式转换"><a href="#驼峰表达式转换" class="headerlink" title="驼峰表达式转换"></a>驼峰表达式转换</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line"><span class="keyword">const</span> camelize = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : <span class="string">""</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可能会用 <strong>abc-def</strong> 的方式定义对象的属性名，或者 <strong>vue</strong> 中非规范的定义， <strong>vue</strong> 框架就会有统一的处理，将 <strong>abc-def</strong> 统一转化为 <strong>abcDef</strong> <strong>驼峰写法</strong>。</p><h1 id="解析-html-属性-KV"><a href="#解析-html-属性-KV" class="headerlink" title="解析 html 属性 KV"></a>解析 html 属性 KV</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s"'&lt;&gt;\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=&lt;&gt;`]+)))?/</span>;</span><br></pre></td></tr></table></figure><p>我们先看这段正则的匹配输出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'id="app" class="foo"&gt;hello&lt;/div&gt;'</span>.match(attribute);</span><br><span class="line"><span class="comment">// ["id="app"", "id", "=", "app", undefined, undefined, index: 0, input: "id="app" class="red" disabled&gt;&lt;/div&gt;", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="string">"id='app' class='foo'&gt;hello&lt;/div&gt;"</span>.match(attribute);</span><br><span class="line"><span class="comment">// ["id='app'", "id", "=", undefined, "app", undefined, index: 0, input: "id='app' class='red' disabled&gt;&lt;/div&gt;", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="string">"  disabled&gt;hello&lt;/div&gt;"</span>.match(attribute);</span><br><span class="line"><span class="comment">// ["  disabled", "disabled", undefined, undefined, undefined, undefined, index: 0, input: "disabled&gt;hello&lt;/div&gt;", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>按照顺序，开始分析：</p><p>我先把这个正则简化下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;A(B)(?:C(?(?(D)|(E)|(F))))&#x2F;</span><br></pre></td></tr></table></figure><p>第一部分 <strong>A</strong> ，匹配任何空白字符，并且空白符可出现 or 未出现过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\s*</span><br></pre></td></tr></table></figure><p>随后跟着一个 <strong>括号捕获</strong> 表达式 <strong>B</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([^\s&quot;&#39;&lt;&gt;\&#x2F;&#x3D;]+)</span><br></pre></td></tr></table></figure><p>用 <strong>[]</strong> 中括号包裹，并且里面匹配的内容至少要出现一次。</p><p>注意内部内容的 <strong>^</strong> 并不是说明以其开头，而是 <strong>非 \s”‘&lt;&gt;/=</strong> 这些字符，从而 <strong>取出属性的 key</strong>。</p><p>后面将是个复杂的 <strong>非括号捕获</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\s*(&#x3D;)\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)))?</span><br></pre></td></tr></table></figure><p>我们先分析其中三个括号捕获 <strong>DEF</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+)</span><br></pre></td></tr></table></figure><p>仔细看不难发现，<strong>D</strong> 和 <strong>E</strong> 是针对不同的引号（双引号、单引号）包裹内容来匹配的，并且内部不能出现外部的引号。</p><p><strong>F</strong> 和之前的 <strong>B</strong> 类似，唯独去除了斜杠限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\s&quot;&#39;&#x3D;&lt;&gt;&#96;]+))</span><br></pre></td></tr></table></figure><p>最后针对 <strong>DEF</strong> 的结果，来做非括号匹配。就能 <strong>取出属性的 value</strong></p><p>既然知道了属性的 key、value 取值方式，那么 <strong>C</strong> 的作用也显而易见了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\s*(&#x3D;)\s*(?(D)|(E)|(F)))</span><br></pre></td></tr></table></figure><p>用等号 = 作为分隔符，取出整个 <strong>key=value</strong> 的值。</p><p>那么再回头看之前正则对应的输出结果就容易些了。</p><h1 id="正则的封装"><a href="#正则的封装" class="headerlink" title="正则的封装"></a>正则的封装</h1><p>讲个轻松些的，如下是个判断 html 起始标签的正则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;^&lt;((?:[a-zA-Z_][\-\.0-9_a-zA-Za-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*\:)?[a-zA-Z_][\-\.0-9_a-zA-Za-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*)&#x2F;</span><br></pre></td></tr></table></figure><p>能发现整个正则表达式很长，虽然逻辑不复杂，但看起来真的很揪心。</p><p>我们看看 vue 是怎么做的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unicodeRegExp = <span class="regexp">/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z<span class="subst">$&#123;unicodeRegExp.source&#125;</span>]*`</span>;</span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>使用正则的 <strong>source</strong> 属性，我们能拿到正则表达式的字符串，同时需要注意所有交付给 <strong>new RegExp</strong> 的参数，对其中的斜杠需要作次转义。</p><p>这样通过 es6 的 <strong><code></code></strong> 表达式和 <strong>RegExp</strong> 对象，将原先繁琐的正则表达式优化成多个变量定义，现在我们能按其意思快速的理解正则了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面这些例子只是个引子，我希望同我一样惧怕正则表达式的同学能正视它，因为表面看上去它很复杂，但其实耐心些，像主流框架些的正则都是能挖掘很多内含的东西。</p><p>希望这篇文章能让你的正则能力提升一个台阶。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> regexp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-数据动态响应：监听者 Watcher</title>
      <link href="/legacy/2019/12/15/vue-learn-reactive-watcher/"/>
      <url>/legacy/2019/12/15/vue-learn-reactive-watcher/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过 <strong>Observer</strong> 和 <strong>Dep</strong> 对象的学习，我们大致已经对 vue 内部是如何定义数据动态响应方式的， <strong>Dep</strong> 内部和 <strong>Watcher</strong> 对象互相交织着，形成动态响应机制。</p><p>现在就开始看 <strong>Watcher</strong> 对象，看其中是怎么个设计方式。</p><h1 id="Watcher-对象"><a href="#Watcher-对象" class="headerlink" title="Watcher 对象"></a>Watcher 对象</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>既然 <strong>Watcher</strong> 是个对象，那肯定有 <strong>new</strong> 的地方，但似乎我们现在都没有看到这样 <strong>new Watcher()</strong> 的操作。</p><p>其实 <strong>vue</strong> 完成所有的初始化动作后，就会定义 <strong>mount</strong> 函数，内部完成渲染相关的工作，这里不做展开，到渲染函数篇在细看。</p><p>如下就是一个 Watcher 对象的创建操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">"beforeMount"</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      before() &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">          callHook(vm, <span class="string">"beforeUpdate"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 <strong>Vue.prototype.\$watch</strong> 内部也创建该对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们也知道 <strong>computed</strong> 和 <strong>watch</strong> 选项属性使用上也大致相同，所以 <strong>computed</strong> 内部也是用 <strong>Watcher</strong> 创建的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = (vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码主体"><a href="#代码主体" class="headerlink" title="代码主体"></a>代码主体</h2><p>大致知道了 <strong>Watcher</strong> 对象的创建，我们来看其代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\observer\watcher.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  addDep(dep: Dep) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  cleanupDeps() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  evaluate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  teardown() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h2><p>如果我们以 <strong>\$mount</strong> 中的 <strong>Watcher</strong> 作为切入点，那么 <strong>Watcher</strong> 对象的创建后，其构造函数收到的值将是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// (this,function,function,&#123;before:function&#125;,true)</span></span><br><span class="line">  <span class="keyword">constructor</span>(vm, expOrFn, cb, options, isRenderWatcher) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化基础属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line">  <span class="keyword">this</span>.deep = !!options.deep; <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">this</span>.user = !!options.user; <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">this</span>.lazy = !!options.lazy; <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">this</span>.sync = !!options.sync; <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">this</span>.before = options.before; <span class="comment">// false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.cb = cb;</span><br><span class="line"><span class="keyword">this</span>.id = ++uid; <span class="comment">// uid for batching</span></span><br><span class="line"><span class="keyword">this</span>.active = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy; <span class="comment">// for lazy watchers // false</span></span><br></pre></td></tr></table></figure><p>除了 <strong>this.active</strong> 为 <strong>true</strong> ，其他用于判断的属性都为 <strong>false</strong> 。（再次强调下，这里是以 <strong>\$mount</strong> 中的 <strong>new Watcher</strong> 的参数为切入点）</p><p>初始化依赖对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.deps = [];</span><br><span class="line"><span class="keyword">this</span>.newDeps = [];</span><br><span class="line"><span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>看这些属性的名字，基本能猜出：这些属性将是 <strong>Watcher</strong> 和 <strong>Dep</strong> 进行交互通讯的桥梁。</p><p>解析 <strong>expOrFn</strong> ，得到 <strong>getter</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.getter = expOrFn;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后根据 <strong>this.lazy</strong> (false) ，运行 <strong>get</strong> 方法，得到 <strong>this.value</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get();</span><br></pre></td></tr></table></figure><p>下面我们从构造函数 <strong>get</strong> 方法开始，看数据响应机制是如何实现的。</p><h1 id="get-预取值"><a href="#get-预取值" class="headerlink" title="get 预取值"></a>get 预取值</h1><p><strong>get</strong> 方法代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h2><p>当 <strong>Watcher</strong> 对象初始化后，就会触发 <strong>get</strong> 方法，第一步就调用 <strong>pushTarget</strong> ，我们来看下内部原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\observer\dep.js</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> targetStack = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target);</span><br><span class="line">  Dep.target = target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vue</strong> 声明时，就定义好了 <strong>Dep.target</strong> 属性，当调用 <strong>Watcher</strong> 调用 后，将 <strong>Watcher</strong> 实例引用 <strong>this</strong> 赋值给 <strong>Dep.target</strong> ，同时也放入监听堆栈队列 <strong>targetStack</strong> 。</p><h2 id="执行-getter"><a href="#执行-getter" class="headerlink" title="执行 getter"></a>执行 getter</h2><p>定义完 <strong>Dep.target</strong> 后，马上执行 <strong>this.getter</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br></pre></td></tr></table></figure><p>而这个方法就是前面提到的 <strong>updateComponent</strong> ，我打了个 <strong>debugger</strong> 来说明这问题：</p><img src="/legacy/2019/12/15/vue-learn-reactive-watcher/getter.png" class=""><p><strong>call</strong> 执行完后，并不会跳到最后的出栈方法 <strong>popTarget</strong> ，而是转到了我们前面 <strong>definedReactive</strong> 中定义的 <strong>getter</strong> 方法：</p><img src="/legacy/2019/12/15/vue-learn-reactive-watcher/get.png" class=""><p>因为我们的模板可能这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就涉及到观察对象上属性的<strong>取值</strong>操作，所以触发了 <strong>getter</strong> 。</p><p>中间触发的依赖关系待会儿再说。</p><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>获取到 value 后，则执行 <strong>popTarget</strong> 出栈：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop();</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刷新队列"><a href="#刷新队列" class="headerlink" title="刷新队列"></a>刷新队列</h2><p>调用 <strong>cleanupDeps</strong> 方法，来更新 dep 相关的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 处理 id依赖集合</span></span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    <span class="comment">// 2 处理 依赖队列</span></span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>this.deps</strong> 是个数组，它是哪里有数据塞入的？就是在 <strong>cleanupDeps</strong> 方法中。</p><p>上面 <strong>1</strong> 和 <strong>2</strong> 分别是对 <strong>id 依赖集合</strong> 和 <strong>依赖队列</strong> 做置换顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds; <span class="comment">// 历史 id依赖集合</span></span><br><span class="line"><span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds; <span class="comment">// depIds 得到：由 addDep 方法添加的 id依赖集合</span></span><br><span class="line"><span class="keyword">this</span>.newDepIds = tmp;</span><br></pre></td></tr></table></figure><p>这样 <strong>depIds</strong> 得到最新的 <strong>id 依赖集合</strong> ， <strong>newDepIds</strong> 最后被清空。</p><p>下一步对 <strong>deps</strong> 也是一样的处理，将最新的 <strong>newDeps</strong> 赋值给 <strong>deps</strong> ，然后清空 <strong>newDeps</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp = <span class="keyword">this</span>.deps;</span><br><span class="line"><span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps;</span><br><span class="line"><span class="keyword">this</span>.newDeps = tmp;</span><br><span class="line"><span class="keyword">this</span>.newDeps.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="依赖-Dep-和监听-Watcher-的关系"><a href="#依赖-Dep-和监听-Watcher-的关系" class="headerlink" title="依赖 Dep 和监听 Watcher 的关系"></a>依赖 Dep 和监听 Watcher 的关系</h1><p>我认为这是 <strong>真正的数据动态响应机制</strong>。</p><p>前面提到的的 <strong>Observer</strong> 只是对我们的对象数据进行观察； <strong>definedReative</strong> 只是提供了响应“动力”，或者是触发点。</p><p>而当数据真正响应后，其内部通过有 <strong>Dep</strong> 对象提供的 <strong>depend、notify</strong> 方法和 <strong>Watcher</strong> 之间的交互才是真正的机制。</p><h2 id="添加依赖-addDep"><a href="#添加依赖-addDep" class="headerlink" title="添加依赖 addDep"></a>添加依赖 addDep</h2><p>我们知道当被观察对象的属性被调用了，则触发了 <strong>definedReative</strong> 中的 <strong>getter</strong> 方法。</p><p>内部调用了 <strong>dep.depend()</strong> 方法，最终执行到了 <strong>Watcher</strong> 的 <strong>addDep</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defineReactive getter</span></span><br><span class="line">dep.depend();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep</span></span><br><span class="line">depend () &#123;</span><br><span class="line">Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line"><span class="keyword">const</span> id = dep.id</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line"><span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line"><span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来细看中间是什么逻辑：</p><p>程序开始执行时，<strong>this.newDeps = []</strong> 和 <strong>this.newDeps，this.depIds</strong> 为空集合，然后调用 <strong>dep</strong> 实例的 <strong>addSub</strong> 方法 ，往 <strong>dep.subs</strong> 订阅队列添加 <strong>Watcher</strong> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dep</span></span><br><span class="line">addSub (sub: Watcher) &#123;</span><br><span class="line"><span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖通知-notify"><a href="#依赖通知-notify" class="headerlink" title="依赖通知 notify"></a>依赖通知 notify</h2><p>当我们更新数据时，就触发了 <strong>definedReative</strong> 中的 <strong>setter</strong> 方法，调用了 <strong>dep.notify()</strong> 。</p><p><strong>notify</strong> 内部调用了 <strong>Watcher</strong> 对象 <strong>update</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dep.notify()</span><br><span class="line"></span><br><span class="line">notify () &#123;</span><br><span class="line">subs[i].update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line"><span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line"><span class="keyword">this</span>.run()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>update</strong> 方法内部，根据同步属性 <strong>sync</strong> 判断是执行 <strong>run</strong> 还是 <strong>queueWatcher</strong> 。</p><p>当然目前不管那么复杂的条件，就先看 <strong>run</strong> 方法，因为 <strong>queueWatcher</strong> 最终还是要执行它的。</p><h2 id="依赖执行-run"><a href="#依赖执行-run" class="headerlink" title="依赖执行 run"></a>依赖执行 run</h2><p>这是 run 的主体代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>能看到内部又去执行了 <strong>预期值 get</strong> 方法。并且最后把新老 <strong>value</strong> 交给 <strong>cb</strong> 方法，这也就是我们在调用 <strong>watch api</strong> 时，有数据更新前后的值的原因。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于这三篇我们对 <strong>Observer</strong> 、 <strong>Dep</strong> 、 <strong>Watcher</strong> 这三个核心对象和数据动态响应机制起到的作用就有个大致的概念基础了。</p><p>其中为什么 <strong>vue</strong> 要那么设计、以及在 <strong>initState</strong> 方法中其他选项属性的定义解析我们后面继续学习。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-数据动态响应：依赖 Dep</title>
      <link href="/legacy/2019/12/15/vue-learn-reactive-dep/"/>
      <url>/legacy/2019/12/15/vue-learn-reactive-dep/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们已经在 <strong>Observer</strong> 类中看到了 <strong>Dep</strong> 的影子，并且在 <strong>getter/setter</strong> 中使用了 <strong>depend</strong> ， <strong>notify</strong> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key,val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">set</span>()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们到底在做什么？本篇来继续探究。</p><h1 id="Dep-依赖对象"><a href="#Dep-依赖对象" class="headerlink" title="Dep 依赖对象"></a>Dep 依赖对象</h1><p><strong>Dep</strong> 我个人认为它是 <strong>Depend</strong> 的缩写，即在此对象中实现 <strong>响应依赖关系</strong> 的。</p><p>这是 <strong>Dep</strong> 类的代码主体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\observer\dep.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub(sub: Watcher) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  removeSub(sub: Watcher) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此对象中的方法涉及 <strong>队列</strong> 的操作，既然有 <strong>Observer</strong> 观察者，其中肯定也会有订阅者 <strong>subscriber</strong> ，就像 <strong>rxjs</strong> 中的核心概念一样。而这个队列我称为 <strong>订阅队列</strong> ，即：里面存放着一堆 <strong>Watcher</strong> 监听对象。</p><p>事实上，你看到 <strong>vue</strong> 代码的 <strong>flow</strong> 类型说明也能很清楚的看出来。</p><h1 id="Dep-实例怎么被调用"><a href="#Dep-实例怎么被调用" class="headerlink" title="Dep 实例怎么被调用"></a>Dep 实例怎么被调用</h1><p>首先是 <strong>Observer</strong> 对象中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能看到该对象中初始化创建 <strong>Dep</strong> 后，就没有对 <strong>this.dep</strong> 拿出来做什么事情了，但事实不是这样。</p><p>将在 <strong>observe</strong> 方法中，将创建观察者对象 <strong>Observer</strong> ，并将这个实例称为 <strong>ob</strong> return 。那么所有拿到 <strong>observe</strong> 返回值的，既可以通过 <strong>ob.dep</strong> 调用依赖 Dep 对象</p><p>几乎所有用到 <strong>observe</strong> 方法的地方都没有使用它的返回值，但 <strong>defineReactive</strong> 中使用到了，注意 <strong>childOb</strong> 变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就代码定义而言，知道了这个 <strong>childOb</strong> 就是 <strong>Observer</strong> 实例，并且通过 <strong>childOb.dep</strong> 调用了 <strong>Dep</strong> 方法，就这样简单实现了对象引用的依赖关联。</p><h1 id="ob-和-dep-的关系"><a href="#ob-和-dep-的关系" class="headerlink" title="__ob__ 和 dep 的关系"></a>__ob__ 和 dep 的关系</h1><p>之前在 <strong>Observer</strong> 类中，通过 <strong>def</strong> 方法，增加了 <strong>__ob__</strong> 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>我们知道 <strong>__ob__</strong> 的 <strong>value</strong> 值就是当前 <strong>Observer</strong> 对象的引用 <strong>this</strong> ，这样定义有什么作用？</p><p>结合前面说的，我们知道 <strong>Observer</strong> 内含 <strong>Dep</strong> 对象实例 <strong>dep</strong> ，那么得到 <strong>__ob__</strong> 也能获取到这个实例 <strong>dep</strong> 属性。</p><p>这样如果遍历某对象的属性，其内含 <strong>__ob__</strong> 属性，我们就知道它是被观察化的，具备数据的动态响应特征。</p><p>下面列举几处 <strong>__ob__</strong> 调用 <strong>dep</strong> 的代码例子：</p><p>对观察对象中的属性值 <strong>value</strong> 进行判断，如果是 <strong>Array</strong> 则对该 <strong>value</strong> 进行依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span>(<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i];</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>methodsToPatch</strong> 是 <strong>vue</strong> 初始化时针对原生数组方法进行的拦截处理，里面也通过 <strong>__ob__</strong> 调用 <strong>dep</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然还有 <strong>Watch</strong> 对象中的 <strong>traverse</strong> 等其他地方用到 <strong>__ob__</strong> ，我们后面再看。</p><h1 id="depend-和-notify"><a href="#depend-和-notify" class="headerlink" title="depend 和 notify"></a>depend 和 notify</h1><h2 id="depend-创建依赖"><a href="#depend-创建依赖" class="headerlink" title="depend 创建依赖"></a>depend 创建依赖</h2><p>很多地方调用了 <strong>depend</strong> 方法，我们来看下它到底做了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dep.target</strong> 是个 <strong>Watcher</strong> 对象实例，如果他存在则会执行 <strong>addDep</strong> 。</p><p>在 <strong>Watcher</strong> 类中，我们找到了该方法，发现内部最终调用了 <strong>Dep</strong> 的 <strong>addSub</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\observer\watcher.js</span></span><br><span class="line"></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addSub</strong> 的作用就是为 <strong>Dep</strong> 上的 <strong>subs</strong> 堆栈添加新的监听 <strong>Watcher</strong> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addSub (sub: Watcher) &#123;</span><br><span class="line">  <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回过头，我们再看 <strong>defineReactive</strong> 方法中的 <strong>getter</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在应该清楚了这段方法的作用：</p><ol><li>调用 <strong>obj.key</strong> 触发该 <strong>getter</strong> 方法</li><li>判断 <strong>getter</strong> 是否存在，进行预执行，得到一开始的 <strong>value</strong></li><li><p>如果 <strong>Dep.target</strong> 监听对象存在，对当前 <strong>Dep</strong> 依赖实例进行依赖，触发 addDep</p><p>3.1. 调用 <strong>Watcher</strong> 的 <strong>addDep</strong> 方法，存入当前依赖实例对象 <strong>dep</strong></p><p>3.2. 进行“依赖判断”（这个判断逻辑，Watcher 篇再说）</p><p>3.3. 将 <strong>Watcher</strong> 实例对象 <strong>this</strong> 引用，添加至 <strong>Dep</strong> 依赖对象的 <strong>subs</strong> 订阅队列</p></li><li><p>如果其指数型 <strong>childOb</strong> 也被赋予观察特征，那么也对其 <strong>childOb.dep</strong> 属性进行 <strong>addDep</strong></p></li></ol><h2 id="notify-通知依赖（触发）"><a href="#notify-通知依赖（触发）" class="headerlink" title="notify 通知依赖（触发）"></a>notify 通知依赖（触发）</h2><p>接下来就讲讲 <strong>notify</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">notify () &#123;</span><br><span class="line">  <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前通过 <strong>depend</strong> 收集的 <strong>subs</strong> 通过一个数组的 <strong>slice</strong> 浅拷贝出来。</p><p>而这个 <strong>update</strong> 是属于 Watcher 对象的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">this</span>.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 <strong>run</strong> 方法中涉及了 <strong>Watcher</strong> 是如何实现 <strong>数据动态响应机制</strong> 的。</p><p>中间这个过程我们暂时不去关心，还是回到 <strong>setter</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">  dep.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否触发 <strong>vue</strong> 的数据更新机制，需要判断新老值是否有变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有变化则直接 <strong>return</strong> 。注意这里有个“矛盾的判断”，针对 <strong>NaN</strong> 结果的。</p><p>然后如果没有定义 <strong>setter</strong> 但定义了 <strong>getter</strong> 也直接 <strong>return</strong> ，因为一开始就通过 <strong>getter</strong> 预取值过了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果定义了 <strong>setter</strong> 则通过 <strong>call</strong> 方式调用次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setter.call(obj, newVal);</span><br></pre></td></tr></table></figure><p>注意这里有个小细节：重新对 <strong>val</strong> 赋值，因为对 <strong>val</strong> 的引用是个闭包方式（chlidOb 也是个闭包引用），以让 <strong>getter 方法下次能取到更新后的值</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = newVal;</span><br></pre></td></tr></table></figure><p>得到的 <strong>newVal</strong> 也通过 <strong>observe</strong> 进行观察。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">childOb = !shallow &amp;&amp; observe(newVal);</span><br></pre></td></tr></table></figure><p>全局结束后，遍历 <strong>this.subs</strong> 异步队列执行 <strong>update</strong> 方法，通知 Watcher 对象进行数据动态响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.notify();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲了 <strong>Dep</strong> 对象中的 <strong>depend</strong> , <strong>notify</strong> 两个主要方法。回过头看了 <strong>defineReactive</strong> 方法中的 <strong>getter/setter</strong> 是如何触发这两个方法。</p><p>同时也加深了对 <strong>Observer</strong> 中定义的 <strong>__ob__</strong> 属性和 <strong>Dep</strong> 对象之间的关系。</p><p>下篇将通过对 <strong>Watcher</strong> 对象的解读，理解 <strong>Dep</strong> 和 <strong>Watcher</strong> 之间的联系。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-数据动态响应：观察者 Observer</title>
      <link href="/legacy/2019/12/15/vue-learn-reactive-observer/"/>
      <url>/legacy/2019/12/15/vue-learn-reactive-observer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们已经大致了解了初始化工作中 vue 到底做了哪些事情，这篇开始，进入第二大块内容 —— <strong>数据响应</strong>，逐步探究 <strong>vue</strong> 是如何实现数据的动态响应？</p><p>再次回顾状态初始化 <strong>initState</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先忽略 props 、methods 、computed 、watcher 的“处理工作”，先选 <strong>options.data</strong> 属性作为起点，因为 <strong>data</strong> 使我们开发中最常用的属性，借他了解整个 <strong>动态响应的全貌</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">"function"</span> ? getData(data, vm) : data || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 校验 options.data 的合法性</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 <strong>initData</strong> 的初始化处理，发现最终调用了观察方法 <strong>observe(data)</strong> ，这是数据动态响应的第一部分。</p><h1 id="observe-观察数据"><a href="#observe-观察数据" class="headerlink" title="observe 观察数据"></a>observe 观察数据</h1><h2 id="代码主体"><a href="#代码主体" class="headerlink" title="代码主体"></a>代码主体</h2><p>先看下方法代码定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span>;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp; <span class="built_in">Object</span>.isExtensible(value) &amp;&amp; !value._isVue) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>我们知道目前是如何调用此 <strong>observe</strong> 方法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br></pre></td></tr></table></figure><p>所以目前参数列表中 <strong>value</strong> 就是 <strong>options.data</strong> ， <strong>asRootData</strong> 值为 <strong>true</strong>：</p><p>首先，回去判断某些不做观察的条件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不做观察的条件</strong> ： <strong>value</strong> 非对象形式，并且不是 <strong>VNode</strong> 虚拟节点对象。</p><p>再是，判断 <strong>value</strong> 是否已经被观察过了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer;</span><br></pre></td></tr></table></figure><p>如果 value 对象上含有 <strong>__ob__</strong> 属性，并且该属性是 <strong>Observer</strong> 对象，则直接返回 <strong>__ob__</strong> 属性值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasOwn(value, <span class="string">"__ob__"</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">  ob = value.__ob__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是一段很长的判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp; <span class="built_in">Object</span>.isExtensible(value) &amp;&amp; !value._isVue;</span><br></pre></td></tr></table></figure><p><strong>shouldObserve</strong> 默认为 <strong>true</strong> ，通过调用 <strong>toggleObserving</strong> 方法来切换其值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleObserving</span>(<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">  shouldObserve = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shouldObserve</strong> 像是一个开关来控制是否来执行 <strong>observe</strong> 方法，你们在 <strong>vue</strong> 中找到几处 <strong>toggleObserving</strong> 开关的使用。</p><p>比如，在对 inject 处理 provide 的传值时的数据封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInjections</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm);</span><br><span class="line">  toggleObserving(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(vm, key, result[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">  toggleObserving(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终 <strong>inject</strong> 上的第一级属性被定义了响应化，但子级属性因为 <strong>toggleObserving(false)</strong> 而直接 <strong>return</strong> ，这就是为何：你更新 inject 相关值时，页面没有更新的原因（有些扯远了）。</p><p><strong>isServerRendering</strong> 判断是否是 SSR 服务端渲染，本文的运行环境是浏览器中，所以这里判断为 <strong>true</strong> 。</p><p>后续只要 <strong>value</strong> 符合是 <strong>引用类型对象</strong>（对象字面量、数组），并且是属性可扩展，和非 vue 框架对象 （<strong>_isVue</strong> 为 <strong>false</strong> ），则会创建 <strong>Observer</strong> 观察者对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ob = <span class="keyword">new</span> Observer(value);</span><br></pre></td></tr></table></figure><h1 id="Observer-观察者对象"><a href="#Observer-观察者对象" class="headerlink" title="Observer 观察者对象"></a>Observer 观察者对象</h1><h2 id="代码主体-1"><a href="#代码主体-1" class="headerlink" title="代码主体"></a>代码主体</h2><p>这是 <strong>Observer</strong> 类的代码主体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">    def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  walk() &#123;</span><br><span class="line">    defineReactive();</span><br><span class="line">  &#125;</span><br><span class="line">  observeArray() &#123;</span><br><span class="line">    observe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们先看下 <strong>Observer</strong> 的基本属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line"><span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>每次新建的 Observer 对象将初始化一个 <strong>Dep</strong> 对象（这块下篇再看）定义为 <strong>this.dep</strong> ，并且还会初始化 <strong>this.value</strong> 待观察对象，<strong>this.vmCount</strong> 。</p><h2 id="对象属性-ob"><a href="#对象属性-ob" class="headerlink" title="对象属性 __ob__"></a>对象属性 __ob__</h2><p>在 <strong>value</strong> 对象上新增一个观察属性 <strong>__ob__</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><strong>def</strong> 方法内部就是通过定义 <strong>数据类型属性</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  value: val,</span><br><span class="line">  enumerable: !!enumerable,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这里的 <strong>enumerable</strong> 为 <strong>false</strong> ，会在遍历 value 是屏蔽掉当前属性 <strong>__ob__</strong> 。这个属性 <strong>__ob__</strong> 以后有什么用，我们在 <strong>Dep</strong> 对象中再看。</p><p>先跳过 <strong>Array.isArray(value)</strong> 的判断，直接调用 <strong>this.walk</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.walk(value);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>walk</strong> 会遍历 <strong>value</strong> 上的所有属性（除了 <strong>__ob__</strong>），并通过 <strong>defineReactive</strong> 定义 <strong>响应式数据</strong> 。</p><h2 id="数组拦截"><a href="#数组拦截" class="headerlink" title="数组拦截"></a>数组拦截</h2><p>再回到数据类型的判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    protoAugment(value, arrayMethods);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们知道 <strong>__proto__</strong> 是个有争议的属性，因为他不属于 Web 规范，只是被浏览器厂商实现着，用来访问对象 [[Prototype]] 属性。</p><p>所以 <strong>vue</strong> 会有如下工具函数 <strong>hasProto</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"__proto__"</span> <span class="keyword">in</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>判断当前环境是否支持 <strong>hasProto</strong> 分别调用 <strong>protoAugment</strong> 、 <strong>copyAugment</strong> 来对 <strong>value</strong> 数组上的每个元素进行针对数组类型的数据做响应。</p><p>根据 <strong>Array.prototype</strong> 创建数组（方法）对象 <strong>arrayMethods</strong> ，通过 <strong>def</strong> 设置 <strong>mutator</strong> 方法，如果数组数据涉及变化（ <strong>push、unshift、splice</strong> ）则再次调用 <strong>notify</strong> 触发数据响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面就是 vue 怎么对原生数组方法进行拦截的代码，有兴趣可以细看。</p><p>解析完数组队列后，最后执行 <strong>this.observeArray</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">        observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部还是执行 <strong>observe</strong> 方法。</p><p>假设你在 data 上定义了一个数组数据，最后的结果就会长成这样：</p><img src="/legacy/2019/12/15/vue-learn-reactive-observer/arrayOb.png" class="" title="数组每个元素都添加了 __ob__"><h1 id="defineReactive-响应式数据的定义"><a href="#defineReactive-响应式数据的定义" class="headerlink" title="defineReactive 响应式数据的定义"></a>defineReactive 响应式数据的定义</h1><p>已经知道，无论是否是 <strong>Array</strong> 类型的数据， <strong>value</strong> 最终都会调用 <strong>walk</strong> 方法，执行 <strong>defineReactive</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码主体-2"><a href="#代码主体-2" class="headerlink" title="代码主体"></a>代码主体</h2><p>现在来看下 <strong>defineReactive</strong> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// depend ...</span></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// notify ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Dep-对象"><a href="#创建-Dep-对象" class="headerlink" title="创建 Dep 对象"></a>创建 Dep 对象</h2><p>已进入该方法，就看到了新建了 <strong>Dep</strong> 对象，并定义为 <strong>dep</strong> ，这个是依赖对象，我们目前只需知道每个对象属性都会调用 <strong>defineReactive</strong> 方法，并且都会创建 Dep 实例。具体下篇再细谈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br></pre></td></tr></table></figure><h2 id="合法验证"><a href="#合法验证" class="headerlink" title="合法验证"></a>合法验证</h2><h3 id="对象属性是否可配置"><a href="#对象属性是否可配置" class="headerlink" title="对象属性是否可配置"></a>对象属性是否可配置</h3><p>根据对象属性描述特征 <strong>configurable</strong> 来判断是否要进行数据动态响应定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line"><span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果特性 <strong>configurable</strong> 为 <strong>false</strong> ，就没有之后的意义了（将对象属性定义为 <strong>访问器属性</strong> ）。</p><h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><p>我们通常在 <strong>data</strong> 选项属性上会定义 {name:’foo’} ，是有值的，但没有定义 getter 函数。所以需要通过某种方式来事先计算一次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.get;</span><br><span class="line"><span class="keyword">const</span> setter = property &amp;&amp; property.set;</span><br><span class="line"><span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">  val = obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果 <strong>getter</strong> 存在呢？那就会在底下的 <strong>getter/setter</strong> 中执行 <strong>getter.call()</strong> 进行执行赋值操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br></pre></td></tr></table></figure><h2 id="判断子元素是否需要观察"><a href="#判断子元素是否需要观察" class="headerlink" title="判断子元素是否需要观察"></a>判断子元素是否需要观察</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val);</span><br></pre></td></tr></table></figure><p>如果我们的数据是这样（对象嵌套）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">        name:<span class="string">'eminoda'</span>,</span><br><span class="line">        child:&#123;</span><br><span class="line">            name:<span class="string">'sxh'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次遍历 <strong>user</strong> 时，当前的 <strong>val</strong> 就是 <strong>child</strong> 对象，需要继续通过 <strong>observe</strong> 观察。</p><p>得到 <strong>childOb</strong> ，供后续逻辑使用。</p><h2 id="对象属性定义访问器属性"><a href="#对象属性定义访问器属性" class="headerlink" title="对象属性定义访问器属性"></a>对象属性定义访问器属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: function reactiveGetter() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p>首先通过 getter ，来预执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br></pre></td></tr></table></figure><p>然后就是判断 <strong>Dep.target</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  dep.depend();</span><br><span class="line">  <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">    childOb.dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      dependArray(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然目前没不知道这个 <strong>Dep.target</strong> 是什么，不过从代码上看，当它存在时，就会调用 <strong>depend</strong> 来执行依赖相关操作。</p><h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><p>第一步还是根据判断 <strong>getter</strong> 进行预执行操作，获得 <strong>value</strong> 。</p><p>之后判断 <strong>newVal</strong> 和 <strong>value</strong> 是否有变化？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，<strong>newVal !== newVal</strong> 这样的矛盾判断有什么用？你可以运行下如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"foo"</span>) == <span class="built_in">Number</span>(<span class="string">"foo"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>然后通过 <strong>customSetter</strong> 在开发模式打印些 warn 信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">  customSetter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <strong>getter &amp;&amp; !setter</strong> 就没必要继续之后操作了，直接 <strong>return</strong> 。</p><p>如果定义了 <strong>setter</strong> 函数，则会执行下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (setter) &#123;</span><br><span class="line">  setter.call(obj, newVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  val = newVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将这个新 <strong>newVal</strong> 进行观察，同时出发 <strong>notify</strong> 进行依赖更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">dep.notify();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文篇幅较长，尽可能把 vue 数据动态响应的第一部分原理说明白了。</p><p>通过 <strong>observe</strong> 方法判断对象上，那些属性需要观察，来新建对应的 <strong>Observer</strong> <strong>观察者对象。Observer</strong> 内部循环遍历属性，调用 <strong>definedReactive</strong> 来定义动态响应方式。</p><p>这个动态响应的基本原理还是基于对象的访问属性 getter/setter 。</p><p>其内部真正实现数据的响应机制，还是要看之后的 <strong>Dep</strong> 和 <strong>Watcher</strong> 对象。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 基础：对象属性 property 相关 api 示例</title>
      <link href="/legacy/2019/12/12/js-base-property/"/>
      <url>/legacy/2019/12/12/js-base-property/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向对象语言有个基本的特征，就是有 <strong>类</strong> 这样一个概念。我们也通过各种渠道知道 ECMAScript 中是没有类这个概念的，因起 js 里的对象和面向对象语言中的对象有所不同。</p><blockquote><p>官方把对象定义为：“无序属性的集合，其属性可以包括基本值、对象或者函数”</p></blockquote><p>本篇以对象中无序属性的集合 property 为核心，说下与其相关的一些 api 。</p><h1 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h1><p>如下是，我们最常用的对象定义方式： <strong>对象字面量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  name: <span class="string">"eminoda"</span>,</span><br><span class="line">  age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>表面上看我们只能看到显式的属性定义，其实 js 内部对对象的属性有 <strong>特定值</strong> 来说明其属性的行为特征，分别有两种不同的方式：<strong>数据属性</strong> 和 <strong>访问器属性</strong>。</p><p>对于用于对象属性特性进行 <strong>描述的属性</strong>，我们无法显式调用，这些特性都是由 js 引擎来使用的。当然我们可以调用 <strong>Object.defineProerty()</strong> 来修改。</p><h1 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h1><p>数据属性包含以下 4 个 描述特征：</p><ul><li>configurable: boolean 类型，表示是否可以删除属性、修改属性特性</li><li>enumerable: boolean 类型，表示是否可以通过 for-in 遍历对象属性</li><li>writable: boolean 类型，表示是否可以修改属性值</li><li>value: any 类型，属性值</li></ul><p>下面通过一些例子，来加深对这些属性的理解：</p><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><p>当 configurable 为 false 后，属性 name 无法 delete 删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configurable</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"name"</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 注意：无法删除属性、修改属性特性</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">"eminoda"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> user.name;</span><br><span class="line">log(<span class="string">"configurable"</span>, user.name); <span class="comment">//eminoda</span></span><br></pre></td></tr></table></figure><p>修改非 writable、value 的其他特征就会报错：<strong>Cannot redefine property: name</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"name"</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// Cannot redefine property: name</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">// Cannot redefine property: name</span></span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"eminoda2"</span></span><br><span class="line">&#125;);</span><br><span class="line">log(<span class="string">"configurable"</span>, user.name); <span class="comment">//eminoda2</span></span><br></pre></td></tr></table></figure><h2 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h2><p>当 writable 为 false 后，属性 nickName 无法再次通过赋值来修改属性值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writable</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"nickName"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"sxh"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.nickName = <span class="string">"sxh2"</span>;</span><br><span class="line">log(<span class="string">"writable"</span>, user.nickName); <span class="comment">//sxh</span></span><br></pre></td></tr></table></figure><h2 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h2><p>当 enumerable 为 false 后，无法通过 for-in 遍历其对象上属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enumerable</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"salary"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="number">10000</span></span><br><span class="line">&#125;);</span><br><span class="line">log(<span class="string">"enumerable"</span>, user.salary); <span class="comment">//10000</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> user) &#123;</span><br><span class="line">  log(item); <span class="comment">//name age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为 enumerable 使用场景很小，但是在 vue 数据响应处理时，就对 __ob__ 做了这样的限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  value: val,</span><br><span class="line">  enumerable: !!enumerable, <span class="comment">//默认 false</span></span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当我们使用例如对象字面量方式来创建对象时， configurable 、enumerable 、writable 都默认为 <strong>true</strong> ，value 为我们定义的值，没有则为 undefined。</p><p>如果我们通过 Object.defineProperty 等 api 来定义对象属性，但没有写全这些特征属性的话，默认为 <strong>false</strong> 。</p><p><strong>最佳实践</strong>：建议不要偷懒写全所有的特征描述，除非你知道这些默认值的作用。</p><h1 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h1><p>访问器属性中的访问器即使有 getter/setter 函数，就像 java 里对象中的 getter/setter。</p><p>访问器属性包含以下 4 个 描述特征：</p><ul><li>configurable: boolean 类型，表示是否可以删除属性、修改属性特性</li><li>enumerable: boolean 类型，表示是否可以通过 for-in 遍历对象属性</li><li>get: function 类型，属性调用时触发</li><li>set: function 类型，属性赋值时触发</li></ul><p>相对数据属性的描述特性，我们重点只需要放在 getter/setter 函数。</p><p>下面是个简单用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">"hobby"</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._hobby;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._hobby = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> hobby is <span class="subst">$&#123;val&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.hobby = <span class="string">"持续前端技术分享"</span>;</span><br><span class="line">log(user.hobby); <span class="comment">//eminoda2 hobby is 持续前端技术分享</span></span><br></pre></td></tr></table></figure><p>vue 的数据响应核心就是用过类似这样的方法，只是它在 getter/setter 做了更多的“工作”。</p><h1 id="更多-API"><a href="#更多-API" class="headerlink" title="更多 API"></a>更多 API</h1><p>除了上面用到的 Object.defineProperty 方法外，还有几个常用的 api</p><h2 id="多属性定义"><a href="#多属性定义" class="headerlink" title="多属性定义"></a>多属性定义</h2><p>利用 <strong>Object.defineProperties</strong> 来一次性的对多个对象属性进行特性描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(user, &#123;</span><br><span class="line">  skill: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">"javascript"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  address: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"shanghai"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#123; name: 'eminoda2',</span></span><br><span class="line"><span class="comment">  age: 29,</span></span><br><span class="line"><span class="comment">  _hobby: 'eminoda2 hobby is 持续前端技术分享',</span></span><br><span class="line"><span class="comment">  skill: 'javascript',</span></span><br><span class="line"><span class="comment">  address: 'shanghai' &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="特性描述读取"><a href="#特性描述读取" class="headerlink" title="特性描述读取"></a>特性描述读取</h2><p>在严格模式下，如果我们不知道别人对某对象是如何进行特征定义的话，可能会出现非预期的错误，为避免这样的情况发生，我们可以通过 <strong>Object.getOwnPropertyDescriptor</strong> 获取对象属性的特性描述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="string">"name"</span>);</span><br><span class="line">log(desc);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&#123; value: 'eminoda2',</span></span><br><span class="line"><span class="comment">  writable: false,</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: false &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h1 id="对象“限制”"><a href="#对象“限制”" class="headerlink" title="对象“限制”"></a>对象“限制”</h1><p>我们知道通过属性特征的 configurable、writable 来使得对象更趋于“稳定”，但调用 Object.defineProperty 方法好像有些麻烦。从 es5 开始，提供了几个 api 方式来帮助我们 <strong>防止对象非预期的篡改情况发生</strong> 。</p><p>现实我们也经常在框架看到这些 api 的出现，但要知道本质都是使用 <strong>属性特征</strong> 来做控制的。</p><h2 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h2><p>特点：不可扩展（不可添加新属性，添加无效为 undefined）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br></pre></td></tr></table></figure><p>下面来测试下，对象限制后的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试工具方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_testObj</span>(<span class="params">obj, type</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">`[<span class="subst">$&#123;type&#125;</span>] `</span>, <span class="string">"扩展性: "</span>, <span class="built_in">Object</span>.isExtensible(obj), </span><br><span class="line">    <span class="string">"密封性: "</span>, <span class="built_in">Object</span>.isSealed(obj), </span><br><span class="line">    <span class="string">"冻结性: "</span>, <span class="built_in">Object</span>.isFrozen(obj));</span><br><span class="line"></span><br><span class="line">  obj.name = <span class="string">"eminoda2"</span>;</span><br><span class="line">  log(obj.name !== <span class="string">"eminoda"</span> ? <span class="string">"属性可修改"</span> : <span class="string">"属性不可修改"</span>);</span><br><span class="line">  obj.name2 = <span class="string">"sxh"</span>;</span><br><span class="line">  log(!obj.name2 ? <span class="string">"属性不可新增"</span> : <span class="string">"属性可新增"</span>);</span><br><span class="line">  <span class="keyword">delete</span> obj.name;</span><br><span class="line">  log(!obj.name ? <span class="string">"属性可删除"</span> : <span class="string">"属性不可删除"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> noExtensionUser = <span class="built_in">Object</span>.preventExtensions(&#123;</span><br><span class="line">  name: <span class="string">"eminoda"</span></span><br><span class="line">&#125;);</span><br><span class="line">_testObj(noExtensionUser, <span class="string">"preventExtensions"</span>);</span><br><span class="line"><span class="comment">// [preventExtensions]  扩展性:  false 密封性:  false 冻结性:  false</span></span><br><span class="line"><span class="comment">// 属性可修改</span></span><br><span class="line"><span class="comment">// 属性不可新增</span></span><br><span class="line"><span class="comment">// 属性可删除</span></span><br></pre></td></tr></table></figure><h2 id="密封对象"><a href="#密封对象" class="headerlink" title="密封对象"></a>密封对象</h2><p>不可扩展、不可删除属性（configurable 为 false）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sealUser = <span class="built_in">Object</span>.seal(&#123;</span><br><span class="line">  name: <span class="string">"eminoda"</span></span><br><span class="line">&#125;);</span><br><span class="line">_testObj(sealUser, <span class="string">"seal"</span>);</span><br><span class="line"><span class="comment">// [seal]  扩展性:  false 密封性:  true 冻结性:  false</span></span><br><span class="line"><span class="comment">// 属性可修改;</span></span><br><span class="line"><span class="comment">// 属性不可新增;</span></span><br><span class="line"><span class="comment">// 属性不可删除;</span></span><br></pre></td></tr></table></figure><h2 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h2><p>不可扩展、不可删除属性、并且不可更新属性值（writable 为 false）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> forzenUser = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  name: <span class="string">"eminoda"</span></span><br><span class="line">&#125;);</span><br><span class="line">_testObj(forzenUser, <span class="string">"freeze"</span>);</span><br><span class="line"><span class="comment">// [freeze]  扩展性:  false 密封性:  true 冻结性:  true</span></span><br><span class="line"><span class="comment">// 属性不可修改</span></span><br><span class="line"><span class="comment">// 属性不可新增</span></span><br><span class="line"><span class="comment">// 属性不可删除</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写这篇的目的是因为最近在看 <strong>vue</strong> 源码，发现在数据响应这块逻辑实现上运用了几处对象属性描述特征，即调用了：<strong>Object.defineProperty</strong> 方法。</p><p>我们平时业务代码使用的较少，多是框架帮我们做了这些“事情”。所以借这个机会来探究原生 js 涉及 <strong>对象属性描述定义</strong> 这块的知识点，同时也提到了几个 <strong>对象属性限制</strong> 方面的 api 。希望对此不太清楚的同学能打好基础。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-初始化：响应式的状态</title>
      <link href="/legacy/2019/12/09/vue-learn-init-state/"/>
      <url>/legacy/2019/12/09/vue-learn-init-state/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在开始会在如下方法中，涉及 vue 数据响应相关的 api 使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm);</span><br><span class="line">initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">"created"</span>);</span><br></pre></td></tr></table></figure><p>我不打算在这里看探究响应式 api 的原理，只是先熟悉哪些地方出现了 api ？</p><h1 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h1><p>先是 initInjections(vm); 的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\inject.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInjections</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm);</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      defineReactive(vm, key, result[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">    toggleObserving(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析-inject"><a href="#解析-inject" class="headerlink" title="解析 inject"></a>解析 inject</h2><p>先回顾下之前的属性合并 <strong>mergeOptions</strong> 方法，vue 会首先对如下属性进行“标准化”操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normalizeProps(child, vm);</span><br><span class="line">normalizeInject(child, vm);</span><br><span class="line">normalizeDirectives(child);</span><br></pre></td></tr></table></figure><p>比如我们定义的 inject 属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: [<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure><p>最终会被解析成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject: &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">"name"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在 <strong>resolveInject</strong> 方法中就会一级级往“上”，寻找父类定义的 <strong>provide</strong> 属性，直至找到与 <strong>inject</strong> 属性中 <strong>from</strong> 对应的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveInject</span>(<span class="params">inject: any, vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123;</span><br><span class="line">      result[key] = source._provided[provideKey];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    source = source.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义响应式"><a href="#定义响应式" class="headerlink" title="定义响应式"></a>定义响应式</h2><p>最后如果 result 存在，就会交给 <strong>defineReactive</strong> 定义成响应式数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInjections</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm);</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    defineReactive(vm, key, result[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h1><p><strong>initState</strong> 相比于 <strong>initInjections</strong> 和 <strong>initProvide</strong> 复杂，因为在它内部需要处理我们平时最常用的属性：props、methods、data、computed、watch。同时这些属性也是 vue 的数据驱动核心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options;</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props);</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods);</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed);</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到对这些重要的属性分别有对应初始化解析的方法（initProps、initMethods、initData…）</p><p>并且传入的参数都是由 <strong>mergeOptions</strong> 方法中的合并属性策略来生成最后的属性对象 <strong>vm.\$options</strong>。</p><h2 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h2><p>initProps 遍历 vm.\$options.props 对象上的属性，定义为响应式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params">vm: Component, propsOptions: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    defineReactive(props, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这些定义的 props 属性不能是组件定义上涉及的关键字 key,ref,slot,slot-scope,is；同时基于单项数据流的原则 props 中的属性值不建议从子组件中再次改变来影响父组件，官方建议还是使用 data、computed 来处理。</p><h2 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h2><p>initMethods 最简单，检验完合法性后，最后将每个方法赋值到 vm 对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span>(<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// 校验方法属性，不能与 props 冲突</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">"function"</span> ? noop : bind(methods[key], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h2><p>同样 data 属性对象也是通过遍历，来对每个属性进行校验：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">let</span> i = keys.length;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">// 校验 props、methods</span></span><br><span class="line">  &#125;</span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将整个 data 对象交给 <strong>observe</strong> 方法设置为观察对象。</p><h2 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h2><p>initComputed 和前面的初始化方法略有不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = (vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key];</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">"function"</span> ? userDef : userDef.get;</span><br><span class="line"></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验属性，不能出现在 data、props 上</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>computed</strong> 对象上的属性，必须有个 <strong>get</strong> 方法，后面需要给 <strong>Watcher</strong> 使用。</p><p>基于我们开发中使用过 <strong>computed</strong> 和 <strong>watch</strong> 属性的场景上看，其他这两者很类似。在代码中也体现了出来，因为都创建了 <strong>Watcher</strong> 对象。</p><h2 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span>(<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>createWatcher</strong> 内部就是调用 <strong>\$watch</strong> 方法，创建 <strong>Watcher</strong> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(expOrFn, handler, options);</span><br></pre></td></tr></table></figure><h1 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h1><p><strong>provide</strong> 属性采用 <strong>mergeDataOrFn</strong> 策略，最后被定义在 <strong>vm.\$options.provide</strong> 属性中。</p><p><strong>provide</strong> 和 <strong>inject</strong> 都是成对出现，所以在执行完本实例的 <strong>initInjections</strong> 后，也将执行<br><strong>initProvide</strong> 方法，供下个子组件使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProvide</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.$options.provide;</span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm._provided = <span class="keyword">typeof</span> provide === <span class="string">"function"</span> ? provide.call(vm) : provide;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并将结果挂载到 <strong>vm._provided</strong> 上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这些 init 方法中涉及了数据响应式相关的 api ，分别是：</p><ul><li>defineReactive</li><li>observe</li><li>Watcher</li></ul><p>这些方法都在做什么？我们下篇继续深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-初始化：生命周期钩子</title>
      <link href="/legacy/2019/12/09/vue-learn-init-lifecycle-hook/"/>
      <url>/legacy/2019/12/09/vue-learn-init-lifecycle-hook/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>顺着 _init 代码的逻辑。因为都是 vue 相关变量属性的初始化定义，我跳过了如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initLifecycle(vm);</span><br><span class="line">initEvents(vm);</span><br><span class="line">initRender(vm);</span><br></pre></td></tr></table></figure><p>直接进入了第一个 beforeCreate 生命周期钩子的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">"beforeCreate"</span>);</span><br></pre></td></tr></table></figure><p>下面看下，几种不同的周期钩子是怎么在整个 vue 执行的过程中生效的。</p><h1 id="lifecycle-hook"><a href="#lifecycle-hook" class="headerlink" title="lifecycle hook"></a>lifecycle hook</h1><h2 id="回顾-mergeOption-处理"><a href="#回顾-mergeOption-处理" class="headerlink" title="回顾 mergeOption 处理"></a>回顾 mergeOption 处理</h2><p>注意所有的钩子在 mergeOptions 阶段已被 mergeHook 策略处理过了。</p><p>并且如果存在继承关系的 vue 实例上定义的钩子方法不会存在覆盖情况，他们会按父先子后的顺序存入数组中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params">parentVal: ?Array&lt;Function&gt;, childVal: ?Function | ?Array&lt;Function&gt;</span>): ?<span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = childVal ? (parentVal ? parentVal.concat(childVal) : <span class="built_in">Array</span>.isArray(childVal) ? childVal : [childVal]) : parentVal;</span><br><span class="line">  <span class="keyword">return</span> res ? dedupeHooks(res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupeHooks</span>(<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(hooks[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      res.push(hooks[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="钩子函数的包装"><a href="#钩子函数的包装" class="headerlink" title="钩子函数的包装"></a>钩子函数的包装</h2><p>在实际的 vm.\$options[hook] 属性上你能看到最终的效果：</p><img src="/legacy/2019/12/09/vue-learn-init-lifecycle-hook/lifecycle-hook.png" class=""><p>以下是对 hook 钩子方法的处理，中间包裹了一个错误处理的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\lifecycle.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHook</span>(<span class="params">vm: Component, hook: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget();</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$options[hook];</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span>;</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">"hook:"</span> + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到这个 error 处理中包含 call 执行操作，就这样对应的生命周期钩子得到了执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\util\error.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeWithErrorHandling</span>(<span class="params">handler: Function, context: any, args: null | any[], vm: any, info: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? handler.apply(context, args) : handler.call(context);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123;</span><br><span class="line">      res.catch(<span class="function"><span class="params">e</span> =&gt;</span> handleError(e, vm, info + <span class="string">` (Promise/async)`</span>));</span><br><span class="line">      <span class="comment">// issue #9511</span></span><br><span class="line">      <span class="comment">// avoid catch triggering multiple times when nested calls</span></span><br><span class="line">      res._handled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, info);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接触了第一个生命周期钩子 beforeCreate ，进入 callHook 看了生命周期方法是如何执行触发的。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-初始化：代理</title>
      <link href="/legacy/2019/12/09/vue-learn-init-proxy/"/>
      <url>/legacy/2019/12/09/vue-learn-init-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>紧接着 <strong>mergeOptions</strong> 的方法后，接下来就进入了渲染代理 <strong>_renderProxy</strong> 属性的定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">  initProxy(vm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm._renderProxy = vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开始 initProxy 前，先对 Proxy 对象有个简单的认识。</p><h1 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h1><blockquote><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p></blockquote><p>我对其简单的理解：</p><ul><li>Proxy 作用：<br>我们可以定义 handler 方式作为对象 target 的“加工处理”，定义在 Proxy 中。</li><li>元编程：<br>如果我们 handler 处理较为不同，可能得到的最终结果会是“加工处理”后的，并且它比我们写代码更为高效。</li></ul><h1 id="初始化代理-initProxy"><a href="#初始化代理-initProxy" class="headerlink" title="初始化代理 initProxy"></a>初始化代理 initProxy</h1><p>了解 <strong>Proxy</strong> 后，我们来进入到 <strong>initProxy</strong> 方法中看下，首先是 <strong>Proxy</strong> 的 <strong>set</strong> 定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isBuiltInModifier = makeMap(<span class="string">"stop,prevent,self,ctrl,shift,alt,meta,exact"</span>);</span><br><span class="line">config.keyCodes = <span class="keyword">new</span> <span class="built_in">Proxy</span>(config.keyCodes, &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBuiltInModifier(key)) &#123;</span><br><span class="line">      warn(<span class="string">`Avoid overwriting built-in modifier in config.keyCodes: .<span class="subst">$&#123;key&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据 isBuiltInModifier 的信息，基本知道该 set 方法适用于设置按键相关操作的。如果我们设置了 ctrl 等的关键字就会出现 warn 警告。</p><p>下面是 initProxy 的主方法定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProxy) &#123;</span><br><span class="line">    <span class="comment">// determine which proxy handler to use</span></span><br><span class="line">    <span class="keyword">const</span> options = vm.$options;</span><br><span class="line">    <span class="keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped ? getHandler : hasHandler;</span><br><span class="line">    vm._renderProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(vm, handlers);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先会判断当前客户端是否支持 Proxy 对象，接着会判断 render._withStripped 来决定使用哪种 handler 方式？（getHandler or hasHandler）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getHandler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">"string"</span> &amp;&amp; !(key <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key);</span><br><span class="line">      <span class="keyword">else</span> warnNonPresent(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasHandler = &#123;</span><br><span class="line">  has(target, key) &#123;</span><br><span class="line">    <span class="keyword">const</span> has = key <span class="keyword">in</span> target;</span><br><span class="line">    <span class="keyword">const</span> isAllowed = allowedGlobals(key) || (<span class="keyword">typeof</span> key === <span class="string">"string"</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">"_"</span> &amp;&amp; !(key <span class="keyword">in</span> target.$data));</span><br><span class="line">    <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123;</span><br><span class="line">      <span class="comment">// 同 handler get</span></span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key);</span><br><span class="line">      <span class="keyword">else</span> warnNonPresent(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> has || !isAllowed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面涉及了几个对象属性取值的校验：</p><ul><li>warnReservedPrefix: 属性 key 必须是 target.\$data 对象上定义过的</li><li>warnNonPresent: 属性 key 没有在 target 定义过，却出现在 template 模板上</li><li>allowedGlobals:<br>允许出现的定义（Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,require）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要注意的是，通过 Proxy 元编程方式对设置的对象做了验证拦截处理，比让我们在开发中有个更详细的错误提示。</p><p>这个对象 target 就是 vm （即整个 this 引用），最后整个代理是交付给 <strong>vm._renderProxy</strong> 属性，我们在看到相关渲染方式时再关注它的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-初始化：属性合并</title>
      <link href="/legacy/2019/12/09/vue-learn-init-merge-options/"/>
      <url>/legacy/2019/12/09/vue-learn-init-merge-options/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇，借助生命周期图简单介绍了整个 Vue 的声明过程，这篇开始正式进入 <strong>Vue.prototype._init</strong> 方法，以其为起始点，看整个 Vue 的内部代码逻辑。</p><h1 id="初始化-init"><a href="#初始化-init" class="headerlink" title="初始化 _init()"></a>初始化 _init()</h1><p>先看下整个初始化的代码（因为排版，略作删减，有需要还是 clone 整个项目查看，后续不再做说明）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span>;</span><br><span class="line">  vm._uid = uid++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  vm._isVue = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    initInternalComponent(vm, options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">    initProxy(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm._self = vm;</span><br><span class="line">  initLifecycle(vm);</span><br><span class="line">  initEvents(vm);</span><br><span class="line">  initRender(vm);</span><br><span class="line">  callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">  initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm);</span><br><span class="line">  initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">"created"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="属性合并-mergeOptions"><a href="#属性合并-mergeOptions" class="headerlink" title="属性合并 mergeOptions"></a>属性合并 mergeOptions</h1><p>我们定义 <strong>Vue</strong> 对象的参数，会被 <strong>_init</strong> 方法接收，并作为 options 选项对象参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options?: Object</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>之后会判断 options._isComponent ，当然现在肯定为 false ，随后程序会调用 <strong>mergeOptions</strong> 方法，进行合并选项参数的工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm);</span><br></pre></td></tr></table></figure><h2 id="Constructor-解析"><a href="#Constructor-解析" class="headerlink" title="Constructor 解析"></a>Constructor 解析</h2><p>如果你愿意可以看下，它是怎么对 this 上的 Constructor 引用做解析的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span>(<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> options = Ctor.options;</span><br><span class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</span><br><span class="line">    <span class="keyword">const</span> superOptions = resolveConstructorOptions(Ctor.super);</span><br><span class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions;</span><br><span class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</span><br><span class="line">      Ctor.superOptions = superOptions;</span><br><span class="line">      <span class="keyword">const</span> modifiedOptions = resolveModifiedOptions(Ctor);</span><br><span class="line">      <span class="keyword">if</span> (modifiedOptions) &#123;</span><br><span class="line">        extend(Ctor.extendOptions, modifiedOptions);</span><br><span class="line">      &#125;</span><br><span class="line">      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);</span><br><span class="line">      <span class="keyword">if</span> (options.name) &#123;</span><br><span class="line">        options.components[options.name] = Ctor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果就是通过递归该方法，把 vm.constructor 上的父类引用 Ctor.super 的属性和当前对象引用 Ctor 的属性做继承，合并成一个符合要求的 options 返回。</p><p>不过有些其他的概念可以说下，我们知道一个构造函数声明后，会有个 prototype 原型对象，并且原型对象有个 constructor 指针指回构造函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">  <span class="keyword">this</span>.age = options.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.nickname = options.nickname;</span><br><span class="line">  <span class="keyword">this</span>.resolveConstructor(<span class="keyword">this</span>.constructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype.resolveConstructor = <span class="function"><span class="keyword">function</span>(<span class="params">Ctor</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">"Ctor"</span>, Ctor); <span class="comment">//Ctor.options [Function: Child]</span></span><br><span class="line">  log(<span class="string">"Ctor.prototype"</span>, Ctor.prototype); <span class="comment">// Child &#123; resolveConstructor: [Function] &#125;</span></span><br><span class="line">  log(<span class="string">"Ctor.nickname"</span>, Ctor.nickname); <span class="comment">// undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(&#123; <span class="attr">name</span>: <span class="string">"eminoda"</span>, <span class="attr">nickname</span>: <span class="string">"e"</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="normalize-标准化选项"><a href="#normalize-标准化选项" class="headerlink" title="normalize 标准化选项"></a>normalize 标准化选项</h2><p>解析完 <strong>Constructor</strong> 后，就进入 <strong>mergeOptions</strong> 方法了，然后迎来针对 props、inject、directives 的 <strong>标准化解析</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params">parent: Object, child: Object, vm?: Component</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  normalizeProps(child, vm);</span><br><span class="line">  normalizeInject(child, vm);</span><br><span class="line">  normalizeDirectives(child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Vue 为方便我们的“各种”方式的使用，做了多样的 api，最后都要通过标准化的转化让 vue 内部来正确使用：</p><p>下面是这三个属性的转化说明：</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: Array&lt;string&gt; | Object</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeProps</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = options.props;</span><br><span class="line">  <span class="keyword">if</span> (!props) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> i, val, name;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(props)) &#123;</span><br><span class="line">    <span class="comment">// 数组 props: ['name','age']</span></span><br><span class="line">    i = props.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      val = props[i];</span><br><span class="line">      <span class="comment">// 只接受字符串的变量 key，并且转为驼峰形式</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"string"</span>) &#123;</span><br><span class="line">        name = camelize(val);</span><br><span class="line">        res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</span><br><span class="line">    <span class="comment">// 对象字面量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      val = props[key];</span><br><span class="line">      name = camelize(key);</span><br><span class="line">      res[name] = isPlainObject(val) ? val : &#123; <span class="attr">type</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: Array&lt;string&gt; | &#123; [key: string]: string | Symbol | Object &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeInject</span>(<span class="params">options: Object, vm: ?Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inject = options.inject;</span><br><span class="line">  <span class="keyword">if</span> (!inject) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> normalized = (options.inject = &#123;&#125;);</span><br><span class="line">  <span class="comment">// 无论数组还是对象，最终都将 inject 赋值成 &#123;from:key&#125; 的形式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inject.length; i++) &#123;</span><br><span class="line">      normalized[inject[i]] = &#123; <span class="attr">from</span>: inject[i] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(inject)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> inject) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = inject[key];</span><br><span class="line">      normalized[key] = isPlainObject(val) ? extend(&#123; <span class="attr">from</span>: key &#125;, val) : &#123; <span class="attr">from</span>: val &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directives: Object</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeDirectives</span>(<span class="params">options: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dirs = options.directives;</span><br><span class="line">  <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> dirs) &#123;</span><br><span class="line">      <span class="keyword">const</span> def = dirs[key];</span><br><span class="line">      <span class="comment">// 如果对象上属性值为 function ，这默认定义 bind 和 update 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">"function"</span>) &#123;</span><br><span class="line">        dirs[key] = &#123; <span class="attr">bind</span>: def, <span class="attr">update</span>: def &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mergeField-字段合并"><a href="#mergeField-字段合并" class="headerlink" title="mergeField 字段合并"></a>mergeField 字段合并</h2><p>当标准化后，会分别遍历 parent 和 child 的属性字段，根据特定字段的 <strong>合并策略</strong> 进行 merge 操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> key;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">  mergeField(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">    mergeField(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeField</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> strat = strats[key] || defaultStrat;</span><br><span class="line">  options[key] = strat(parent[key], child[key], vm, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并策略-strat"><a href="#合并策略-strat" class="headerlink" title="合并策略 strat"></a>合并策略 strat</h2><p>这里简单说下，vue 默认会对重要的选项属性有个合并策略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\util\options.js</span></span><br></pre></td></tr></table></figure><h3 id="默认策略-defaultStrat"><a href="#默认策略-defaultStrat" class="headerlink" title="默认策略 defaultStrat"></a>默认策略 defaultStrat</h3><p>属性：el、propsData</p><p>以最简单的方式来合并字段，如果 child 不存在就用 parent</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultStrat = <span class="function"><span class="keyword">function</span>(<span class="params">parentVal: any, childVal: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal === <span class="literal">undefined</span> ? parentVal : childVal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="特殊定义"><a href="#特殊定义" class="headerlink" title="特殊定义"></a>特殊定义</h3><p>属性：lifecycle</p><p>根据预设的生命周期数组，挨个遍历初始化钩子 hook 的策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LIFECYCLE_HOOKS = [<span class="string">"beforeCreate"</span>, <span class="string">"created"</span>, <span class="string">"beforeMount"</span>, <span class="string">"mounted"</span>, <span class="string">"beforeUpdate"</span>, <span class="string">"updated"</span>, <span class="string">"beforeDestroy"</span>, <span class="string">"destroyed"</span>, <span class="string">"activated"</span>, <span class="string">"deactivated"</span>, <span class="string">"errorCaptured"</span>, <span class="string">"serverPrefetch"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>属性：component、directive、filter 策略：</p><p>如上三个 api 设置 s 命名，定义合并策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  strats[type + <span class="string">"s"</span>] = mergeAssets;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="继承策略"><a href="#继承策略" class="headerlink" title="继承策略"></a>继承策略</h3><p>属性：props、methods、inject、computed</p><p>以 child 优先，覆盖 parent 属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">parentVal,childVal,vm,key</span>): ?<span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br><span class="line">  <span class="keyword">const</span> ret = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  extend(ret, parentVal)</span><br><span class="line">  <span class="keyword">if</span> (childVal) extend(ret, childVal)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据合并方法策略-mergeDataOrFn"><a href="#数据合并方法策略-mergeDataOrFn" class="headerlink" title="数据合并方法策略 mergeDataOrFn"></a>数据合并方法策略 mergeDataOrFn</h3><p>属性：data、provide</p><p>如果参数是 function 类型，会通过 call 来做预执行操作，将结果作为 parent 和 child 的合并前提。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeDataOrFn</span>(<span class="params">parentVal: any, childVal: any, vm?: Component</span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="comment">// in a Vue.extend merge, both should be functions</span></span><br><span class="line">    <span class="keyword">if</span> (!childVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parentVal) &#123;</span><br><span class="line">      <span class="keyword">return</span> childVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mergeData(<span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : childVal, <span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(<span class="keyword">this</span>, <span class="keyword">this</span>) : parentVal);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// instance merge</span></span><br><span class="line">      <span class="keyword">const</span> instanceData = <span class="keyword">typeof</span> childVal === <span class="string">"function"</span> ? childVal.call(vm, vm) : childVal;</span><br><span class="line">      <span class="keyword">const</span> defaultData = <span class="keyword">typeof</span> parentVal === <span class="string">"function"</span> ? parentVal.call(vm, vm) : parentVal;</span><br><span class="line">      <span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeData(instanceData, defaultData);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultData;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据合并策略-mergeData"><a href="#数据合并策略-mergeData" class="headerlink" title="数据合并策略 mergeData"></a>数据合并策略 mergeData</h3><p>用于 <strong>mergeDataOrFn</strong> 策略中的基础方案</p><p>会根据遍历 to、from 各自对象上的属性，互相作对比，以 to 优先</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeData</span>(<span class="params">to: Object, from: ?Object</span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">from</span>) <span class="keyword">return</span> to;</span><br><span class="line">  <span class="keyword">let</span> key, toVal, fromVal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = hasSymbol ? <span class="built_in">Reflect</span>.ownKeys(<span class="keyword">from</span>) : <span class="built_in">Object</span>.keys(<span class="keyword">from</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    key = keys[i];</span><br><span class="line">    <span class="comment">// in case the object is already observed...</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">"__ob__"</span>) <span class="keyword">continue</span>;</span><br><span class="line">    toVal = to[key];</span><br><span class="line">    fromVal = <span class="keyword">from</span>[key];</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(to, key)) &#123;</span><br><span class="line">      <span class="keyword">set</span>(to, key, fromVal);</span><br><span class="line">    &#125; else if (toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal)) &#123;</span><br><span class="line">      mergeData(toVal, fromVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有属性遍历完后，得到最终的 options 交付给 <strong>vm.\$options</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 源码学习-准备工作</title>
      <link href="/legacy/2019/12/03/vue-learn-start/"/>
      <url>/legacy/2019/12/03/vue-learn-start/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="初衷-heart"><a href="#初衷-heart" class="headerlink" title="初衷:heart:"></a>初衷:heart:</h2><p>从 <strong>angular</strong> 转到 <strong>vue</strong> ，到现在也用了两年多了。作为前端开发一直在“无脑”用着官方提供的 API，完成迭代需求。</p><p>表面看似熟悉这门技术框架，但根本不了解其内部机制，如同几根稻草顶着一块砖头一样 <strong>软弱不堪</strong>。</p><p>赶在 vue 3.0 还没有正式发布前，做最后的冲刺，以更好的姿态面对将来的挑战 :punch:</p><p>当然如果在看的你也和我一样未看过 vue 源码，希望这个系列能帮助到你。</p><p>几个小目标 :triangular_flag_on_post:：</p><ul><li>看完 vue 2.x 的源码，了解内部核心原理</li><li>加强解决 vue 相关的问题能力</li><li>提升程序设计能力，学习其中的 <strong>最佳实践</strong></li></ul><h2 id="感谢和参考-sunny"><a href="#感谢和参考-sunny" class="headerlink" title="感谢和参考 :sunny:"></a>感谢和参考 :sunny:</h2><p>由于一直在 <strong>搬砖</strong>，让自己在底层技术面前依旧是新人，因为我从未深度了解它们。所以开始这段旅程前，需要很多人的指点和引导。再次感谢社区那些无私奉献的大佬们。</p><p>参考链接：</p><ul><li><a href="http://hcysun.me/vue-design/" target="_blank" rel="noopener">Vue 技术内幕–hcysun</a> 超详细的解读，还有不错的排版，佩服作者的辛苦付出</li><li><a href="https://juejin.im/post/5c1a839f518825780008537d" target="_blank" rel="noopener">停止学习框架</a> 这是我为何重视源码的契机</li></ul><h1 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h1><p>在开始学习之前，需要对如下工具或者语法有个概念：</p><ul><li><p>ES6</p><p>这算是现在前端的标配，借鉴 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰老师的 ESMAScript 6 入门</a> 基本可以快速上手。</p></li><li><p>flow &amp; rollup</p><p>vue 源码基于这两个工具做类型检查以及代码构建的，不影响阅读学习，但知道是最好的。我也准备了两篇快速入门：<a href="https://eminoda.github.io/2018/12/12/flow-quickstart/" target="_blank" rel="noopener">flow 静态代码检查工具</a>, <a href="https://eminoda.github.io/2018/12/11/rollup-quickstart/" target="_blank" rel="noopener">rollup 5 分钟入门</a></p></li><li><p>vue api</p><p>整个学习过程还是需要对官方 api 有个比较高的熟悉度，只有用过了，当看到源码才会有更深的理解和思考。</p></li></ul><h1 id="Vue-对象在创建的整个过程？"><a href="#Vue-对象在创建的整个过程？" class="headerlink" title="Vue 对象在创建的整个过程？"></a>Vue 对象在创建的整个过程？</h1><p>如下是一个简单的 vue 对象创建示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello Vue!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刚学习前我们一直不知道这个对象的创建内部经历了什么？以这个 Demo 为起点，我们先从 Vue 的函数 function 声明开始：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\index.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不看内部的 _init 方法，因为我们知道当 new 对象后，自然首先就会进入该方法。</p><p>当 function Vue 声明完后，立即会混合相关 vue 原型方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initMixin(Vue);</span><br><span class="line">stateMixin(Vue);</span><br><span class="line">eventsMixin(Vue);</span><br><span class="line">lifecycleMixin(Vue);</span><br><span class="line">renderMixin(Vue);</span><br></pre></td></tr></table></figure><p>这些 Mixin 方法会在 Vue 对象上定义一些我们熟知的 <strong>原型方法</strong>：</p><ul><li>状态类：\$watch、\$set、\$delete</li><li>事件类：\$on、\$once、\$off、\$emit</li><li>生命周期类：\$forceUpdate、\$destroy、_update</li><li>渲染类：\$nextTick、_render</li></ul><p>有机会我们会具体看这些方法是如何工作的。</p><p>先具体看下 <strong>initMixin</strong> ，因为它和一开始的函数声明关系最密切，定义了原型 <strong>_init</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\init.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initLifecycle(vm);</span><br><span class="line">    initEvents(vm);</span><br><span class="line">    initRender(vm);</span><br><span class="line">    callHook(vm, <span class="string">"beforeCreate"</span>);</span><br><span class="line">    initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm);</span><br><span class="line">    initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">"created"</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面定义了一系列 vue 相关的初始化工作，结合 vue 的 <strong>生命周期图谱</strong>，会让容易理解这些初始化方法和 beforeCreate，created 两个生命周期钩子的意义。</p><img src="/legacy/2019/12/03/vue-learn-start/lifecycle-init.png" class="" title="生命周期图谱"><p>紧接着之后的声明，在 <strong>initGlobalAPI</strong> 方法中知道 Vue 定义了哪些 <strong>全局 API</strong> 的？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\index.js</span></span><br><span class="line">initGlobalAPI(Vue);</span><br></pre></td></tr></table></figure><p>包括 Vue.config、Vue.set、Vue.delete、Vue.nextTick、Vue.observable、Vue.mixin、Vue.use、Vue.extend 等，这些你都能在官网的 <a href="https://cn.vuejs.org/v2/api/#%E5%85%A8%E5%B1%80-API" target="_blank" rel="noopener">全局 API</a> 找到对应的说明。</p><p>注意最后的页面挂载，你能在“完整版”的 vue.js 中看到两处 <strong>\$mount</strong> 的方法定义。</p><p>第一处：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\platforms\web\runtime\index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二处是“完整版”打包入口文件这里，再次定义了 <strong>\$mount</strong> 方法，集成了 render 等函数，其内部调用上面的 <strong>\$mount</strong> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\platforms\web\entry-runtime-with-compiler.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount;</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>\$mount 在 _init() 方法中被调用，就这样我们能看到模板被挂载到页面上，其中的逻辑在 <strong>生命周期图谱</strong> 上也展示的很清楚：</p><img src="/legacy/2019/12/03/vue-learn-start/lifecycle-mount.png" class="" title="生命周期图谱"><p>之后，会根据数据的更新机制来完成页面的数据动态响应：</p><img src="/legacy/2019/12/03/vue-learn-start/lifecycle-react.png" class="" title="生命周期图谱"><p>当然以上的过程都简单带过了，详细原理见后续文章。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>做了 vue 代码学习的准备工作。</p><p>并结合 vue 整个生命周期过程，讲了一个简单的 vue 从声明到创建中间的所经历过程，大致对其中过程有个初步的概念。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-路由开发指南</title>
      <link href="/legacy/2019/12/03/vue-base-router/"/>
      <url>/legacy/2019/12/03/vue-base-router/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>示范页面跳转参数传递几个方式。</p><h2 id="query-参数"><a href="#query-参数" class="headerlink" title="query 参数"></a>query 参数</h2><p>第一个就是如何获取 url 问号后面的参数，query 就是描述这块参数的“专用单词”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url: http://127.0.0.1:8080/#/router/params/foo?name=abc</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    queryByRoute: <span class="keyword">this</span>.$route.query, <span class="comment">// &#123;name:'abc'&#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="path-参数"><a href="#path-参数" class="headerlink" title="path 参数"></a>path 参数</h2><p>基于 Restful 规范，我们会设置动态路由（但整个地址的含义是一样的），这样就会有获取地址上的动态参数的需求。</p><p>那怎么方便的获取其中的变量呢？vue-router 也给我准备好了相关 api ，功能是通过 <strong>path-to-regexp</strong> 这个模块完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'params'</span>,</span><br><span class="line">  path: <span class="string">'params/:pathParam'</span>,</span><br><span class="line">  component: Params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url: http://127.0.0.1:8080/#/router/params/foo?name=abc</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    pathParamByRoute: <span class="keyword">this</span>.$route.params.pathParam <span class="comment">// foo</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props-参数"><a href="#props-参数" class="headerlink" title="props 参数"></a>props 参数</h2><p>上面的示例都涉及 this.\$route ，这样使得路由模块和组件的耦合度较高。vue-router 中可以设置 props 属性来注入到 component 中的对应的 props 属性，这样我们的代码会是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'params'</span>,</span><br><span class="line">  path: <span class="string">'params/:pathParam'</span>,</span><br><span class="line">  component: Params,</span><br><span class="line">  props: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url: http://127.0.0.1:8080/#/router/params/foo?name=abc</span></span><br><span class="line">props: &#123;</span><br><span class="line">  pathParam: <span class="built_in">String</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样我们就能在组件的 props 属性中拿到 url 对应的动态参数。就像父子组件参数传递一样。</p><h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><p>所谓动态路由，就是以冒号 :xxx 来定义地址某部分的路由，通常是基于 Restful 规范，比如下面使用动态的 id 定义的地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/user/:id"</span>,</span><br><span class="line">    component: User</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>相信经验丰富的你一定遇到过这样的问题：明明地址变了，但组件没有重新进行“刷新”。</p><p>我们可以通过 vue 的生命周期来验证组件是否会重新渲染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$message(<span class="string">'当前组件被创建'</span>);</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  changeRouterUrl() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id++;</span><br><span class="line">    <span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'/router/'</span> + <span class="keyword">this</span>.id &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我每次通过 button 触发 changeRouterUrl 方法来进行 id 的累加使得 url 发生变化。但 created 一直没有执行第二次。</p><img src="/legacy/2019/12/03/vue-base-router/dynamic.gif" class="" title="一个简单的 gif"><p>那怎么解决的？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我们知道当定义好 Vue.use(Router); 后，我们就能在实例化后的 vue 中，通过 this.\$route 路由对象来获取相关属性了。</p><p>知道这点后，就通过 watch 来监听 \$route 对象即可。</p><p>同时也能用 \$route 中对应的 to、from 概念对应上 watch 接受的 newVal、oldVal 两个变化前后的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$message(<span class="string">'路由更新了，你可以在这里做任何事情'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/12/03/vue-base-router/watchRouter.gif" class="" title="一个简单的 gif"><p>这样就能在每次动态路由改动时，通过监听 \$route 来自定义需要刷新组件那部分的数据了。</p><h1 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h1><p>这属于路由参数获取外，用的第一多的功能。下面示例 vue-router 中 4 种常见的跳转用法。</p><h2 id="普通跳转"><a href="#普通跳转" class="headerlink" title="普通跳转"></a>普通跳转</h2><p>声明式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"paramsRoute"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>试一试：声明式跳转<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编程式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paramsRoute: &#123; path: '/router/params/foo', query: &#123; name: 'fromJump' &#125; &#125;</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="keyword">this</span>.paramsRoute);</span><br></pre></td></tr></table></figure><h2 id="replace-跳转"><a href="#replace-跳转" class="headerlink" title="replace 跳转"></a>replace 跳转</h2><p>一开始我不太理解 <strong>replace</strong> 有什么用，但当我用到 <strong>element-ui</strong> 中的 <strong>breadcrumb</strong> 面包屑功能时，注意到了其中 <strong>replace</strong> 属性。</p><blockquote><p>replace: 在使用 to 进行路由跳转时，启用 <strong>replace</strong> 将不会向 <strong>history</strong> 添加新记录</p></blockquote><p><strong>有什么用？</strong></p><p>我们都知道路由有 history 功能，每当点击浏览器返回时，将回到之前访问的页面记录。</p><p>假如页面设计有 3 层（首页、产品列表、产品详情页），当从 1 级页面（首页）跳转到 2 级页面（产品列表）后，我们点击浏览器后退按钮一切都正常；但当 2 级页面跳转到 3 级页面（详情页）后，再返回 2 级页面似乎也没问题，<strong>但当你再次返回时，却又回到了 3 级页面</strong>（其实用户想回到最初的 1 级页面，虽然代码上符合逻辑，但现在一定出错了）</p><p>原先我遇到类似问题，都是在最后级页面通过“写死”的路由地址来解决这个 bug，但其实现在有更好的方式，那就是 <strong>replace</strong> 。</p><p>如下是模拟这 bug 的重现：</p><p>tab 从： 路由跳转 –&gt; 动态路由 –&gt; 路由跳转（清除 history） –&gt; 参数传递</p><p>最后 <strong>浏览器返回</strong> 后，路由没有切换到上次访问的路由记录，而是跳到再上次的记录。</p><img src="/legacy/2019/12/03/vue-base-router/replace.gif" class="" title="一个简单的 gif"><p>声明式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意多了个 replace 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"paramsRoute"</span> <span class="attr">replace</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>试一试：声明式跳转<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编程式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.replace(<span class="keyword">this</span>.paramsRoute);</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向概念多数出现在服务器端，但路由中的重定向你一定也见过，虽然原理不同，但最终的“效果”类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">redirect</span>: <span class="string">"/router"</span> &#125;];</span><br></pre></td></tr></table></figure><p>最终你访问 / 时，页面地址会变成 /router ，并渲染 /router 对应的 component。但需注意：浏览器并没有收到类似 3xx 的重定向状态码。</p><h2 id="“前进-后退”-跳转"><a href="#“前进-后退”-跳转" class="headerlink" title="“前进/后退” 跳转"></a>“前进/后退” 跳转</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"$router.go(-1)"</span>&gt;</span>试一试：返回上一级历史页面<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似还有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.back();</span><br><span class="line"><span class="keyword">this</span>.$router.forward();</span><br></pre></td></tr></table></figure><p>他们都是基于 window.history 相关 api 来实现的功能。</p><h1 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h1><p>对于简单的路由，我们模板定义如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以在路由文件 router.js 中定义一堆路由地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/a"</span>,</span><br><span class="line">    component: componentA</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/b"</span>,</span><br><span class="line">    component: componentB</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这些都是一级路由。那路由怎么实现嵌套呢？</p><h2 id="父子路由"><a href="#父子路由" class="headerlink" title="父子路由"></a>父子路由</h2><p>利用 children 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">redirect</span>: <span class="string">"/router"</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/router"</span>,</span><br><span class="line">    component: RouterIndex,</span><br><span class="line">    redirect: <span class="string">"/router/jump"</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">"jump"</span>, <span class="attr">path</span>: <span class="string">"jump"</span>, <span class="attr">component</span>: Jump &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">"nest"</span>,</span><br><span class="line">        path: <span class="string">"nest"</span>,</span><br><span class="line">        component: NestIndex,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">"wrap"</span>,</span><br><span class="line">            path: <span class="string">"wrap"</span>,</span><br><span class="line">            component: NestChild1</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这个例子出现了两个 children ，也就是一个普通的 <strong>三级路由</strong> 形式。</p><img src="/legacy/2019/12/03/vue-base-router/nest.png" class="" title="父子路由嵌套"><h2 id="路由多组件"><a href="#路由多组件" class="headerlink" title="路由多组件"></a>路由多组件</h2><p>有时候会出现一个路由地址中需要出现 sidebar（侧导航栏） 和 main（主内容）两个 view 模块。</p><p>抽象的话，就是存在两个 router-view，这是可以把原先的 component 定义成复数 components，通过 <strong>命名视图</strong> 来完成这样的功能。</p><img src="/legacy/2019/12/03/vue-base-router/peer.png" class="" title="同级路由"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"view"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>路由嵌套<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vv-header</span> <span class="attr">:headers</span>=<span class="string">"headers"</span>&gt;</span><span class="tag">&lt;/<span class="name">vv-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'peer'</span>,</span><br><span class="line">  path: <span class="string">'peer'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="keyword">default</span>: NestChild1,</span><br><span class="line">    left: NestChild2,</span><br><span class="line">    right: NestChild3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先我只在一个父组件中使用一个 router-view ，通过 components 的定义可以出现多个 router-view ，来完成多样的布局可能。</p><h1 id="健壮的路由体系"><a href="#健壮的路由体系" class="headerlink" title="健壮的路由体系"></a>健壮的路由体系</h1><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>守卫这个思想，最初我是在 angular 看到的，然而 vue 里也有对应的概念。但在整个程序设计语言中，还是觉得用 java 里的拦截器描述最为恰当。</p><h3 id="全局前置守卫-beforeEach"><a href="#全局前置守卫-beforeEach" class="headerlink" title="全局前置守卫 beforeEach"></a>全局前置守卫 beforeEach</h3><p>beforeEach 接受 to、from、next 三个参数，前两者分别是路由对象，代表到哪里去、从哪里来。</p><p>next 是整个方法最后 resolve 的回调钩子。如果始终没有在这方法中执行，那么永远进入不到后续路由中。</p><p>我们能在里面做什么？看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截</span></span><br><span class="line">routers.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 特定路由做验证</span></span><br><span class="line">  <span class="keyword">if</span> (to.name == <span class="string">"guard"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"验证用户登录"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以对需要的路由做个判断，目标地址如果是需要用户授权的页面，可以在这里统一的做用户信息的判断，来决定是否“放”到后续 to 路由。</p><h3 id="全局后置路由-afterEach"><a href="#全局后置路由-afterEach" class="headerlink" title="全局后置路由 afterEach"></a>全局后置路由 afterEach</h3><p>这是一个 to 路由跳转后，执行的路由方法。与 beforeEach 不同，它不具备 next 参数，也就不具备“守卫”功能。</p><p>我们可以统一在此处做些状态信息的处理，以便 component 能更好的处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routers.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"路由请求结束"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h3><p>在 afterEach 之前被调用，当路由组件被解析后则触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routers.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"beforeResolve 路由解析"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="路由独享的守卫-beforeEnter"><a href="#路由独享的守卫-beforeEnter" class="headerlink" title="路由独享的守卫 beforeEnter"></a>路由独享的守卫 beforeEnter</h3><p>上面这两个都是全局范围的，如果只想让某个特定路由执行特殊“任务”，可以在路由定义上使用 beforeEnter，它和 beforeEach 一样具备守卫功能，即可以调用 next：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'notFound'</span>,</span><br><span class="line">  path: <span class="string">'*'</span>,</span><br><span class="line">  component: NotFound,</span><br><span class="line">  beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">from</span>, <span class="string">'error'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件内的守卫-beforeRouteXXX"><a href="#组件内的守卫-beforeRouteXXX" class="headerlink" title="组件内的守卫 beforeRouteXXX"></a>组件内的守卫 beforeRouteXXX</h3><p>为了更细粒度的控制组件的交互，vue-router 也提供了组件内部的路由方法，他们和 data、methods 等组件属性一样使用。</p><p>使用示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 组件还未进入前触发，注意：无法使用 this 来调用相关方法</span></span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"component beforeRouteEnter"</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 动态路由切换地址时才会触发</span></span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"component beforeRouteUpdate"</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 准备跳转其他路由时触发</span></span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"component beforeRouteLeave"</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路由执行顺序"><a href="#路由执行顺序" class="headerlink" title="路由执行顺序"></a>路由执行顺序</h3><p>分两块：不同路由切换、动态路由切换</p><p>记肯定记不住的，我画了一个简单的图供参考：</p><img src="/legacy/2019/12/03/vue-base-router/router-order.png" class="" title="路由顺序"><h2 id="设置路由名称"><a href="#设置路由名称" class="headerlink" title="设置路由名称"></a>设置路由名称</h2><p>我们知道每个路由 router 具备 path、component 这两个基础属性，同常我们一个项目里可能所有的路由都是这两个属性。</p><p>但你有没有设置过 路由名称？我个人以前是没有用过，因为不知道其中的好处。</p><p>它的用法很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这个 name 属性</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'dynamic'</span>, <span class="attr">path</span>: <span class="string">':dynamic'</span>, <span class="attr">component</span>: DynamicRouter &#125;</span><br></pre></td></tr></table></figure><p>你注意到他只是比普通路由多了个 name 属性，但会给整个开发体验上带来一丝“温暖”。</p><p>为什么？</p><p>以前我们可能直接在路由的跳转中明确写出目标路由的 path ，但这个 path 是极有可能因为疏忽大意少个斜杠或者单词拼写错误而无法跳转，如果没有较完善的测试机制可能很难发现。</p><p>现在这个 name 属性会提高我们路由的相对稳定性，也有助于我们的开发效率：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">"dynamic"</span>, <span class="attr">params</span>: &#123; <span class="attr">dynamic</span>: <span class="number">1</span> &#125; &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="动态路由的顺序问题"><a href="#动态路由的顺序问题" class="headerlink" title="动态路由的顺序问题"></a>动态路由的顺序问题</h2><p>越来越多的接口是基于 Restful 规范，这样会使得我们出现很多动态路由。但由于各种地址的设计问题，会存在其他路由被这个动态路由覆盖的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'jump'</span>, <span class="attr">path</span>: <span class="string">'jump'</span>, <span class="attr">component</span>: Jump &#125;</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'dynamic'</span>, <span class="attr">path</span>: <span class="string">':dynamic'</span>, <span class="attr">component</span>: DynamicRouter &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你能想象把上述两则路由的顺序颠倒的后果吗？那么永远都不会再触发 jump 路由了。</p><p>有幸，我们的 vue-router 基于先定义先执行的原则，相比后端 springboot 一些路由问题解决起来轻松愉快多了。只需要平时多注意些。</p><h2 id="异步路由加载"><a href="#异步路由加载" class="headerlink" title="异步路由加载"></a>异步路由加载</h2><p>经验丰富的我们都清楚，所有 js 打包在一个 bundle 是非常消耗服务器资源的，这毕竟是现代单页面应用的通病。</p><p>设置一个菊花 loading 图来让用户体验更加好些，但可以通过路由＋ webpack 的打包机制，利用路由异步动态加载所需要的组件 js，达到优化效果更佳。</p><p>现代构建工具已经帮我们把 api 优化好了，简单使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RouterIndex = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; <span class="built_in">require</span>(<span class="string">"./pages/Router/Index.vue"</span>), <span class="string">"RouterIndex"</span>);</span><br><span class="line"><span class="keyword">const</span> DynamicRouter = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./pages/Router/DynamicRouter.vue"</span>);</span><br><span class="line"><span class="keyword">const</span> NotFound = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./pages/Router/NotFound.vue"</span>);</span><br><span class="line"><span class="keyword">const</span> Params = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./pages/Router/Params.vue"</span>);</span><br></pre></td></tr></table></figure><p>这样能使得整个服务器的负载压力更小些，用户体验也更好。</p><h2 id="404-后备选项"><a href="#404-后备选项" class="headerlink" title="404 后备选项"></a>404 后备选项</h2><p>通常 404 页面都是由服务器后端来提供，但我们简单的项目通常都是单页面应用，并且页面不经过服务端渲染。</p><p>所以对于客户端的异常页面跳转需要有个最后通配的地址来做渲染。使得整个应用“看似”更好些。</p><p>你总不希望你做的页面在用户一通乱点后，出现一个 nginx 提供的 404 Not Found 页面吧？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">component</span>: NotFound &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个很简单的例子，希望能帮到遇到此类问题的同学。</p><p>tips: 如果你需要快速掌握相关 vue 概念，有兴趣可以查看如下项目（当然还在建设中，本文章所有 demo 都处于此处，确保能正常 work ）</p><blockquote><p><a href="https://gitee.com/eminoda/practice/tree/master/vue-demo" target="_blank" rel="noopener">https://gitee.com/eminoda/practice/tree/master/vue-demo</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从事件轮询 Event Loop，看 microTask、macroTask</title>
      <link href="/legacy/2019/11/25/js-event-loop/"/>
      <url>/legacy/2019/11/25/js-event-loop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道执行 javascript 的引擎是单线程的，那么 js 中是按什么顺序处理不同的“异步”事件呢？</p><p>这篇就从一个面试题开始，讲述事件轮循 Event Loop ，以及 microTask、macroTask 的相关概念。</p><h1 id="一个经典的面试题"><a href="#一个经典的面试题" class="headerlink" title="一个经典的面试题"></a>一个经典的面试题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">log(data);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  data = <span class="number">6</span>;</span><br><span class="line">  log(data);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  data = <span class="number">5</span>;</span><br><span class="line">  log(data);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    data = <span class="number">3</span>;</span><br><span class="line">    log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    data = <span class="number">4</span>;</span><br><span class="line">    log(data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">data = <span class="number">2</span>;</span><br><span class="line">log(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出顺序为：1,2,3,4,5,6</p><h1 id="事件轮询-Event-Loop"><a href="#事件轮询-Event-Loop" class="headerlink" title="事件轮询 Event Loop"></a>事件轮询 Event Loop</h1><p>在解释 Event Loop 前，我们先了解下 js 的执行栈。</p><h2 id="执行栈-Call-Stack"><a href="#执行栈-Call-Stack" class="headerlink" title="执行栈 Call Stack"></a>执行栈 Call Stack</h2><p>我们知道程序中的函数定义，参数都会被放到一个执行栈 stack 中。如下就是个很普通的一段程序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"baz"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  bar();</span><br><span class="line">  baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>最后会按顺序输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo;</span><br><span class="line">bar;</span><br><span class="line">baz;</span><br></pre></td></tr></table></figure><p>栈图如下：</p><img src="/legacy/2019/11/25/js-event-loop/callstack.png" class="" title="摘自：flaviocopes"><p>整个程序，按照<strong>先进后出的队列</strong>（LIFO queue）进行栈的操作。foo 优先被调用塞进栈内，随后对内部的 bar 进行入栈，执行后再出栈，baz 类似 ，内部方法全部执行结束后 foo 出栈，清空该栈。</p><p>整个顺序和我们预期的一样，那如果涉及 setTimout 的话，整个过程会怎么样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"baz"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  <span class="comment">// 只是将 bar 定义在 setTimout 中</span></span><br><span class="line">  setTimeout(bar, <span class="number">0</span>);</span><br><span class="line">  baz();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>栈图如下：</p><img src="/legacy/2019/11/25/js-event-loop/callstack-event.png" class="" title="摘自：flaviocopes"><p>注意上图中 setTimout 的那部分，虽然在 foo 进栈后，setTimout 紧接着进栈，但随后并没有 pending 住等待它的执行结束。就像它只是进来注册下，然后马上 baz 跟了进来。当 baz 和最外层的 foo 执行结束后，setTimout 中的 bar 才出现在栈中，开始 bar 的执行操作。</p><p>那 setTimout 注册后，被藏到哪里去了？内部的方法又是怎么被再次出现？</p><p>这个就涉及 js 的 Event Loop 机制。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>javascript 运行时，会同步方式挨个在执行栈中执行我们代码，就像上例中没有 setTimout 的例子。</p><p>同时还有一个分支，叫做消息队列。当执行栈内没有代码执行后，会遍历该消息队列，把达到要求的方法放到执行栈来执行，并不停轮询。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">  queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似上述通过 while 来轮询的代码，以达到事件循环的机制就称为事件轮循 Event Loop。</p><p>也就解释了上例中，setTimeout 第一次进来后，它被放到了哪里（消息队列中）。当执行栈没有执行的代码后，循环该消息队列，取出了 setTimeout 中的 bar 方法放到执行栈中运行。</p><h1 id="microTask-和-macroTask"><a href="#microTask-和-macroTask" class="headerlink" title="microTask 和 macroTask"></a>microTask 和 macroTask</h1><p>回到最初的面试题，到此你应该大致明白了“普通” js 和 setTimout 的执行顺序问题。</p><p>那什么是 microTask 和 macroTask 呢？</p><p>该消息队列又对其中的消息类型进行了分类，微任务和宏任务。</p><p>macroTask</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI render</li><li>http</li></ul><p>microTask</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li><li>MutationObserver</li></ul><p>microTask 还是属于当前 js 线程的，不同于 macroTask 像 setTimeout 会单独启用一个 Timer 线程来执行当前任务，它会涉及多个线程互相通讯的问题。</p><p>另外 microTask 只是会比“普通”的 js 执行延后而已，但优先于 macroTask。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://flaviocopes.com/javascript-event-loop/" target="_blank" rel="noopener">javascript-event-loop</a></li><li><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础- $nextTick 使用的场景</title>
      <link href="/legacy/2019/11/25/vue-base-nextTick/"/>
      <url>/legacy/2019/11/25/vue-base-nextTick/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><p>在开发时，是不是遇到过这样的场景，响应数据明明已经更新，但无法通过 dom 获取到。最后使用 nextTick 方法“包裹”后就能拿到。如果你不太清楚其中的原因，这篇或许能解开你的疑惑。</p><h1 id="先来看个例子"><a href="#先来看个例子" class="headerlink" title="先来看个例子"></a>先来看个例子</h1><p>这个例子很简单，主要来测试 nextTick 的作用。</p><p>定义了一个异步数据获取的方法 asyncDataFetch ，你可以把它当成一个接口请求，在执行 updateMsg 后，调用该方法，并最后通过 \$refs 的方式来获取页面上的文本。</p><img src="/legacy/2019/11/25/vue-base-nextTick/demo-html.png" class="" title="页面模板"><img src="/legacy/2019/11/25/vue-base-nextTick/demo-methods.png" class="" title="方法定义"><p>虽然我们已经把接口返回的数据赋值给 this.asyncData ,但实际却没有在 \$refs 中获取到 （html-2）。</p><p>从调试 console 中看到，其在 nextTick 方法中（html-3）被成功获取。</p><img src="/legacy/2019/11/25/vue-base-nextTick/demo.png" class="" title="浏览器输出"><h1 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h1><blockquote><p>为什么例子中，明明把数据赋值给响应对象，但 html-2 中却没有更新呢？</p></blockquote><p>这其实要回到 <strong>vue 异步更新队列</strong> 的解释中，查看原因。</p><p>虽然我们通过 this.someData = ‘new value’ 执行了赋值，但该响应数据并不是同步响应到页面模板中（即更新到页面 Dom 里）。</p><p>vue 更新 Dom 是一个异步过程，所以即使我们看到页面的渲染虽然被“刷新”了，但其实并不是数据一刷新，页面就被刷新，这尤其需要我们注意。</p><p>在这个异步队列中，vue 会根据不同的“异步” api 的支持情况来选择以最佳的方式执行 tick 。这些 api 包括：Promise、MutationObserver、setImmdiate、setTimeout。如果你了解浏览器的事件循环机制，将会对理解这个异步队列容易许多。</p><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><p>好，知道 vue 中数据的更新时异步这一个概念后，那么为什么在 nextTick 执行相关代码能达到预期效果就基本知道大概了。</p><p>如下是一段 nextTick 相关源码片段，你可以在 vue\src\core\util\next-tick.js 找到：</p><img src="/legacy/2019/11/25/vue-base-nextTick/nextTick.png" class="" title="源码"><p>它会有什么作用呢？</p><p>一旦调用了 nextTick ，就会把我们定义的 callback 函数方法推到 callbacks 这样一个全局变量中，这个 callbacks 就是 <strong>异步更新队列</strong>。</p><p>然后会执行 timerFunc 一个异步 tick 方式封装。</p><p>如果当前客户端不支持 Promise、MutationObserver 等 api 方法时，将采用 setTimeout 后备方式：</p><img src="/legacy/2019/11/25/vue-base-nextTick/callbacks-execute.png" class="" title="setTimeout 方式"><p>当 vue 开始执行更新相关操作时，通过 flushCallbacks 方法来“清空”这个队列，内部执行每个队列元素：</p><img src="/legacy/2019/11/25/vue-base-nextTick/callbacks.png" class="" title="源码"><p>由于操作 dom 的成本非常高， vue 在数据 watch 层做了很多优化来处理整个过程的计算操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了为何使用 nextTick 能解决开发中一些“奇怪”的问题，并抛出 vue 的异步事件队列这个概念来解释这个原因。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 安装 node-gyp 报错：解决 electron 调用 canvas</title>
      <link href="/legacy/2019/11/22/node-gyp-canvas-electron/"/>
      <url>/legacy/2019/11/22/node-gyp-canvas-electron/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日做个 electron 项目，涉及使用 canvas 模块。然后调用 canvas 时，就报如下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx canvas.node was compiled against a different Node.js version using</span><br><span class="line">NODE_MODULE_VERSION <span class="number">72.</span> This version <span class="keyword">of</span> Node.js requires</span><br><span class="line">NODE_MODULE_VERSION <span class="number">75.</span> Please <span class="keyword">try</span> re-compiling or re-installing</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/22/node-gyp-canvas-electron/different-version.png" class=""><p>现代浏览器中 canvas 只是个普通的 api ，我们直接用就行了。但在 node 端，一切就变得不怎么容易了。</p><p>我尝试通过 nvm 更新 node 版本（12.13.1），结果如上图，NODE_MODULE_VERSION 还是比 electron 的低。</p><p>看样子这个问题没那么容易，接下来就开始了“漫长”的环境配置过程，接下来我会对每个阶段的插件安装过程做详细描述。</p><h1 id="electron-rebuild"><a href="#electron-rebuild" class="headerlink" title="electron-rebuild"></a>electron-rebuild</h1><p>遇到问题找官网，electron 文档上的确有一篇些关于<a href="https://electronjs.org/docs/tutorial/using-native-node-modules" target="_blank" rel="noopener">“使用 Node 原生模块”</a>的文章。</p><blockquote><p>Electron 支持原生的 Node 模块，但由于 Electron 非常有可能使用一个与您的系统上所安装的 Node 不同的 V8 引擎，您所使用的模块将需要被重新编译。</p></blockquote><p>然后我兴冲冲的安装了 <strong>electron-rebuild</strong> ，原以为问题到此结束。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev electron-rebuild</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每次运行<span class="string">"npm install"</span>后，也运行这条命令</span></span><br><span class="line">./node_modules/.bin/electron-rebuild</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在windows下如果上述命令遇到了问题，尝试这个：</span></span><br><span class="line">.\node_modules\.bin\electron-rebuild.cmd</span><br></pre></td></tr></table></figure><p>结果这只是开始：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/rebuild-failed.png" class=""><h1 id="node-gyp-安装"><a href="#node-gyp-安装" class="headerlink" title="node-gyp 安装"></a>node-gyp 安装</h1><p>错误都是从 <strong>node-gyp</strong> 报出来的，也就是说 canvas 是个原生模块（非 js 语言的第三方插件）。</p><p>自打我第一次用 node.js 起，sass 的安装就差点让我从入门到放弃，就是因为这个“臭名昭著”的 <strong>node-gyp</strong> 。</p><p>以前 sass 的问题可以通过 cnpm 解决，但这次不同，不得不把 <strong>node-gyp</strong> 的环境整一整了。</p><h2 id="windows-build-tools"><a href="#windows-build-tools" class="headerlink" title="windows-build-tools"></a>windows-build-tools</h2><p>node-gyp 需要些三方的支持（Visual C++，python …），当然市面上有集成好的工具，让我们快速的准备好这些环境。</p><p>这个就是 <strong>windows-build-tools</strong> ，一个用于 windows 平台的环境构建工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global windows-build-tools</span><br></pre></td></tr></table></figure><p>只要我们把它安装在全局即可，稍作等待，后续它为我们安装好一系列的插件：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/tools.png" class=""><h2 id="python-字符设置"><a href="#python-字符设置" class="headerlink" title="python 字符设置"></a>python 字符设置</h2><p>虽然 <strong>windows-build-tools</strong> 为我们安装了 <strong>python</strong> ，但为了避免不必要的麻烦，我建议你事先安装好 python2 。</p><p>后续执行 electron-rebuild 还会遇到 <strong>字符编码的错误</strong>，下面我来说下怎么处理（虽然临时学的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: <span class="string">'ascii'</span> codec can<span class="string">'t decode byte 0xe5 in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure><p>当你遇到编码问题时，你需要把默认的 ascii 编码设置为 gkb （如果你设置 utf8 没用的话）</p><p>不可能每个文件都设置编码，对此我们需要全局范围内修改 python 的编码模式。那怎么做呢？</p><p>找到对应 python 的目录，在 xxx\Python27\Lib\site-packages 下，新建文件 <strong>sitecustomize.py</strong> ，内容如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set system default encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys) <span class="comment"># 可能不需要</span></span><br><span class="line">sys.setdefaultencoding(<span class="string">'gbk'</span>)</span><br></pre></td></tr></table></figure><p>最后你可以通过命令行试下是否生效：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/python-encoding.png" class=""><h2 id="GTK2"><a href="#GTK2" class="headerlink" title="GTK2"></a>GTK2</h2><p>node-gyp 后续还需要 GTK2 和 libjpeg-turbo 插件的支持，相比前面基本没什么难度，只要“仔细”些。</p><p>node-canvas 只是基于 cairo 的实现，同时为了让 electron-rebuild 能重新编译 canvas ，则需要包含 cairo 的运行时代码，而这些是由 GTK 提供。</p><p>你只要到官方提供的网站下载即可：</p><ul><li>win32<ul><li><a href="http://ftp.gnome.org/pub/GNOME/binaries/win32/gtk+/2.24/gtk+-bundle_2.24.10-20120208_win32.zip" target="_blank" rel="noopener">http://ftp.gnome.org/pub/GNOME/binaries/win32/gtk+/2.24/gtk+-bundle_2.24.10-20120208_win32.zip</a></li></ul></li><li>win64<ul><li><a href="http://ftp.gnome.org/pub/GNOME/binaries/win64/gtk+/2.22/gtk+-bundle_2.22.1-20101229_win64.zip" target="_blank" rel="noopener">http://ftp.gnome.org/pub/GNOME/binaries/win64/gtk+/2.22/gtk+-bundle_2.22.1-20101229_win64.zip</a></li></ul></li></ul><p>为了避免不必要的麻烦，一定注意如下两点：</p><ul><li>明确所属电脑是 32 位还是 64 位</li><li>点击下载的 exe 后，后续操作全局采取默认配置</li></ul><p>当然你直接编译，还是会出错，因为还需要个 libjpeg-turbo ：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/jpeg.png" class=""><h2 id="libjpeg-turbo"><a href="#libjpeg-turbo" class="headerlink" title="libjpeg-turbo"></a>libjpeg-turbo</h2><p>为了能支持 JPEG 格式的文件，还需要 libjpeg-turbo 插件，同样安装也很简单。</p><p><a href="https://sourceforge.net/projects/libjpeg-turbo/files/" target="_blank" rel="noopener">下载地址</a> ：</p><p><a href="https://sourceforge.net/projects/libjpeg-turbo/files/2.0.0/libjpeg-turbo-2.0.0-vc.exe/download" target="_blank" rel="noopener">https://sourceforge.net/projects/libjpeg-turbo/files/2.0.0/libjpeg-turbo-2.0.0-vc.exe/download</a></p><p>为了避免不必要的麻烦，一定注意如下两点：</p><ul><li>请选择 2.0.0 中的 vc.exe 版本</li><li>区别 GTK2 插件，不要选择对应的 32 或者 64 位对应的版本，因为后面实际运行中，会出现文件找不到的问题</li></ul><h2 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h2><p>一切顺利的话，你将在 C 盘中看到如下两个新目录：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/result.png" class=""><p>最后在执行 electron-rebuild 的重新编译命令：</p><img src="/legacy/2019/11/22/node-gyp-canvas-electron/success.png" class=""><p>ok，node-canvas 编译成功，后续调用没有再报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇可能阅读下来不足 5 分钟，但实际解决这个问题，我是花了整个下午。个人是非常厌倦解决这类环境问题，但侧面也反应出自己知识面的浅薄，毕竟只会 js 。</p><p>最后希望能帮助到类似问题的同学，如果你克服了这问题，可以点个赞哟。</p><p>另外，如果你 cmd 控制台出现乱码问题，可以试下控制台直接运行： chcp 65001 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://github.com/Automattic/node-canvas/wiki/Installation:-Windows" target="_blank" rel="noopener">node-canvas windows</a></li><li><a href="https://github.com/nodejs/node-gyp#on-windows" target="_blank" rel="noopener">node-gyp windows</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 页面重定向 redirect</title>
      <link href="/legacy/2019/11/18/http-redirect/"/>
      <url>/legacy/2019/11/18/http-redirect/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>页面的重定向想必大家都知道，如果你是用过 koa ，那么通过如下代码，就能让网页跳转至指定页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forceLogin) &#123;</span><br><span class="line">  ctx.redirect(<span class="string">"/user/login?backUrl="</span> + <span class="built_in">decodeURIComponent</span>(ctx.path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者你用过 java 的重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"redirectUrl"</span>);</span><br></pre></td></tr></table></figure><p>那么框架内部到底是怎么实现页面重定向的呢？这篇小短文可能会让你更加清楚其中的一些原理。</p><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当你在浏览器访问 A 地址时，你会看到浏览器会刷新进度条，地址栏被更新为 B 地址。这就是 URL 重定向。</p><p>这样类似的技术，就是由 Http 协议定义的。重定向操作是由服务端向客户端发送特定的响应状态来触发，这类状态有个专门的状态码：3xx ，当浏览器接收后，将会进行页面的重定向，即地址发生了跳转。</p><h2 id="几种状态码"><a href="#几种状态码" class="headerlink" title="几种状态码"></a>几种状态码</h2><table><thead><tr><th>状态码</th><th>含义</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久重定向</td><td>网站重构。方法变更为 Get</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>永久重定向</td><td>方法和消息主体都不发生变化</td></tr><tr><td>302</td><td>Found</td><td>临时重定向</td><td>页面暂不可用。方法变更为 Get</td></tr><tr><td>303</td><td>See Other</td><td>临时重定向</td><td>用于 PUT 或 POST 请求后，方法变更为 Get ，消息主体会丢失</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向</td><td>方法和消息主体都不发生变化</td></tr><tr><td>300</td><td>Multiple Choice</td><td>特殊重定向</td><td>多种重定向选择</td></tr><tr><td>304</td><td>Not Modified</td><td>特殊重定向</td><td>配合缓存头，实现资源缓存，和重定向没有关系</td></tr></tbody></table><h2 id="302-和-301-的区别"><a href="#302-和-301-的区别" class="headerlink" title="302 和 301 的区别"></a>302 和 301 的区别</h2><p>上面列了许多 3xx 的状态码，但平时我们最多用的是 301 和 302，这里就详细解释这两个的区别：</p><h3 id="301"><a href="#301" class="headerlink" title="301"></a>301</h3><p>永久重定向。如果 A 地址被 301 到 B 地址后，后续再次请求 A 地址的话，浏览器就会默认首次请求 B 地址，不会再有 A 地址的请求。</p><img src="/legacy/2019/11/18/http-redirect/301.png" class=""><p>等看到第一次访问 /api/books/111 时，页面被重定向到 /api/books，浏览器发送两次请求。但后续再次请求 /api/books/111 时，直接请求了 /api/books 。</p><p>所以通常该状态码用于网站重构，告知搜索引擎你以后访问我 301 重定向的地址。</p><h3 id="302"><a href="#302" class="headerlink" title="302"></a>302</h3><p>相反，302 就是临时重定向。</p><p>平时我们登陆页面的授权跳转都是基于此状态码。因为客户端访问的页面是临时不可用，满足了某些条件后，可以继续使用。</p><img src="/legacy/2019/11/18/http-redirect/302.png" class=""><p>对比 301 的请求，能看到两次 /api/books/222 的请求都被“记录在案”。</p><h1 id="koa-中的重定向"><a href="#koa-中的重定向" class="headerlink" title="koa 中的重定向"></a>koa 中的重定向</h1><p>来看下 koa 中 response 的 redirect 的重定向源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">redirect(url, alt) &#123;</span><br><span class="line">  <span class="comment">// location 设置 location 请求头</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'back'</span> == url) url = <span class="keyword">this</span>.ctx.get(<span class="string">'Referrer'</span>) || alt || <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'Location'</span>, url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status 默认 302 状态码</span></span><br><span class="line">  <span class="keyword">if</span> (!statuses.redirect[<span class="keyword">this</span>.status]) <span class="keyword">this</span>.status = <span class="number">302</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据不同访问类型，设置不同 body 的返回内容</span></span><br><span class="line">  <span class="comment">// html</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.ctx.accepts(<span class="string">'html'</span>)) &#123;</span><br><span class="line">    url = <span class="built_in">escape</span>(url);</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'text/html; charset=utf-8'</span>;</span><br><span class="line">    <span class="keyword">this</span>.body = <span class="string">`Redirecting to &lt;a href="<span class="subst">$&#123;url&#125;</span>"&gt;<span class="subst">$&#123;url&#125;</span>&lt;/a&gt;.`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// text</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'text/plain; charset=utf-8'</span>;</span><br><span class="line">  <span class="keyword">this</span>.body = <span class="string">`Redirecting to <span class="subst">$&#123;url&#125;</span>.`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到在这段重定向的代码中，分别设置了 location 和 状态码，依靠他们来完成重定向的功能。</p><p>当然我们可以自己简单的实现一个服务器重定向功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url = req.url;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="string">"/redirect"</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">        Location: <span class="string">"/goHere"</span></span><br><span class="line">      &#125;);</span><br><span class="line">      res.write(<span class="string">"ready redirect"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="string">"/goHere"</span>) &#123;</span><br><span class="line">      res.write(<span class="string">"&lt;head&gt;&lt;meta charset='utf-8'/&gt;&lt;/head&gt;&lt;h1&gt;我是重定向后的页面&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你只是单纯的使用框架的 redirect api，而不清楚其内部的原理，可能这篇会帮助你了解更多些。毕竟这是 Http 的基础，会让你对浏览器的重定向有个概念。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础- mixins 多继承方式的代码复用</title>
      <link href="/legacy/2019/11/18/vue-base-mixins/"/>
      <url>/legacy/2019/11/18/vue-base-mixins/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><p>先前讲过选项/组合中的 extends 属性，他属于一种单继承方式，我们已经能享受到它给我带来的代码复用“福利”。这里再介绍下和它类似的属性 mixins 。</p><h1 id="mixins-使用"><a href="#mixins-使用" class="headerlink" title="mixins 使用"></a>mixins 使用</h1><p>类型可是：Array&lt;Object></p><p>mixins 接受一个混入对象的数组，该混入对象可以使用正常 Vue 定义的那些选项。如果你的混入包含一个钩子而创建组件本身也有一个，两个函数都将被调用。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>这是 mixins 定义，里面定义了一个钩子函数 created ，和默认 methods。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"parent1 created"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    buttonClick() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"parent1 method click"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个普通的 vue 组件，通过 mixins 混入一些初始化定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mixins1 <span class="keyword">from</span> <span class="string">"../../mixins/preper"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"Home"</span>,</span><br><span class="line">  components,</span><br><span class="line">  mixins: [mixins1],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      banner: &#123;</span><br><span class="line">        height: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      msg: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    buttonClick() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"child method click"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"child created"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看下实际效果：</p><img src="/legacy/2019/11/18/vue-base-mixins/mixins.png" class=""><p>正如官网所说，mixins 上如果定义一些生命周期的钩子函数，默认执行顺序将会合并按照 mixins 先，当前 vue 实例后的顺序执行。</p><p>同时如果有相同的属性，比如 methods 中某个方法命名一致，将会被覆盖。这也是我们要的继承复用效果。</p><h2 id="多个-mixins"><a href="#多个-mixins" class="headerlink" title="多个 mixins"></a>多个 mixins</h2><p>那如果有多个 mixins 会是什么效果？</p><p>我再定义了个差不多的 mixins2 ，来看下实际的输出情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixins: [mixins1, mixins2],</span><br></pre></td></tr></table></figure><p>两个混入对象的钩子方法均得到了调用，并且顺序按照 mixins 的数组顺序执行。</p><img src="/legacy/2019/11/18/vue-base-mixins/mixins2.png" class=""><h1 id="和-extends-的区别"><a href="#和-extends-的区别" class="headerlink" title="和 extends 的区别"></a>和 extends 的区别</h1><p>其实代码效果和 extends 一样，目的都能实现代码继承。区别不同的是 mixins 是接受一个数组形式的对象，换句话说子类能继承多个父类的定义。而 extends 只能继承一个，也就是单继承和多继承的区别。</p><p>不过需要注意的是：extends 和 mixins 的顺序不是那么随意，<strong>extends 优先于 mixins</strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixins: [mixins1, mixins2],</span><br><span class="line">extends: extend,</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/18/vue-base-mixins/mixins3.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>介绍了 mixins 的使用，也通过和 extends 的结合使用来说明这两者的细微不同，这样在代码上使用继承来达到某些代码功能复用时能有个正确的选择判断。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 文件上传</title>
      <link href="/legacy/2019/11/15/node-file-upload/"/>
      <url>/legacy/2019/11/15/node-file-upload/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件上传一个基础服务端功能，比如：上传一张用户头像。</p><p>由于我自己 node api 使用的不多，借这个“文件上传”功能，来了解 node 服务端如何接收客户端的文件，然后存储到服务器上，完成整个功能。</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>先看下流程图：</p><img src="/legacy/2019/11/15/node-file-upload/upload-order.png" class=""><p>通常会有两种简单的场景：</p><ul><li>客户端上传图片，服务端解析后，保存在当前服务器，回告客户端，整个流程结束。</li><li>可能还会有其他服务器需要这个上传文件，这时就涉及两个服务端之间的上传通讯过程。</li></ul><p>下面按照这两个场景，分步看下实际怎么处理：</p><h2 id="解析客户端请求"><a href="#解析客户端请求" class="headerlink" title="解析客户端请求"></a>解析客户端请求</h2><p>必须要提前说的是，浏览器端通常需要通过 form 表单组件来触发上传文件弹框的 <strong>激活</strong>。上传图片的 ajax 还需要添加特定的请求头：<strong>multipart/form-data</strong> 。</p><p>这里使用 <strong>formidable</strong> 这个工具模块，来解析来自客户端 request 中的上传文件，毕竟我们自己写代码解析太麻烦了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formidable = <span class="built_in">require</span>(<span class="string">"formidable"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> form = <span class="keyword">new</span> formidable.IncomingForm();</span><br><span class="line">  <span class="keyword">let</span> fileUploadPath = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    form.parse(ctx.req, <span class="function"><span class="keyword">function</span>(<span class="params">err, fields, files</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// picFile 是上传文件的 key</span></span><br><span class="line">        <span class="keyword">if</span> (files &amp;&amp; files.picFile) &#123;</span><br><span class="line">          <span class="comment">// 保存到服务器</span></span><br><span class="line">          util</span><br><span class="line">            .saveFile(files.picFile)</span><br><span class="line">            .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">              resolve(data);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              reject(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>借助 formidable ，整个请求流的解析还是很方便的。通过 form.parse 就能帮我们拿到上传的资源文件 file 对象，然后我们可以进行下步“文件落地”的操作。</p><h2 id="通过-fs-实现文件落地"><a href="#通过-fs-实现文件落地" class="headerlink" title="通过 fs 实现文件落地"></a>通过 fs 实现文件落地</h2><p>这里简单说下 fs 如何保存 file ，当然如果你比较熟悉 node 的话，可以选择性的跳过。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取文件</span></span><br><span class="line">      fs.readFile(file.path, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 简单的判断文件后缀</span></span><br><span class="line">        <span class="keyword">let</span> ext = file.name.match(<span class="regexp">/\.(?:[a-zA-Z]+$)/</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ext) &#123;</span><br><span class="line">          resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"文件后缀不正确"</span>));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给文件去个新名字，并写到服务器的资源文件路径</span></span><br><span class="line">        <span class="keyword">let</span> tempFileName = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + ext;</span><br><span class="line">        <span class="keyword">let</span> tempUploadDir = path.resolve(process.env.UPLOAD_DIR, tempFileName);</span><br><span class="line">        fs.writeFile(tempUploadDir, data, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          resolve(tempUploadDir);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为服务器的资源处理会比较重要，上例中只是简单的示例如何保存上传资源。实际操作中，需要对上传文件的后缀、大小、以及定期控制文件夹文件数量等有个更为严格的处理。</p><p>以防止服务器被攻击等情况的发生。</p><h2 id="重写-node-请求，发送给后端"><a href="#重写-node-请求，发送给后端" class="headerlink" title="重写 node 请求，发送给后端"></a>重写 node 请求，发送给后端</h2><p>一般情况，我们完成上述两个步骤，基本文件上传的整个流程结束了。但可能 node 服务端只是个中间层，真正的资源落地需要在业务后端存储，这时就需要把上面存在中间层的资源，再次发到后端服务。</p><p>这里用到了 <strong>form-data</strong> 模块，来模拟类似浏览器 form 的提交信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormData = <span class="built_in">require</span>(<span class="string">"form-data"</span>);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/upload'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.append(<span class="string">"picFile"</span>, fs.createReadStream(tempUploadDir));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> respData = <span class="keyword">await</span> yourAxios().request(&#123;</span><br><span class="line">        url: ctx.path,</span><br><span class="line">        method: ctx.method,</span><br><span class="line">        data: formData,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">`multipart/form-data; boundary=<span class="subst">$&#123;formData._boundary&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ctx.body = respData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到在中间层存储的文件路径，通过 fs 转成 ReadStream 并构造成一个 formData。再通过 axios 等 http 服务工具发送给后端服务。</p><p>当然整个请求的 header 和 data 需要符合后端的接收标准（下图，举个例子）：</p><img src="/legacy/2019/11/15/node-file-upload/http-upload.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述是一个较为完整的文件上传说明，希望对此类有问题的同学能有启发作用。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 作为中间层如何转存 cookie</title>
      <link href="/legacy/2019/11/14/node-cookie-transfer/"/>
      <url>/legacy/2019/11/14/node-cookie-transfer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着前后端服务的分离、主业务服务（java）的“下沉”，类似 BFF（Backends For Frontends）架构的雏形越来越多。node.js 一个能跑 js 的运行平台，让越来越多的前端工程师无语言学习障碍的加入了 node 服务端的阵营。</p><p>相信多数团队和我们一样，node 作为一个中间层连通着客户端和后端服务，处理着各种各样的事情。这篇就简单讲下 node 端如何转存 cookie 。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>先说下问题出现的场景，由于前端本来是接口 api 的使用者，导致很多问题没有遇到过，都是后端服务帮我们处理掉的。</p><p>但当 node 介入整个服务体系后，不可避免的就会碰到类似用户登录“失效”这类问题。可以看下如下这图：</p><img src="/legacy/2019/11/14/node-cookie-transfer/miss-cookie.png" class=""><p>注意到后一种方式，node 作为中间层充当着接口的传递者，你一定不会忘记处理来自后端的响应信息，但可能会忘记给客户端设置 cookie （如：红框内容），这样就导致一些忽视的问题。</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>好，再来看下 cookie ，这不是 http 协议里的东西，太简单了吧？的确是基础，但有时我们却会轻视这些东西。借这个机会快速过下：</p><h2 id="http-无状态"><a href="#http-无状态" class="headerlink" title="http 无状态"></a>http 无状态</h2><p>我们都知道 http 是无状态的协议，每次请求服务端根本不知道之前客户端有什么情况。就此，就有 Cookie 这样的机制，传递一些信息来帮助客户端和服务端建立起一定的关系，并持久化到浏览器，每次请求都把 cookie 发送给服务端，服务端解析后做逻辑处理。比如：用户登录等。</p><h2 id="cookie-存储受那些影响"><a href="#cookie-存储受那些影响" class="headerlink" title="cookie 存储受那些影响"></a>cookie 存储受那些影响</h2><p>cookie 存储受 domain、path 的影响（端口除外），你不同的域名、访问地址都会影响到 cookie 的存储。你也不能获取不同域的 cookie 信息，这就是前端经常遇见的 <strong>跨域问题</strong> ，这里不做展开，只希望你特别留一下 domain 和 path 两个属性。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>下图，是一个简单的客户端请求和服务端响应流程：</p><img src="/legacy/2019/11/14/node-cookie-transfer/cookie-pass.png" class=""><p>这里将通过代码来说明如何处理 1、2 两处中间层的交互，来使得最后的 cookie 能顺利给到客户端。</p><blockquote><p>备注：代码基于 koa + axios</p></blockquote><h2 id="中间层接收后端服务-cookie"><a href="#中间层接收后端服务-cookie" class="headerlink" title="中间层接收后端服务 cookie"></a>中间层接收后端服务 cookie</h2><p>首先是服务端向客户端设置 cookie （用户登录成功后，会向客户端设置一个 token 信息，下次从 cookie 获取 token 来验证是否已登录）</p><p>我们已经知道 cookie 是受 domain 和 path 影响的，并且是无状态的。假设，后端的 domain 是写死的，一直是往（foo.com）存的，那么我们就需要在中间层重写 cookie 的 domain 和全部 cookie 信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = <span class="built_in">require</span>(<span class="string">'cookie'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cookies = response.headers[<span class="string">'set-cookie'</span>];<span class="comment">//['uid=1; Domain=foo.com; Path=/','nick=2; Domain=foo.com; Path=/']</span></span><br><span class="line">  <span class="keyword">let</span> targetCookie = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> cookieStr <span class="keyword">of</span> cookies) &#123;</span><br><span class="line">    targetCookie = <span class="built_in">Object</span>.assign(targetCookie, cookie.parse(cookieStr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> cookieKey <span class="keyword">of</span> targetCookie)&#123;</span><br><span class="line">    <span class="comment">// 设置给 ctx</span></span><br><span class="line">    <span class="keyword">this</span>.ctx.cookies.set(cookieKey, targetCookie[cookieKey], &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      domain: your-domain, <span class="comment">// 注意这个！！</span></span><br><span class="line">      httpOnly: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ctx 是 koa 创装的全局对象。先请后端获取响应头中的 cookie 信息，解析出 cookie 的 key-value ，重写到 ctx.cookies 中。</p><h2 id="中间层发送-cookie-到后端服务"><a href="#中间层发送-cookie-到后端服务" class="headerlink" title="中间层发送 cookie 到后端服务"></a>中间层发送 cookie 到后端服务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.create(&#123;</span><br><span class="line">  baseURL: baseURL,</span><br><span class="line">  method: ctx.method,</span><br><span class="line">  timeout: <span class="number">1000</span> * <span class="number">30</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Cookie: ctx.headers[<span class="string">'cookie'</span>] || <span class="string">''</span>,</span><br><span class="line">    Host: ctx.headers[<span class="string">'host'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较容易，通过 ctx.headers 分别获取来自客户端的 cookie 和 host 信息，重新组织好 headers 通过 axios 发送给后端服务。这样后端就知道是哪个域名、哪个 cookie 内容了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>如果后端比较“智能”，可以根据请求端的 host 来动态指定响应的 domain ，那么他不用把 cookie 固定往 foo.com 这个域名存。当然目前我们通过重写 cookie 就替后端完成了这样的操作，并且 cookie 的主导权落在了我们前端的手上。</p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>我们知道可能客户端会携带大量的 cookie 信息，它将严重影响网络请求和响应的速度。</p><p>当我们中间层 node 获得了 cookie 的主导权后，我们完全可以根据业务逻辑来过滤后端不需要的 cookie 信息，从而提升网站的速度。</p><p>比如，后端只需要一个 token 的 cookie 信息，那么我们重写 cookie 的时候就发 token 相关的数据即可。</p><p>虽然前端介入整个服务体系会使得工作量增加，但如果一切得法，会在某种程度减少整个二次开发的成本，通过 node 中间层的各种“协调”，使后端服务更“稳定”。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-生命周期 lifecycle</title>
      <link href="/legacy/2019/11/10/vue-base-lifecycle/"/>
      <url>/legacy/2019/11/10/vue-base-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><p>平时开发中，我真的不太使用生命周期相关的方法。但必须明确的是，生命周期在整个 vue 具有非常重要的作用，如果你了解它将对理解整个 vue 会更容易；同时在遇到问题时也能有个导向性的判断。</p><p>此篇简单说下生命周期的过程，以及方法调用。</p><h1 id="生命周期的整个过程"><a href="#生命周期的整个过程" class="headerlink" title="生命周期的整个过程"></a>生命周期的整个过程</h1><p>借用 vue 官网的图，仔细全览下基本就对生命周期的过程有个粗略的认识了。</p><img src="/legacy/2019/11/10/vue-base-lifecycle/lifecycle.png" class="" title="vue 官网的生命周期图"><p>我这里没必要重复细说了，按我自己理解讲这个过程：</p><ol><li>new 一个 Vue 实例</li><li>初始化 event（$on、$off 等） 和 lifecycle</li><li><strong>触发钩子</strong> beforeCreate</li><li>初始化 inject、data、computed、watch、provide</li><li><strong>触发钩子</strong> created</li><li>判断 el 属性（是否调用 $mount，你在源码能看到两个 $mount 的声明），判断 template 属性（决定渲染模板）</li><li><strong>触发钩子</strong> beforeMount</li><li>替换 el 标签内容，实现元素挂载</li><li><strong>触发钩子</strong> mounted</li><li>definedReactive 响应式的定义在初始化的时候已经完毕了，当数据更新，<strong>触发钩子</strong> beforeUpdate 、 updated</li><li>销毁时，触发钩子 beforeDestroy</li><li>移除事件监听、绑定数据</li><li>销毁完， <strong>触发钩子</strong> destroyd</li></ol><h1 id="钩子触发顺序"><a href="#钩子触发顺序" class="headerlink" title="钩子触发顺序"></a>钩子触发顺序</h1><p>这个例子，调用了所有生命周期的钩子，用来说明他们的执行顺序（注意 activated 和 deactivated 是 keepalive 专用的）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"backgound:#fff;text-align:center;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mt-header</span> <span class="attr">title</span>=<span class="string">"举例"</span> <span class="attr">:fixed</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">mt-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mt-button</span> <span class="attr">type</span>=<span class="string">"default"</span> @<span class="attr">click</span>=<span class="string">"currentComponent = currentComponent == 'vv-button' ? 'vv-button2' : 'vv-button'"</span>&gt;</span>test keepalive<span class="tag">&lt;/<span class="name">mt-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mt-button</span> <span class="attr">type</span>=<span class="string">"danger"</span> @<span class="attr">click</span>=<span class="string">"$destroy()"</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">mt-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:10px;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接看下图，当 created 时，开启一个 timer 定时器用来确认组件的销毁情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'component [Test] '</span>, <span class="string">'created'</span>);</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'component [Test] working ...'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/10/vue-base-lifecycle/lifecycle-hook.gif" class="" title="lifecycle hook 顺序"><img src="/legacy/2019/11/10/vue-base-lifecycle/lifecycle-hook.png" class="" title="lifecycle hook 顺序"><h1 id="有什么细节问题"><a href="#有什么细节问题" class="headerlink" title="有什么细节问题"></a>有什么细节问题</h1><h2 id="beforeCreate-和数据响应式"><a href="#beforeCreate-和数据响应式" class="headerlink" title="beforeCreate 和数据响应式"></a>beforeCreate 和数据响应式</h2><p>因为 beforeCreate 是最开始初始化的，数据响应和相关事件和监听在其后，所以有类似功能处理需要避免。</p><h2 id="created-获取不到-dom-元素"><a href="#created-获取不到-dom-元素" class="headerlink" title="created 获取不到 dom 元素"></a>created 获取不到 dom 元素</h2><p>它是指完成了数据观察、相关属性方法的计算，并没有把我们的模板替换到 html 上，不要试图在这个钩子里调用 dom 相关的 api。</p><p>如果你想获取整个客户端的高度的话，建议放在 mounted 中。</p><h2 id="不要忘记移除掉定时器等"><a href="#不要忘记移除掉定时器等" class="headerlink" title="不要忘记移除掉定时器等"></a>不要忘记移除掉定时器等</h2><p>beforeDestroy 不是没有用，在这环节中，vue 的实例仍然有效，你可以移除定义的 timer ，以免引起不必要的错误。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>生命周期贯穿整个 vue 的设计思想，理解好它能写出让别人能更容易“看得懂的”代码，千万不能张冠李戴的乱用。</p><p>另外上面那张 <strong>vue 整个生命周期的图</strong> ，正如官网所说，随着我们使用的深入，它的意义会越来越大。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-过滤器 filter 和指令 directive 示例</title>
      <link href="/legacy/2019/11/10/vue-base-filter-and-directive/"/>
      <url>/legacy/2019/11/10/vue-base-filter-and-directive/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><p>说下 vue 里过滤器 <strong>filter</strong> 和指令 <strong>directvie</strong> 相关用法。</p><h1 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter 过滤器"></a>filter 过滤器</h1><p>过滤器 <strong>filter</strong> 没什么好说，如果你以前玩过 angular.js ，那么就不会太陌生。通过 <strong>filter</strong> 能对模板上写的数据进行二次加工。</p><p>我们不用通过计算属性 computed，或者某个地方对数据进行新的赋值等操作，在模板上简单的通过 xxx | filter 编写即可。</p><p>通过几个例子来说明用法：</p><h2 id="filter-字典文案"><a href="#filter-字典文案" class="headerlink" title="filter 字典文案"></a>filter 字典文案</h2><p>将通过接口获取到的 value （ number 类型），在前端转换成对应的文案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">"drawStatus"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> types = [<span class="string">"处理中"</span>, <span class="string">"已完成"</span>, <span class="string">"已驳回"</span>, <span class="string">"待放款"</span>, <span class="string">"放款中"</span>, <span class="string">"已撤销"</span>];</span><br><span class="line">  <span class="keyword">return</span> types[value] || <span class="string">"其他"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/10/vue-base-filter-and-directive/filter-value-html.png" class=""><h2 id="filter-时间格式"><a href="#filter-时间格式" class="headerlink" title="filter 时间格式"></a>filter 时间格式</h2><p>一般，后端返回时间存储格式和前端展示会有差异，封装 <strong>moment</strong> 工具库，以过滤器 filter 形式来简化这种格式化操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> value ? moment(value).format(format || <span class="string">"YYYY-MM-DD HH:mm:ss"</span>) : <span class="string">""</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/10/vue-base-filter-and-directive/filter-params-html.png" class=""><p>注意：这个 timeFormat 过滤器示范了如何传递第二个参数。</p><h1 id="directive-指令"><a href="#directive-指令" class="headerlink" title="directive 指令"></a>directive 指令</h1><p>vue 里的指令都默认以 <strong>v-</strong> 开头，像：v-for 、v-if、v-model … 等等。我们也可以自定义指令，根据需要作出不同的功能指令属性，简化 vue 逻辑代码。</p><p>还是先列举几个例子，再开始介绍：</p><h2 id="directive-点击图片自动加载"><a href="#directive-点击图片自动加载" class="headerlink" title="directive 点击图片自动加载"></a>directive 点击图片自动加载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新图片</span></span><br><span class="line"><span class="comment"> * &lt;img alt="" v-reload-img="'/verifyCode.api'" src="/verifyCode.api"&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.directive(<span class="string">"reload-img"</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">    el.src = binding.value ? binding.value : <span class="string">"/verifyCode.api"</span>;</span><br><span class="line">    el.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      el.src = el.src + <span class="string">"?t="</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="directive-根据数据切换不同样式"><a href="#directive-根据数据切换不同样式" class="headerlink" title="directive 根据数据切换不同样式"></a>directive 根据数据切换不同样式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正负红绿样式</span></span><br><span class="line"><span class="comment"> * &lt;span v-red-green="value"&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.directive(<span class="string">"red-green"</span>, &#123;</span><br><span class="line">  componentUpdated: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log('&lt;update&gt;' + binding.value);</span></span><br><span class="line">    <span class="keyword">let</span> setClass = (el.className + <span class="string">" "</span>).replace(<span class="regexp">/color-red|color-green/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (binding.value &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      setClass = setClass + <span class="string">"color-red"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setClass = setClass + <span class="string">"color-green"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    el.className = setClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="directive-模拟路由指令实现跳转"><a href="#directive-模拟路由指令实现跳转" class="headerlink" title="directive 模拟路由指令实现跳转"></a>directive 模拟路由指令实现跳转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页面跳转</span></span><br><span class="line"><span class="comment"> * &lt;li v-go="'/active/center'"&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.directive(<span class="string">"go"</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    el.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      vnode.context.$router.push(binding.value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="钩子函数介绍"><a href="#钩子函数介绍" class="headerlink" title="钩子函数介绍"></a>钩子函数介绍</h2><p>在开始举例前，看下自定义指令里的钩子函数：</p><ul><li>bind<br>只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>inserted<br>被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>update<br>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。需要通过前后值得比较来确定不必要的更新。</li><li>componentUpdated<br>指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li></ul><h2 id="钩子函数触发顺序"><a href="#钩子函数触发顺序" class="headerlink" title="钩子函数触发顺序"></a>钩子函数触发顺序</h2><p>我录制了一个 gif ，分三个阶段来触发钩子函数，希望大家能对钩子函数有个感性认识：</p><ul><li>组件 A 首次加载</li><li>切换组件 B</li><li>再次切换至 A 组件</li></ul><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-hook-order.gif" class="" title="钩子函数执行顺序"><p>能看到指令的 <strong>bind</strong> 、 <strong>inserted</strong> 是在生命周期 <strong>mounted</strong> 之前进行执行的；同时 <strong>unbind</strong> 在组件销毁时触发。</p><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-hook-order.png" class="" title="钩子函数执行顺序"><p>那 <strong>update</strong> 、 <strong>componentUpdated</strong> 呢？</p><p>他们在数据更新时被触发调用，并且是在生命周期 <strong>beforeUpdate</strong> 和 <strong>updated</strong> 之间完成。</p><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-hook-order2.png" class="" title="钩子函数执行顺序"><h2 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h2><ul><li>el：指令所绑定的元素，可进行 dom 操作。</li><li>binding：Object：<ul><li>name：指令名，不包括 v- 前缀。</li><li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li><li>oldValue：指令绑定的前一个值，<strong>仅在 update 和 componentUpdated 钩子中可用</strong></li><li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li><li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li><li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li></ul></li><li>vnode：Vue 编译生成的虚拟节点。</li><li>oldVnode：上一个虚拟节点，<strong>仅在 update 和 componentUpdated 钩子中可用</strong></li></ul><h1 id="指令钩子-inserted-没被插入的原因"><a href="#指令钩子-inserted-没被插入的原因" class="headerlink" title="指令钩子 inserted 没被插入的原因"></a>指令钩子 inserted 没被插入的原因</h1><p>比如我们指令所属标签的子标签内含操作 dom 的指令或者逻辑，比如 v-if</p><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-insert.png" class=""><p>如果我们的 v-if 为 false ，然后你会发现，虽然 insert 被触发了，但页面实际上没有子标签内容的插入，可能你需要避免这方面的 bug 产生。</p><h1 id="指令钩子-update-更新的正确判断"><a href="#指令钩子-update-更新的正确判断" class="headerlink" title="指令钩子 update 更新的正确判断"></a>指令钩子 update 更新的正确判断</h1><p>当我们绑定在指令上的数据发生更新时（数据 从 1 更新为 2），会触发 update 钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding, vnode, oldVnode</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[directive parent]'</span>, <span class="string">`update`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;update&gt;'</span>, <span class="string">'bind-value'</span>, binding.value); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;update&gt;'</span>, <span class="string">'bind-oldValue'</span>, binding.oldValue); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 binding.value 就更新了。</p><p>但注意，下图中的红框内容，虽然当前 vnode 更新了相关元素，但其子 VNode 却没有变化。</p><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-update.png" class=""><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-update2.png" class=""><p>所以当你使用 VNode 做一些更新判断是，就需要根据不同的场景来选择更新模板的契机，以免不必要的无用判断。</p><h1 id="指令钩子-componentUpdated-的错误理解"><a href="#指令钩子-componentUpdated-的错误理解" class="headerlink" title="指令钩子 componentUpdated 的错误理解"></a>指令钩子 componentUpdated 的错误理解</h1><p>这个 hook 让我真不好理解，不过你可以看下别人怎么理解的：</p><blockquote><p><a href="https://stackoverflow.com/questions/50634762/hook-componentupdated-of-vue-directive-not-triggered" target="_blank" rel="noopener">https://stackoverflow.com/questions/50634762/hook-componentupdated-of-vue-directive-not-triggered</a></p></blockquote><p>你要注意到，在官方文档上这个 <strong>及其子 VNode</strong> 是加粗的，这是个“与”判断。首先不能因为只修改了子模板的 VNode 就认为会触发 <strong>componentUpdated</strong> 。</p><p>其次你该理解 <strong>所在组件的</strong> 的真正含义，因为 <strong>componentUpdated</strong> 是说所在组件和子 VNode 被触发，那么如下举例：为什么我在 <strong>componentUpdated</strong> 中取到的两个 ClassName 后的 num 后缀不一样呢？（num 应该同时更新的）：</p><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-componentupdate.png" class=""><img src="/legacy/2019/11/10/vue-base-filter-and-directive/directive-componentupdate-result.png" class=""><p>解释：虽然 <strong>v-my-directive</strong> 指令是写在父模板中，但是写在 <strong>mt-badge</strong> 组件内。当 num 更新，触发 <strong>lifecycle</strong> 中的 <strong>udpate</strong> ，然后接连触发 <strong>update</strong> 和 <strong>componentUpdated</strong> 钩子，但是这个 <strong>mt-badge</strong> 却还没有被触发它的 <strong>lifecycle</strong> 的 <strong>update</strong> （如果每个组件的 update 没有顺序，那还怎么管理数据流），它是在指令 <strong>v-my-directive</strong> 的 componentUpdated 结束后才更新。</p><p>所以指令触发 <strong>componentUpdated</strong> 时， <strong>v-my-directive</strong> 所在组件 VNode 更新了，但子组件的 VNode 还保持原样。</p><p>你可以试下，如果把 <strong>mt-badge</strong> 换成一个普通标签，那取到的 ClassName 就一致了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文列举了过滤器和指令的几种场景运用，给出了 5 个简单的 Demo 示例。同时对指令的 inserted、update 、componentUpdated 做了重点说明。</p><p>原本以为 filter 和 directive 篇幅不会过长，但在说指令中几个钩子时扩展了下。希望各位在开发中遇到问题时能有个更好的判断，如果有帮助就分享给更多的开发者。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础- extends 实现代码复用</title>
      <link href="/legacy/2019/11/08/vue-base-extend/"/>
      <url>/legacy/2019/11/08/vue-base-extend/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><p><strong>extends</strong> 是 <strong>选项/组合</strong> 类别下的选项属性之一，而不是 <strong>Vue.extend</strong> 全局 API，这个事先说下，以免概念上有个混淆。</p><h1 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h1><p>目前的前端有个非常重要的思想，就是“组件化”，对于代码层面就是最终 html、css、js 这些元素都会被挪到一起来实现一个较为完整的功能。就比如 element-ui ，若你想实现一个分页栏，直接拿 &lt;el-pagination> 就可以搞定。</p><p>如果你要对数据进行过滤处理、通过标签有些特殊功能，对应可以自定义一些过滤器、指令。</p><p>这些举例都有个共同的特性就是 <strong>代码复用</strong> 。那些随处可见的好处就不说了。这里提个问题，怎么在 vue 里只针对 js 功能进行复用呢？（可能讲的有些局限）</p><p>答案就是 extends ，一个普普通通的属性，可我在掉了一撮头发后才用到。</p><h1 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h1><p>类型可是：Object | Function</p><p>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。这和 mixins 类似。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>简单举几个例子</p><h2 id="使用在-lifecycle-生命周期上"><a href="#使用在-lifecycle-生命周期上" class="headerlink" title="使用在 lifecycle 生命周期上"></a>使用在 lifecycle 生命周期上</h2><p>有一些需求（例如，控制 mint-ui loadmore 组件的高度），当元素挂载到 dom 节点后，需要控制页面某些区域的固定高度。</p><p>以前我们是这样做的，所有需要控制高度的页面都有这段类似的代码。</p><img src="/legacy/2019/11/08/vue-base-extend/life-js.png" class=""><img src="/legacy/2019/11/08/vue-base-extend/life-html.png" class=""><p><strong>那当使用了 extends 后，就可以简化成：</strong></p><p>使用 extends 调用封装方法 heightControl ，哪个 vue 模块要用就添加这行代码就行了 ：</p><img src="/legacy/2019/11/08/vue-base-extend/life-extends-1.png" class=""><p>heightControl 就是原来的 mounted 中全部的定义：</p><img src="/legacy/2019/11/08/vue-base-extend/life-extends-2.png" class=""><h2 id="简化-methods-方法"><a href="#简化-methods-方法" class="headerlink" title="简化 methods 方法"></a>简化 methods 方法</h2><p>再举一个例子，我们会有注册、忘记密码有获取短信的功能，他们在接口一样，参数类似。那么就会在两个页面上有相似度 99% 的模板化代码（boilerplate code）。</p><img src="/legacy/2019/11/08/vue-base-extend/code-diff.png" class=""><p><strong>那当使用了 extends 后，就可以简化成：</strong></p><img src="/legacy/2019/11/08/vue-base-extend/methods-extends-1.png" class=""><p>重写 methods 属性，将公用获取短信的方法列出，实现一个较为公用化的发送短信功能：</p><img src="/legacy/2019/11/08/vue-base-extend/methods-extends-2.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这两个例子，说了下 extends 简单的场景运用，例子虽少，但的确是我平时优化后觉得很有用的实践。相信通过该属性能让代码的复用性更高，减轻以后的工作量。</p><p>如果你能 get 到其中的点，并觉得此文有帮助，就分享给其他同学吧。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 构建优化 - 提速“10倍”</title>
      <link href="/legacy/2019/11/07/webpack-build-fast/"/>
      <url>/legacy/2019/11/07/webpack-build-fast/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代码构建速度，极为影响开发体验，随着项目代码的增多，原先构建时没有暴露的问题现在倍数级放大。</p><p>你随手改个 css ，js 代码整个项目就要 pending 半分钟之多，简直无法忍受，借这个契机，了解 webpack 构建优化方式，并实践些提速优化方案。</p><h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p>再次声明，当然这篇的目的不是指出业务代码的不足（我都想重构了），而是单从构建角度看能否对构建的编译速度有所提升。</p><p>在优化之前，先说下这个项目的一些细节：</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>jquery：这是一个 PC toB 端的“老”项目，无法割舍部分低版本浏览器的份额（IE 8）</li><li>第三方库： 集成了 juicer、numeral、moment 等常见工具库。</li><li>sass：选用 sass 作为 css 预编译语言。</li></ul><h2 id="目前构建速度"><a href="#目前构建速度" class="headerlink" title="目前构建速度"></a>目前构建速度</h2><ul><li>首次编译：43.8 秒</li><li>再次编译：32 秒</li></ul><p>你能感受到其中的绝望吧？</p><h2 id="文件数量"><a href="#文件数量" class="headerlink" title="文件数量"></a>文件数量</h2><p>由于业务需要，此项目除了服务客户的基本操作外，还负担 SEO 等需求，一个多页面应用，并且服务端渲染输出。</p><p>构建 entry 入口文件数量约为：53 个</p><h1 id="怎么优化"><a href="#怎么优化" class="headerlink" title="怎么优化"></a>怎么优化</h1><p>你可以随便搜索下，遍地都是 webpack 的构建优化策略，但我们需要根据自己项目的实际情况来分析，来直接切入问题要点。</p><p>介绍两款分析工具：</p><h2 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h2><p><strong>webpack-bundle-analyzer</strong> 是个 webpack 可视化分析工具。利用 <strong>webpack-bundle-analyzer</strong> 先看下目前项目各个模块的情况。</p><p>它的安装非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 webpack plugins 注入进去</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">"webpack-bundle-analyzer"</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [<span class="keyword">new</span> BundleAnalyzerPlugin()];</span><br></pre></td></tr></table></figure><p>等待 webpack 构建，最后打开默认的 <a href="http://127.0.0.1:8888" target="_blank" rel="noopener">http://127.0.0.1:8888</a> ，查看即可。</p><img src="/legacy/2019/11/07/webpack-build-fast/analyzer.png" class="" title="分析结果"><p>从矩形树图 Treemap 中，我们能大致得到这些信息：</p><ul><li>每个模块文件很大，原始文件目测都 600 kb 以上，即使压缩了也要 130 kb。（对比了手淘的 js 文件，大了五倍以上）</li><li>每个模块内部至少一半是 jquery.js 的依赖</li><li>由于入口文件的数量关系，输出的模块也有 50 个以上</li></ul><h2 id="webpack-自带-profile-分析"><a href="#webpack-自带-profile-分析" class="headerlink" title="webpack 自带 profile 分析"></a>webpack 自带 profile 分析</h2><p>profile 这是 webpack 自带的 options ，直接在运行脚本加入即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --progress --config build-fast/webpack.dev.conf.js --profile --json &gt; profile.json</span><br></pre></td></tr></table></figure><p>它会对每个模块的构建过程进行打点，最后生成一个 json 文件，把这个文件上传至网站 <a href="http://webpack.github.io/analyse/#home" target="_blank" rel="noopener">http://webpack.github.io/analyse/#home</a> 即可分析出整个构建过程的详细数据。</p><img src="/legacy/2019/11/07/webpack-build-fast/profile1.png" class="" title="分析概况"><p>整个构建耗时 43.8 秒。参与的模块总共有 310 个（js、css、image），chunks 54 个，导出的 assets 292 个。</p><img src="/legacy/2019/11/07/webpack-build-fast/profile2.png" class="" title="模块间依赖关系图"><p>整体看，模块的依赖程度还是不小的。</p><img src="/legacy/2019/11/07/webpack-build-fast/profile3.png" class="" title="309个模块的使用情况"><p>就前 20 多个 modules 文件，几乎被所有的 chunks 所使用。</p><img src="/legacy/2019/11/07/webpack-build-fast/profile4.png" class="" title="单模块多 chunks 的使用情况"><p>这图是上图的进一步具体分析，能看到使用最多 modules 的情况（引用次数、大小）</p><img src="/legacy/2019/11/07/webpack-build-fast/profile5.png" class="" title="耗时模块"><p>能看到个别大模块的占用耗时</p><h2 id="汇总下"><a href="#汇总下" class="headerlink" title="汇总下"></a>汇总下</h2><p>根据这两个工具，就已经对这个项目“就诊”完毕了。来看下具体问题：</p><ul><li><p>第三方依赖占比过重</p><p>以 jquery 为主，没有从业务代码剥离出去，并且一个未压缩的 jquery 文件占了至少一半大小空间。</p></li><li><p>没有公共依赖资源</p><p>相当一部分 module 被多个 chunks 多次引用，并且累计大小不可忽视。</p></li><li><p>css 的编译处理</p><p>sass 被 loader 解析时，耗时过长。</p></li><li><p>webpack 版本过低 3.12</p><p>目前 webpack 已到 4x ，5x 都在 beta 阶段，可以考虑升级。</p></li></ul><p>那么根据这几个大点，外加一些优化策略开始对这项目构建进行加速。</p><h1 id="externals-外链第三方依赖"><a href="#externals-外链第三方依赖" class="headerlink" title="externals 外链第三方依赖"></a>externals 外链第三方依赖</h1><p><strong>时间：43.8s -&gt; 40.8s</strong></p><p>externals 是常用优化手段。构建时，将依赖文件相关从 node_modules 导入改为外部链接引用（即 script 标签 cdn 加载方式）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  jquery: <span class="string">'jQuery'</span>,</span><br><span class="line">  $: <span class="string">'jQuery'</span>,</span><br><span class="line">  juicer: <span class="string">'juicer'</span>,</span><br><span class="line">  numeral: <span class="string">'numeral'</span>,</span><br><span class="line">  moment: <span class="string">'moment'</span>,</span><br><span class="line">  echarts: <span class="string">'echarts'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/07/webpack-build-fast/externals.png" class="" title="取出依赖文件后"><p>最大的 js 编译后降到了 421 kb （大小减了 30%）</p><h1 id="替换-css-编译工具"><a href="#替换-css-编译工具" class="headerlink" title="替换 css 编译工具"></a>替换 css 编译工具</h1><p><strong>时间：40.8s -&gt; 35.8</strong><br>用 fast-sass-loader 替换 sass-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'fast-sass-loader?sourceMap=true'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么 fast-sass-loader 那么快？</strong></p><p>fast-sass-loader 将 sass 文件扁平化使 node-sass 不会重复编译同个文件，编译前会对所有的文件进行合并，按照一个大文件进行编译，同时内部有 cache 机制针对每个 entry 文件。</p><p>使用了 fast-sass-loader 就不用使用 resolve-url-loader 来解决 sass-loader 路径引用的问题。</p><h1 id="使用-CommonsChunkPlugin-提取公共代码"><a href="#使用-CommonsChunkPlugin-提取公共代码" class="headerlink" title="使用 CommonsChunkPlugin 提取公共代码"></a>使用 CommonsChunkPlugin 提取公共代码</h1><p><strong>时间：35.8s -&gt; 27.9</strong></p><img src="/legacy/2019/11/07/webpack-build-fast/externals-common.png" class="" title="提取去公共代码后"><p>最大的 js 编译后降到了 285 kb （大小又减了 30%）</p><img src="/legacy/2019/11/07/webpack-build-fast/profile-commonplugins.png" class="" title="模块依赖"><p>模块依赖问题对比刚开始明显减少，继续优化。</p><h1 id="babel-loader-优化"><a href="#babel-loader-优化" class="headerlink" title="babel-loader 优化"></a>babel-loader 优化</h1><p><strong>时间：27.9s -&gt; 21.6s</strong></p><p>设置 babel-loader 编译过程中需要解析的路径，以及排除 node_modules 相关依赖；</p><p>同时加上 cacheDirectory 开启缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">  include:<span class="regexp">/(js)/</span>,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">      presets: [</span><br><span class="line">        [</span><br><span class="line">          <span class="string">'es2015'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loose: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开启多线程"><a href="#开启多线程" class="headerlink" title="开启多线程"></a>开启多线程</h1><p><strong>时间：21.6s -&gt; 18.3s</strong></p><p>使用 happypack plugins ，它将尽可能利用硬件资源，多线程方式来编译代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: [<span class="string">'happypack/loader?id=scss'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">"scss"</span>,</span><br><span class="line">  loaders: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"fast-sass-loader?sourceMap=true"</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽说开启多线程会加快编译的速度，但就目前情况而言减少幅度很少，不像网上那么明显。</p><p>考虑原因是，基本已经优化的差不多了，代码编译已经瞬时可以完成了，不再需要多线程的帮助了。开启多线程还会增加额外的判断。</p><h1 id="优化多页面"><a href="#优化多页面" class="headerlink" title="优化多页面"></a>优化多页面</h1><p><strong>时间：21.6s -&gt; 最低 4s</strong></p><p>大方向似乎没什么可以优化的了，回过头继续思考我们这个项目的形式。此项目是多页面应用，这意味着如果有 50 个 entry 入口文件，那么在使用 html-webpack-plugin 处理对应 chunks 时就会有 50 个插件来工作，他们之间唯一的不同就是 chunks 参数不一样，仅此而已。我已经试过将该插件“停工”后，整个编译时间就几秒，所以必须针对其做一定的优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: template,</span><br><span class="line">  filename: filename,</span><br><span class="line">  chunks: [<span class="string">"vendor"</span>, <span class="string">"runtime"</span>, entry] <span class="comment">// 只是这个 entry 不一样</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>社区有解决方案，你可以试下 <a href="https://github.com/daifee/html-webpack-plugin-for-multihtml" target="_blank" rel="noopener">html-webpack-plugin-for-multihtml</a>，不过即使这样我更想通过简单粗暴的办法来质变它。</p><p>我们的业务模块，大体会分为 A，B，C，D，E …，如果今天开发的需求是涉及 A 的，能不能只编译 A 模块相关的 entry 文件呢？假设分了 5 个大类，那么现在只编译其中的一类，连小学生都知道编译时间就是缩短 5 倍。</p><img src="/legacy/2019/11/07/webpack-build-fast/splitEntry.png" class="" title="模块分割"><p>我录制了一个简单的控制台键入设置，当选择好编译模块后，再执行 npm run build 之类的脚本。</p><img src="/legacy/2019/11/07/webpack-build-fast/cmd.gif" class="" title="inquirer 示范"><p>通过这样可以 0 侵入业务代码，可选择化的编译需要的模块，使编译构建时间主动大幅降低。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然就目前项目构建情况来说优化结果符合预期了（小范围构建已经 <strong>达到秒级</strong>），当然还有很多优化的细节和方向，我这边简单列举下：</p><ul><li><p><a href="https://webpack.js.org/configuration/devtool/#devtool" target="_blank" rel="noopener">devtool</a></p><p>这是 webpack 自带，用于调试时对代码进行 debugger 。</p></li><li><p><a href="https://webpack.js.org/configuration/resolve/#resolve" target="_blank" rel="noopener">resolve</a></p><p>可以对引用的模块进行别名设置，减少路径的搜索负担。</p></li><li><p>cache-loader</p><p>你可以考虑把 loader 工作加到缓存中，你已经看到 babel-loader 里面的 cache 作用有多大。</p></li><li><p>DllPlugin</p><p>个人认为这是个双刃剑，如果要用的话可能在配置上增加复杂度，而且在有 externals 时，最好做个权衡。</p></li><li><p>uglify-parallel</p><p>如果你在代码“丑化”时，遇到了比较大的耗时，可以用下这个插件。</p></li><li><p>webpack 升级</p><p>这个对于老项目冲击会比较大，再没有健全的自动化体系前需要慎重。但如果项目较小，又不想做过多的优化尝试，直接可以试下这方法。</p></li><li><p>hot 热更新</p><p>这可能是另外一个话题了，如果你觉得再次编译也慢的话尝试开启热更新，我这项目由于不想对业务代码做侵入，就暂不尝试。</p><p>如果你有兴趣，可以看下 <a href="http://eminoda.github.io/2019/10/11/webpack-dev-server-hmr/" target="_blank" rel="noopener">探索 webpack-dev-server 的 HMR</a>，希望你一切顺利。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://segmentfault.com/a/1190000012828879" target="_blank" rel="noopener">详解 CommonsChunkPlugin 的配置和用法</a></li><li><a href="https://www.jianshu.com/p/3efc24316533" target="_blank" rel="noopener">多页面 webpack 构建优化不完全指北</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-动画效果</title>
      <link href="/legacy/2019/11/06/vue-base-animate/"/>
      <url>/legacy/2019/11/06/vue-base-animate/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>vue 提供了 transition 组件标签，来对如下特殊的指令或者标签做 <strong>“进入/离开”过渡</strong> 效果：</p><ul><li>v-if</li><li>v-show</li><li>动态组件</li><li>组件 root 节点</li></ul><p>先来看段代码，当点击 button 后，会控制 show 的值来切换 v-if 所要渲染的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>,</span><br><span class="line"><span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> <span class="comment">/* .fade-leave-active below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际效果：</p><img src="/legacy/2019/11/06/vue-base-animate/toggle.gif" class="" title="v-if transition 效果"><p>那动效怎么产生的呢？</p><ol><li><p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</p><ul><li>当显示时：添加样式 xx-enter-active xx-enter-to</li><li>当离开时：添加样式 xx-leave-active xx-leave-to</li></ul><img src="/legacy/2019/11/06/vue-base-animate/enter.png" class=""></li><li><p>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</p></li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)</li></ol><h2 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h2><p>在进入/离开的过渡中，会有 6 个 class 切换：</p><p>v-enter –&gt; v-enter-active –&gt; v-enter-to –&gt; v-leave –&gt; v-leave-active –&gt; v-leave-to</p><img src="/legacy/2019/11/06/vue-base-animate/transition.png" class=""><h2 id="css-过渡-amp-css-动画"><a href="#css-过渡-amp-css-动画" class="headerlink" title="css 过渡 &amp; css 动画"></a>css 过渡 &amp; css 动画</h2><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p>我们可以根据出入场过渡效果，在 css 这样定义：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 元素 enter 过渡整个过程 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 元素 leave 过渡整个过程 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 元素 enter 过渡开始、 leave 过渡结束 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span><br><span class="line"><span class="comment">/* .slide-fade-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上这些都属于 css 过渡的效果。</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>除了过渡效果，我们还能设置 <strong>animation</strong> 标签指定 css 动画效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">0.5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h3><p>当然这两者都是 css 范畴的特效知识，根据实际需要使用。</p><p>不过可能出现 animation 完成，但 transition 还在继续的情况，对于这种情况需要设置 type=animation|transition 来区分 vue 所要监听的类型。</p><p>我们先来看下两种动效单独的使用情况（动画稍显夸张，只为说明现象）：</p><p><strong>animation</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/06/vue-base-animate/animation.gif" class="" title="animation"><p>粉色方框按照 animation 设置的进度，逐步放大，直至结束，用时 1s。<br><strong>transition</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/06/vue-base-animate/transition.gif" class="" title="transition"><p>红框从 300px 缩小至 100px，用时 3s。</p><p><strong>一起使用</strong></p><img src="/legacy/2019/11/06/vue-base-animate/together.gif" class="" title="一起使用"><p>因为动效在时间 duration 中存在重叠交叉，所以会出现上面这样变扭的效果，可以动过 type animation|transition 来指定 vue 监听动效的类型加以控制。</p><p>比如，我们设置了 animation 就 <strong>屏蔽了 transition 的效果</strong>，就会和单使用 animation 一样了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span> <span class="attr">type</span>=<span class="string">"animation"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h2><p>用于配合第三方 animate 类库时使用。可以根据我们的需要细化效果的展示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"custom-classes-transition"</span> <span class="attr">enter-active-class</span>=<span class="string">"animated tada"</span> <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOutRight"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/06/vue-base-animate/custom-enter.png" class=""><h2 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h2><p>可以在标签上绑定过渡各个时期的钩子，通过 js 来调用触发相关事件的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span> <span class="attr">v-on:enter</span>=<span class="string">"enter"</span> <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span> <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span> <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span> <span class="attr">v-on:leave</span>=<span class="string">"leave"</span> <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span> <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line">  <span class="comment">// 进入中</span></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line"></span><br><span class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当与 CSS 结合使用时</span></span><br><span class="line">  <span class="comment">// 回调函数 done 是可选的</span></span><br><span class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line">  <span class="comment">// 离开时</span></span><br><span class="line">  <span class="comment">// --------</span></span><br><span class="line"></span><br><span class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当与 CSS 结合使用时</span></span><br><span class="line">  <span class="comment">// 回调函数 done 是可选的</span></span><br><span class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></span><br><span class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</p><h1 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h1><p>举个多元素过渡的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">v-if</span>=<span class="string">"items.length &gt; 0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>Sorry, no items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>如果存在数据就显示 table 内容，不存在就显示一个无数据的文案，然后通过 transition 动效切换不同效果。</p><p>但是如果当相同标签元素切换时，就需要通过 key 来区分他们的不同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isEditing"</span> <span class="attr">key</span>=<span class="string">"save"</span>&gt;</span></span><br><span class="line">    Save</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button v-else key="save"&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"edit"</span>&gt;</span></span><br><span class="line">    Edit</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果相同元素模板的 key 一致，效果如下：</p><img src="/legacy/2019/11/06/vue-base-animate/key.gif" class="" title="相同 key"><p>注意，这不是期望的效果。可能你会感觉到生硬，因为相同 key 的元素切换时没有过渡效果。</p><p>设置不同 key 后，动效得以生效：</p><img src="/legacy/2019/11/06/vue-base-animate/key2.gif" class="" title="不同 key"><h2 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h2><p>在两个元素切换的时候，可能我们需要更细致的过渡模式，比如上例中：第一个 button 离开，第二个 button 进来之间的过程中，都被重新绘制了，间隙虽然很短，但能明显看到产生了类似滑动的效果（不符合原始意图）。</p><p>vue 提供了 mode 过渡模式：</p><ul><li>in-out：新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><img src="/legacy/2019/11/06/vue-base-animate/key3.gif" class="" title="out-in mode"><p>当使用 out-in mode 时，第二个元素等待第一个元素消失后才入场，使得原始意图符合预期。</p><h1 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h1><p>同时 transition 也可以作用于“动态组件”的过渡效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"component-fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h1><p>与 transition 不同的是，列表过渡需要使用 &lt;transition-group> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"check"</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">tag</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/06/vue-base-animate/group.gif" class="" title="随机添加数字"><p>能注意到这里设置了 tag=’div’ ，可以让最后的列表内容包裹在一个 div 标签内。</p><h2 id="列表排序过渡"><a href="#列表排序过渡" class="headerlink" title="列表排序过渡"></a>列表排序过渡</h2><p>&lt;transition-group> 另一个不同是，可以设置 v-move 属性，类似 v-enter、v-leave。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fade-move &#123; transition: transform 1s; &#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>vue 内置还使用了 FLIP 动画队列，基于数据驱动的方式，能做更多的动画效果展示。这里不再做展开。<a href="https://cn.vuejs.org/v2/guide/transitioning-state.html" target="_blank" rel="noopener">有兴趣请查看官网示例</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单说了 transation 和 transation-group 单元素和多元素的过渡用法，初步对 vue 在动效上的实现有了一点了解。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-组件</title>
      <link href="/legacy/2019/11/06/vue-base-component/"/>
      <url>/legacy/2019/11/06/vue-base-component/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h2 id="复用性"><a href="#复用性" class="headerlink" title="复用性"></a>复用性</h2><p>组件是可复用的 Vue 实例。当你有大堆大堆类似的 html 内容时，就应该考虑用组件来实现。它们都有独立的方法，参数互相不受影响。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>组件的 data 属性需要特殊返回一个 function 函数，而非一个简单的对象字面量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><p>每个组件都需要定义一个组件名称，用在注册组件的时候。注册组件分为全局和局部注册。</p><h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h2><p>这只是个规范问题。可以使用 kebab-case 和 PascalCase 的命名方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component-name"</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">"MyComponentName"</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>全局注册的组件将在任何基于 vue 根实例的模板中生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component-name"</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>全局组件是全局生效的，这会使得打包后增加一些无谓的代码，如果某些页面不需要这组件。所以对于细粒度的需求，局部组件更为适用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">"component-a"</span>: ComponentA,</span><br><span class="line">    <span class="string">"component-b"</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="prop-数据传递"><a href="#prop-数据传递" class="headerlink" title="prop 数据传递"></a>prop 数据传递</h1><p>prop 属性，建立父子组件交换数据的桥梁。</p><h2 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h2><p>camelCase vs kebab-case</p><p>html 是对大小写不敏感的，最终会转成小写字符，如果 prop 这样定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"blog-post"</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">"postTitle"</span>],</span><br><span class="line">  template: <span class="string">"&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>页面中是这样才能解析的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>props 可以是 array or object，其中对象类型的方式可以允许更多的高级选项（如，类型检测、自定义校验、设置默认值）。</p><p>可以通过这样的定义，来指定各自属性的类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果是字符串类型，就可以简写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">"title"</span>, <span class="string">"likes"</span>, <span class="string">"isPublished"</span>, <span class="string">"commentIds"</span>, <span class="string">"author"</span>];</span><br></pre></td></tr></table></figure><h2 id="数据类型的验证判断"><a href="#数据类型的验证判断" class="headerlink" title="数据类型的验证判断"></a>数据类型的验证判断</h2><p>当然我们可以更细化的设置 props 属性，基于对象语法提供了如下选项：</p><ul><li>type: 定义数据类型：String、Number、Boolean、Array、Object、Date、Function、Symbol</li><li>default：默认值，如果父组件没有设置传入值得话。Object 和 Array 必须通过函数的方式返回（因为内部 vue 会通过 call 来调用）</li><li>required：Boolean。设置当前属性是否必选。</li><li>validator：Function。自定义校验函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component"</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">"hello"</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"success"</span>, <span class="string">"warning"</span>, <span class="string">"danger"</span>].indexOf(value) !== <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对应的父组件就需要这样定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">:propA</span>=<span class="string">"propA"</span> <span class="attr">:propB</span>=<span class="string">"propB"</span> <span class="attr">:propC</span>=<span class="string">"propC"</span> <span class="attr">:propD</span>=<span class="string">"propD"</span> <span class="attr">:propE</span>=<span class="string">"propE"</span> <span class="attr">:propF</span>=<span class="string">"propF"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      propA: <span class="number">1</span>,</span><br><span class="line">      propB:<span class="string">'abc'</span>,</span><br><span class="line">      propC:<span class="string">'abc'</span>,</span><br><span class="line">      propD:<span class="number">200</span>,</span><br><span class="line">      propE:&#123;<span class="attr">name</span>:<span class="string">'abc'</span>&#125;,</span><br><span class="line">      propF:<span class="string">'success'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h2><p>你肯定看过这样的错误：Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders.</p><p>意思是不要试图在子组件中修改 prop 的属性值，这样会让子组件意外父级组件的状态，从而导致你的应用的数据流向难以理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    userName:<span class="built_in">String</span></span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">this</span>.userName = <span class="number">123</span>; <span class="comment">// error。vue 不允许在子组件中，再次修改 prop 值的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种方式去变向实现这样的需求：</p><ol><li>在子组件的 data 属性中，新增加一个属性，来代替原 prop 属性的更改</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'userName'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    nickName: <span class="keyword">this</span>.userName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果需要对 prop 进行转换，相当于一个 filter 功能，可以用计算属性来替代</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'userName'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  nickName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userName.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种在对象类型 or 数组类型的数据会失效，依旧会影响到父组件的数据状态，因为 js 变量的引用未发生变化。</p><h2 id="非-prop-属性"><a href="#非-prop-属性" class="headerlink" title="非 prop 属性"></a>非 prop 属性</h2><p>如果在父组件上设置了子组件 prop 中没有的属性，则默认会在父组件上原样展示设置的属性。</p><p>如果你想避免这样非预期的发生，可以在子组件中设置如下属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inheritAttrs: <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><h2 id="子组件向父组件发送事件"><a href="#子组件向父组件发送事件" class="headerlink" title="子组件向父组件发送事件"></a>子组件向父组件发送事件</h2><p>子组件定义将发送到的目标事件名称和数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    check() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'callParent'</span>,&#123;<span class="attr">name</span>:<span class="number">123</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件定义一个 callParentListen 用来接收事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">childComponent</span> @<span class="attr">callParent</span>=<span class="string">'callParentListen'</span> /<span class="attr">childComponent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细你遇到过 camelCase 或 PascalCase 不能识别的问题，这是由于 dom 模板转换做的处理。为了避免这样的情况，最好都把事件名称定义为 <strong>kebab-case</strong>（即 call-parent）</p><h2 id="v-model-在组件上的使用"><a href="#v-model-在组件上的使用" class="headerlink" title="v-model 在组件上的使用"></a>v-model 在组件上的使用</h2><h3 id="input-举例"><a href="#input-举例" class="headerlink" title="input 举例"></a>input 举例</h3><p>首先应该知道 v-model 是一个语法糖，它包含了数据的绑定和事件的定义。</p><p>来看下一个简单的子组件包含 input 元素的实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">input</span>=<span class="string">"$emit('input', $event.target.value)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>prop 会用一个默认的 value 来接收父组件中 v-model 传来的值，并且  input  事件会随着用户输入触发而发送出去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  value: <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 的语法糖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;HelloWorld v-bind:value="searchText" v-on:input="searchText = $event"&gt;&lt;/HelloWorld&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="非-input-事件"><a href="#非-input-事件" class="headerlink" title="非 input 事件"></a>非 input 事件</h3><p><strong>v-model 默认是定义一个 prop 的 value 属性，和 input 的接收事件</strong>。如果在 checkout 等 form 元素时，需要在子组件中特殊指定 model ，来告诉父组件我是 change 的事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"base-checkbox"</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">"value"</span>,</span><br><span class="line">    event: <span class="string">"change"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: <span class="built_in">Boolean</span> <span class="comment">// 注意 checkout 为布尔类型</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      :checked="value"</span></span><br><span class="line"><span class="string">      @change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="组件绑定原生事件"><a href="#组件绑定原生事件" class="headerlink" title="组件绑定原生事件"></a>组件绑定原生事件</h2><h3 id="native"><a href="#native" class="headerlink" title=".native"></a>.native</h3><p>在父组件上，类似这样的事件监听方法，onFocus() 是接收不到 focus 的选中操作的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> @<span class="attr">focus</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但可以通过 .native 修饰符来获取原生事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> @<span class="attr">focus.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过这有个前提，子组件必须是 input 标签，遇到普通标签如 div 就失效了（除非你定义 tabindex=”0” 之类的属性）。</p><h3 id="listeners"><a href="#listeners" class="headerlink" title="\$listeners"></a>\$listeners</h3><p>vue 专门提供了 this.\$listeners 来获取父组件写的事件监听器。来应对上例失效的情况：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父类定义 focus 监听事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span> @<span class="attr">focus</span>=<span class="string">"onFocus"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意这里的这里的 $attrs inputListeners 写法，类似 v-model=xxx --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span> <span class="attr">:value</span>=<span class="string">"value"</span> <span class="attr">v-on</span>=<span class="string">"inputListeners"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 this.\$attrs 获取父组件上的属性定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>, <span class="comment">// 不继承父类属性到 div 标签上</span></span><br><span class="line">  name: <span class="string">"base-input"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 定义 inputListeners ，然后绑定到子组件事件监听上</span></span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        <span class="comment">// 父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">"input"</span>, event.target.value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当 focus 父组件后，就会触发选中方法。</p><p>上例注释已经可以说明问题了。我在针对其中细节补充下：</p><ul><li><p>通过自带的  \$attrs 来获取父组件模板中额外定义的属性，如，type=text</p></li><li><p>定义计算属性 inputListeners  返回一个事件监听对象。这个对象以 this.\$listeners 为基础可以扩展我们自定义的事件方法。（如上图，定义了 input 以用来使得父模板定义的 v-model 的正常工作）</p></li></ul><h3 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h3><p>我们知道 vue 是不建议父子组件来对 prop 的属性做 “双向绑定” 的，但可以通过常规的方法：子向父发送事件来变向完成这样的需求。并推荐以 <strong>update:属性名</strong> 来约定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"update:title"</span>, newTitle);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span> <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种写法官方也提供了修饰器来简化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>甚至于，整个 prop 下的某个对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">"doc"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="插槽-slot"><a href="#插槽-slot" class="headerlink" title="插槽 slot"></a>插槽 slot</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>navigation-link 标签内的 innerHtml 内容，最终会被子组件“吸收”，在 slot 占位符中被替换显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span> <span class="attr">class</span>=<span class="string">"nav-link"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后渲染的 html :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">data-v-7299320c</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">"/profile"</span> <span class="attr">class</span>=<span class="string">"nav-link"</span>&gt;</span>Your Profile<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><p>即：在 navigation-link 标签内部写的内容，虽然会被 slot 替换，但作用域依旧属于父级模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- url 不会显示 /profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h2><p>如果你熟悉 webpack ，那么就很好理解 fallback 后备这词的含义。</p><p>如果父模板未设置相关插槽内容，那么最后默认显示的将以 slot 标签之间的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>为  slot  标签取个名字，因为多样性的模板出现多个想往  slot  替换的模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;base-layout&gt; component --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模板在 slot 定义 name=xxx ，父模板这样定义，通过 <strong>v-slot:name</strong> 来指定往哪里插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h2><p>和 v-bind 和 v-on 类似，只要把 <strong>v-slot:name</strong> 换成 #name 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">header</span>&gt;</span> <span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要使用 <strong>作用域插槽</strong>，可以写成：#name=slotProps</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>根据 <strong>编译作用域</strong> 我们已经知道，父模板中为子组件 slot 替换的内容，是获取不到子组件作用域的数据的。</p><p>同时子组件的 slot 可以通过 <strong>后备内容</strong> 来默认显示数据。</p><p>但怎么通过父模板的定义，来让 slot 能动态显示数据呢？看下下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义 v-slot:default 作用域插槽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 可以直接根据父插槽作用域 slotProps 来获取旗下的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设在子模板中，已经通过 props 或者 data 定义好了 user 对象（这是前提），然后在父模板中就可以根据 slotProps 这样一个钩子（自定义的 scope 对象）来取到 user 的所有属性，就像这段插值表达式写在子模板中一样。</p><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>我们已经知道通过 <strong>is</strong> 特性，可以动态切换组件模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次切换时，替换的组件都是重新渲染的 vue 组件实例，可以从生命周期的触发看到：</p><img src="/legacy/2019/11/06/vue-base-component/keeplive.gif" class=""><p>我们可以通过 <keep-alive> 来缓存替换的组件标签，另外所有切换的组件只需要设置一个名字即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/11/06/vue-base-component/keeplive2.gif" class=""><h1 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h1><p>目的为了缩小整个应用的大小，将一些组件按需加载，提升总体体验。</p><p>看下 component-b 组件的异步加载示范：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般组件注册</span></span><br><span class="line">Vue.component(<span class="string">"component-a"</span>, ComponentA);</span><br><span class="line"><span class="comment">// 异步组件注册</span></span><br><span class="line">Vue.component(<span class="string">"component-b"</span>, () =&gt; <span class="keyword">import</span>(<span class="string">"./component/ComponentB"</span>));</span><br></pre></td></tr></table></figure><p>import 是 webpack（import 异步加载 api） + es5（模块引用） 的组合写法，将返回一个 Promise 函数。</p><h1 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h1><h2 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素 &amp; 组件"></a>访问元素 &amp; 组件</h2><h3 id="访问根实例"><a href="#访问根实例" class="headerlink" title="访问根实例"></a>访问根实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$root.foo;</span><br></pre></td></tr></table></figure><h3 id="访问父级组件实例"><a href="#访问父级组件实例" class="headerlink" title="访问父级组件实例"></a>访问父级组件实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$parent.foo;</span><br></pre></td></tr></table></figure><h3 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="headerlink" title="访问子组件实例或子元素"></a>访问子组件实例或子元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">"usernameInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput;</span><br></pre></td></tr></table></figure><p>注意：\$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>provide</strong> 选项允许我们指定我们想要提供给后代组件的数据/方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">getMap</span>: <span class="keyword">this</span>.getMap &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child</span></span><br><span class="line">inject: [<span class="string">"getMap"</span>];</span><br></pre></td></tr></table></figure><h1 id="组件之间的循环引用"><a href="#组件之间的循环引用" class="headerlink" title="组件之间的循环引用"></a>组件之间的循环引用</h1><p>可能我们会存在 parent component 中引用 child component ，没有问题。但 child component 又可能会使用 parent component。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;tree-folder&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;tree-folder-contents&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就出现了循环引用，会在 webpack 打包时出现这种错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to mount component: template or render <span class="function"><span class="keyword">function</span> <span class="title">not</span> <span class="title">defined</span>.</span></span><br></pre></td></tr></table></figure><p>面对这种 <strong>悖论</strong> 有如下解决方案：</p><ol><li><p>将 parent component 改为全局组件</p></li><li><p>将组件导入方式改为异步</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./tree-folder-contents.vue"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>设置生命周期钩子 beforeCreate 注册它：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组件篇幅过程，本文大致只说明了 80% 内容。</p><p>列举了组件注册方式、props 属性的运用、父子组件的时间通讯、slot 插槽显示、以及组件加载等一些常见的用法。</p><p>更多细节可继续查阅官网：<a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">深入了解组件</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-事件处理</title>
      <link href="/legacy/2019/11/06/vue-base-event/"/>
      <url>/legacy/2019/11/06/vue-base-event/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>利用 v-on 指令，绑定 dom 原生的一些事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定一个 method 方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say"</span>&gt;</span>say<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以对 say 方法设置具体参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hello')"</span>&gt;</span>say<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意如果，如果没有指定参数，对应的 method 中定义的方法会接受到 event 事件参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      alert(event.target.tagName);<span class="comment">//BUTTON</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以向方法中，传入原始的 DOM 事件，\$event</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say($event)"</span>&gt;</span>say<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>最常用的莫过于 event.preventDefault() 或 event.stopPropagation()</p><p>举个例子，vue 事件处理，我们代码可能这样处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> @<span class="attr">click</span>=<span class="string">"stopJump"</span>&gt;</span>链接跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stopJump: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'haha, just here'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有了事件修饰符，可以简化成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"stopJump"</span>&gt;</span>链接跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有如下修饰符：</p><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive <a href="https://www.cnblogs.com/ziyunfei/p/5545439.html" target="_blank" rel="noopener">说明参考</a> <a href="http://ju.outofmemory.cn/entry/302263" target="_blank" rel="noopener">说明参考 2</a></li><li>.once</li></ul><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 提供了绝大多数常用的按键码的别名：</p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li></ul><p>还可以通过全局 config.keyCodes</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span>;</span><br></pre></td></tr></table></figure><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><ul><li>.ctrl</li><li>.alt</li><li>.shift</li><li>.meta (在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。)</li></ul><p>一些快捷键的定义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>exact 有些特殊，用于精确控制按键</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有最后一部分，鼠标按钮修饰符</p><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h2 id="为什么在-HTML-中监听事件"><a href="#为什么在-HTML-中监听事件" class="headerlink" title="为什么在 HTML 中监听事件?"></a>为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ul><li><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</p></li><li><p>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</p></li><li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>举例说明事件处理的几种实现方式；罗列了事件修饰符的多种分类。最后说了 HTML 模板中直接使用 v-on 事件的好处。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-表单</title>
      <link href="/legacy/2019/11/06/vue-base-form/"/>
      <url>/legacy/2019/11/06/vue-base-form/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>提到表单 form ，就要想到里面最重要的指令 v-model ，它会作用在 input、textarea、select 这些表单标签上实现 <strong>双向数据绑定</strong> 这么一项功能。</p><p>输入框 input</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面 message 的文案，会随着 input 输入框更改而实时更新。</p><p>复选框 checkbox</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单选框 radio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 radio id=one 选择后，值为 One</p><p>选择框 select</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"A"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"B"</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"C"</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 select 选择后，值为 option 选择的某项 value 。为了避免 IOS 首项兼容问题，可以将第一个 options 失效，绕过处理。</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h3><p>input 事件（实时触发）变成了 change 事件，只有当光标改变了状态才会触发值得更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="/legacy/2019/11/06/vue-base-form/lazy.gif" class=""><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>将自动过滤输入字符串的首位空格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>如果想自动将用户的输入值转为数值类型，先知道一点 html input 内输入的值都是字符串，即使你设置了 type=”number” 返回的也是字符串。</p><p>通过该修饰符，会通过 parseFloat 进行解析，返回处理结果。</p><p>当然如果解析失败则会返回请输入的原始值，所以要通过 type=”number” 限制用户的输入一定为数值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>列举 form 表单 v-model 在模板中的运用，最后介绍了三种修饰符。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-数据显示</title>
      <link href="/legacy/2019/11/06/vue-base-display/"/>
      <url>/legacy/2019/11/06/vue-base-display/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p><strong>v-if</strong> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><p>与 v-if 对应的是 <strong>v-else</strong> ，显示相反的逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no 😢<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p><p>另外还可以设置 <strong>v-else-if</strong> 。</p><h3 id="代码片段的显示"><a href="#代码片段的显示" class="headerlink" title="代码片段的显示"></a>代码片段的显示</h3><p>可以使用 template 来对代码片段做统一的显示隐藏，而不是另起一个 div 来做这样的逻辑，会徒增页面标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"isNum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>456<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"!isNum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>def<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h3><p>vue 会对模板做复用用于高效渲染，就像这样：</p><img src="/legacy/2019/11/06/vue-base-display/key.gif" class=""><p>由于模板复用，虽然两个不同的业务逻辑，但在切换中 input 的 value 却保留着。这明显不符合正常的需求。</p><p>但可以在 input 后面添加 key 属性，用于标注所属标签的唯一性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样每次渲染切换的时候，就会重新渲染模板内容。</p><img src="/legacy/2019/11/06/vue-base-display/key2.gif" class=""><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>和 v-if 效果相同，但元素依旧会保留在 dom 中，只是通过 css 控制了显示隐藏。</p><p>同时，v-if 是惰性的，会根据逻辑条件来判断是否要渲染标签，而 v-show 是一直会渲染标签的。</p><h1 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染 v-for"></a>列表渲染 v-for</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>通过 v-for 指令，按照 items 数组长度重复渲染模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把 in 替换成 of 也同样适用。建议适用 of ，这样会和 javascript 的逻辑保持一致。</p><p>除了可以取到 index 索引之外，还可以专门取键值对，只是遍历对象要 <strong>换成对象</strong>，而非数组:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,name) in obj"</span> <span class="attr">:key</span>=<span class="string">"value"</span>&gt;</span>&#123;&#123;name&#125;&#125;-&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><p>vue 对数组类型的属性进行的封装，如果调用相关 api 也会触发对应的更新机制。</p><p>涉及：push()，pop()，shift()，unshift()，splice()，sort()，reverse()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\observer\array.js</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// cache original method</span></span><br><span class="line">    <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">    def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">        <span class="keyword">let</span> inserted;</span><br><span class="line">        <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"unshift"</span>:</span><br><span class="line">                inserted = args;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"splice"</span>:</span><br><span class="line">                inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">        <span class="comment">// notify change</span></span><br><span class="line">        ob.dep.notify();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相反 filter()， concat()， slice() 就需要手动赋值给 vm 数组变量。</p><h2 id="对象变更检测注意事项"><a href="#对象变更检测注意事项" class="headerlink" title="对象变更检测注意事项"></a>对象变更检测注意事项</h2><p>另外，由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>可以通过 vm.\$set(vm.userProfile, ‘age’, 27) 来完成响应式属性难改的添加，或者触发。</p><h2 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h2><p>有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性相对操作简单，也具备高性能。但在其不适合的场景下（嵌套 for 循环），可以定义 method 方法，来指定执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: &#123; numbers: [ 1, 2, 3, 4, 5 ] &#125;, methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>和 v-if 一样，可以用在 template 标签上，用于渲染代码块。</p><p>但 v-for 不能和 v-if 一同使用，在构建时会给出错误警告，原因就是这两者都是对 dom 进行操作。</p><h1 id="样式显示"><a href="#样式显示" class="headerlink" title="样式显示"></a>样式显示</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>vue 可以对 class 属性进行绑定，来动态切换 class</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者一个复杂的对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    isActive：<span class="literal">true</span>,</span><br><span class="line">    activeClass: <span class="string">'active'</span>,</span><br><span class="line">    errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>和 class 一样，也可以设置内联样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外也可以设置多种前缀</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>介绍了 v-for 、v-if 、v-show 的用法以及区别；也列了 vue 控制样式的 class 、style 的使用说明。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-计算属性 computed</title>
      <link href="/legacy/2019/11/04/vue-base-watch-and-computed/"/>
      <url>/legacy/2019/11/04/vue-base-watch-and-computed/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在页面模板中使用 js 的表达式做一些简单功能逻辑非常方便，但太多的运算逻辑会使得模板过重难以维护。</p><p>你可以对比如下两种实现，如果你是该项目的维护者，你会选择哪种？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; reversedMessage &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你看到项目组有类似的代码，一定也会头大。毕竟使得 html template 变得异常臃肿会难以维护，它有时只是作为数据的显示而已。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>看下 computed 在 vue 中的运用、以及几个细节：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#example"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">"Hello"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message</span><br><span class="line">        .split(<span class="string">""</span>)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>计算属性中的 reversedMessage 会专门定义一个 getter 函数用于逻辑处理，它内部的 this.message 会和 reversedMessage 进行依赖。一旦 this.message 更改了，reversedMessage 就会随之做对应的改变。</p><p>相关源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\core\instance\state.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]; <span class="comment">// 获取计算属性的 getter 方法</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="comment">// 遍历 vm 属性</span></span><br><span class="line">      <span class="comment">// 定义动态响应，vm 属性发生变化时，会触发对应的计算属性</span></span><br><span class="line">      defineComputed(vm, key, userDef);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，也能让 template 模板更简约。</p><h2 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h2><p>上面默认是一个 getter 功能的方法，当然可以提供一个 setter 的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给 this.fullName 赋值时就会被触发调用。</p><h1 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h1><p>可以通过 methods 达到一样效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 message 改变时，对应的 reversedMessage() 也会自动执行，并在页面上实时更新。</p><p>那有什么区别？计算属性 computed 是和响应式依赖有联系的，当依赖变化，他就会变化，如果没有变化，就会直接返回“缓存的数据”。</p><p>就像如下的 now 属性，并不会再次执行当前时间的计算，直接返回首次缓存的数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反 methods 就会每次执行当前的方法。如果有相对大运算量的逻辑，method 就会消耗性能。不过缓存特性的使用要根据不同业务需求走。</p><h1 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h1><p>有一些数据需要随着其它数据变动而变动时，就会联想使用 watch，但是多数场景还是 computed 更为适用，体会如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">   fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>watch 里监听了 firstName 和 lastName ，目的就是为了动态更新 fullName ，但就此例子，完全可以使用 computed 对 fullName 进行 getter 函数的封装实现。</p><p><strong>那什么时候 watch 更为适用呢？</strong></p><p>如果监听的数据是异步操作时，watch 的优势就凸显出来了。 computed 计算属性是同步操作，在这个场景下就无法发挥作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"HelloWorld"</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"1 2 3"</span>,</span><br><span class="line">      msg: <span class="string">"not change"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    msg(newQuestion, oldQuestion) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldQuestion !== newQuestion) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">"4 5 6"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 一个简单的异步操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.msg = <span class="string">"change"</span>;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上，watch 监听 msg 字段，3 秒后，msg 发生更改后，message 就联动更新在页面模板上，更新为 4 5 6。这样的处理就变得很合适。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了下 computed 计算属性的相关用法，以及和 method 、 watch 的使用场景的运用。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-模板语法</title>
      <link href="/legacy/2019/11/04/vue-base-template/"/>
      <url>/legacy/2019/11/04/vue-base-template/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><h2 id="Mustache（双大括号）"><a href="#Mustache（双大括号）" class="headerlink" title="Mustache（双大括号）"></a>Mustache（双大括号）</h2><p>很简单，也是主流前端框架的大特色，相比于远古时期的 dom 操作，释放了劳动力，也结合框架机制加入了<strong>数据动态响应机制</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mustache（双大括号）方式只能用于标签的 innerHTML 上，即标签内的文本范围。作用在 Html 标签内部，需要使用 v-bind。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h2><p>如果数据是普通的 HTML 标签，则通过双大括号形式无法输出成真正的 HTML。需要通过 v-html 指令完成该操作。如果需要也要对数据有预防 XSS 攻击的措施。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h2><p>模板中允许写简单的 js 表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125; &#123;&#123; ok ? 'YES' : 'NO' &#125;&#125; &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但如果像写代码那样的写，就不行了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p>vue 的指令通常以 v- 作为前缀，不如：v-bind、v-html、v-once … 。作用是<strong>响应式地作用于 DOM</strong> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>指令属性后，以冒号表示的参数。用于针对不同 html 属性做的绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><p>参数位置可以通过 [] 来动态化，这个 js 里的方式是一样的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>值得注意，动态参数建议避免有大写字符，参数也不建议复杂化。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>比如参数 submit 是 html 特定的事件 event，对应会有冒泡等事件相关的处理，就可以通过修饰符来设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>罗列了 vue 模板插值相关简单的用法，包括双大括号、指令、修饰符以及指令写法。具体的使用方法，需要见后续更多文章。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 基础-起步&amp;安装</title>
      <link href="/legacy/2019/11/04/vue-base-installation/"/>
      <url>/legacy/2019/11/04/vue-base-installation/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《vue 基础》系列是再次回炉 vue 记的笔记，除了官网那部分知识点外，还会加入自己的一些理解。（里面会有部分和官网相同的文案，有经验的同学择感兴趣的阅读）</p><h1 id="vue-介绍"><a href="#vue-介绍" class="headerlink" title="vue 介绍"></a>vue 介绍</h1><p>是一个渐进式框架，容易上手，相比于其他主流框架（react、angular）学习成本低。</p><p>本人是从 angular.js 转到 vue 的，切身体会告诉我一门技术能快速投入业务编码工作尤为重要。但后续使用了 angular2 才方知某些方面是 vue 不及前两者的。比如：angular 中的 Typescript、rxjs、Dependency injection 等，或者 React 里 JSX、virtual Dom、状态机等（没用过就不扯了），总之他们随便抓来一个够玩一阵的了。</p><p>但随着 vue 的更新，你能看到它和其他主流框架类似的设计思想，加上 vue 相对其他框架学习曲线最低的，相信打好 vue 基础也能更好的理解现在主流前端框架。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>在 vue 中使用了诸如 defineProperty 的对象方法，导致只有支持 ES5 的浏览器才运行正常。像 IE8 及以下版本就不支持。</p><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><p>官方提供了 <a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli</a> 工具，可以方便快速的构建整个 vue 应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建项目</span></span><br><span class="line">vue create hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>如果不是特殊要求，还是不要用 script 方式，毕竟不能确保第三方 cdn 的服务不会出问题。</p><h1 id="不同构建版本的解释"><a href="#不同构建版本的解释" class="headerlink" title="不同构建版本的解释"></a>不同构建版本的解释</h1><h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><table><thead><tr><th>版本</th><th>UMD</th><th>CommonJS</th><th>ES Module (构建工具使用)</th><th>ES Module (用于浏览器)</th></tr></thead><tbody><tr><td>完整版</td><td>vue.js</td><td>vue.common.js</td><td>vue.esm.js</td><td>vue.esm.browser.js</td></tr><tr><td>运行时版</td><td>vue.runtime.js</td><td>vue.runtime.common.js</td><td>vue.runtime.esm.js</td><td>-</td></tr><tr><td>完整版（生产压缩）</td><td>vue.min.js</td><td>-</td><td>-</td><td>vue.esm.browser.min.js</td></tr><tr><td>运行时版（生产压缩）</td><td>vue.runtime.min.js</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h2 id="版本术语"><a href="#版本术语" class="headerlink" title="版本术语"></a>版本术语</h2><p><strong>完整版</strong>：同时包含编译器 + 运行时的版本。</p><p><strong>编译器</strong>：用来将模板字符串编译成为 JavaScript <strong>渲染函数</strong> 的代码。</p><p><strong>运行时</strong>：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是 <strong>除去编译器</strong> 的一切。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>UMD</strong>：可以使用 script 在浏览器端使用的脚本。</p><p><strong>CommonJS</strong>：配合 Browserify 或 webpack 1 构建的脚本。</p><p><strong>ES Module</strong> 分别有两种：</p><ul><li>构建工具使用：配合 webpack 2 或 Rollup 现在主流构建工具使用的脚本，结合 tree-shaking 实现代码进一步的简化。</li><li>浏览器直接使用：现代浏览器，可设置 &lt;script type=”module”> 直接导入。</li></ul><h2 id="ES-Moudle-vs-CommonJS"><a href="#ES-Moudle-vs-CommonJS" class="headerlink" title="ES Moudle vs CommonJS"></a>ES Moudle vs CommonJS</h2><p>首先要知道 node.js 内部的模块引用方式，就是通过 CommonJS 来加载的。</p><p>ES Moudle 就是社区为了统一模块加载方案，用来取代 CommonJS 和 AMD 规范的新方案。</p><p>由于这个方案设计思想就是：尽量使得代码静态化，在编译时期就能确保各个模块间的依赖关系。这就是为何配合 webpack 等现代打包工具的 tree-shaking 特性能让代码体积更小的原因之一。</p><p>举个代码例子说明 CommonJS vs ESM</p><img src="/legacy/2019/11/04/vue-base-installation/build-diff.png" class="" title="左：ESM，右：CommonJS"><h2 id="运行时-编译器-vs-只包含运行时"><a href="#运行时-编译器-vs-只包含运行时" class="headerlink" title="运行时 + 编译器 vs. 只包含运行时"></a>运行时 + 编译器 vs. 只包含运行时</h2><p>来看下含有编译器的完整版和运行版的区别：</p><p>首先我使用未压缩的完整版 js 大小为 852kb，运行版为 753kb （仅供参考）。</p><p>其次，代码实现区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">"&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">"div"</span>, <span class="keyword">this</span>.hi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>区别就是多了个 render 函数，如果你按“需要编译器”的写法，就会出现如下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue.runtime.common.dev.js:<span class="number">621</span> [Vue warn]: You are using the runtime-only build <span class="keyword">of</span> Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</span><br><span class="line"></span><br><span class="line">(found <span class="keyword">in</span> &lt;Root&gt;)</span><br></pre></td></tr></table></figure><p>值得注意的是：使用 vue-loader 或 vueify 的时候，*.vue 会由 webpack 交给他们做构建，实际上会在构建时预编译成 JavaScript（即不需要编译器的），如果非需要，在 webpack 配置 resolve 参数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="comment">// vue$: 'vue/dist/vue.esm.js' // 完整版</span></span><br><span class="line">      vue$: <span class="string">'vue/dist/vue.runtime.common.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单介绍 Vue，以及 Vue 安装时的一些细节。同时就 Vue 不同的版本文件做了说明举例。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端“自我修养”</title>
      <link href="/legacy/2019/11/01/my-frontend-best-practice-and-habit/"/>
      <url>/legacy/2019/11/01/my-frontend-best-practice-and-habit/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间过得飞快，从 2015.9 转行 <strong>前端开发</strong> 已经4年了。从小白菜到现在黄花菜，小公司谈不上架构设计，自己也只是个小开发，但在前端领域有自己的一些沉淀，这篇就罗列下 <strong>几个前端方面的心得体会</strong>，希望这些非代码的建议，能让看到的人有启发和帮助。</p><h1 id="勇于尝试“新事物”"><a href="#勇于尝试“新事物”" class="headerlink" title="勇于尝试“新事物”"></a>勇于尝试“新事物”</h1><p>我不太喜欢体验新事物，就是因为畏惧它带来的陌生感，不稳定性，不确定性，需要投入学习成本，产生不必要的 Bug。但做这行的总要 <strong>乐此不疲</strong> 的学新技术，别人创新出来的东西，给你带来好处远远超过那些缺点。</p><h2 id="选择主流的工具"><a href="#选择主流的工具" class="headerlink" title="选择主流的工具"></a>选择主流的工具</h2><p>“工欲善其事必先利其器”，在“搬砖”开始，选择一个炫酷吊炸天的工具非常重要，它将提升 <strong>非自身能力外</strong> 的工作效率和体验。</p><p>回忆起以前用 <strong>eclipse</strong> 时，调个黑色主题，或者是使用 <strong>shift+alt+A</strong> 快捷键带来的科技感和便捷性现在都觉得蛮有意思的。</p><p>扯回来，在前端还是推荐 sublime 和 <strong>vscode</strong>，前者我定位一个记事本，后者是正儿八经的 IDE。如果你还在用其他 IED 是时候考虑换了。</p><p>这里简单看下选择 <strong>vscode</strong> 将带来的“收益”：</p><ol><li><p>轻量的 IDE</p><p> 比较后端那些 IDE，我们前端的工具堪比记事本的打开速度。你不用一大早来公司拿泡杯茶的时间来等待 workspace 的加载，撸起袖子直接开干吧。</p></li><li><p>社区丰富的插件</p><p> vscode 的扩展功能里，你总能找到和自己技术栈对应的插件，来提升效率。</p> <img src="/legacy/2019/11/01/my-frontend-best-practice-and-habit/plugins.png" class="" title="插件"></li><li><p>便捷的操作</p><p> 一处学习，终身受益。前端所有 IDE 快捷键貌似都差不多，成为一种约定的规则，所以不用为这些学习成本担心。</p></li><li><p>方便的 Debug 调试。上手可以看下：<a href="https://eminoda.github.io/2018/01/26/vscode-debugger/" target="_blank" rel="noopener">如何使用 vscode debug 能力</a></p></li><li><p>它本身也是前端一部分，基于 electron</p></li></ol><h2 id="接受新技术"><a href="#接受新技术" class="headerlink" title="接受新技术"></a>接受新技术</h2><p>记得前一两年，Angular 的布道师和 Vue 的作者有一场争夺前端框架谁好谁坏的片段。那时候井底之蛙的我用的是 angular.js，很排除其他技术选型，可结果现在到处都是“真香”的想法。</p><p>无论是 Vue 那容易上手的体验，还是 Angular + TS 有些稍高的学习成本，用过之后都让自己的眼界开阔，当然还有 React 和其他优秀技术。</p><img src="/legacy/2019/11/01/my-frontend-best-practice-and-habit/keepLearn.png" class="" title="吃瓜"><p>总之大家不要像上图一样吵得热火朝天，然后在下面一股脑的为“我学不动了”点赞，倒不如自己试一下，没准它将给你打开心的世界。别让前端真成为娱乐圈了。​</p><h1 id="优先选择英文资源"><a href="#优先选择英文资源" class="headerlink" title="优先选择英文资源"></a>优先选择英文资源</h1><p>开发技术多数都源自外国，造成新技术的文档多英文，如果英文底子不好，就会自然觉得学习门槛变高。</p><p>我本身英语也很渣渣，但手持在线翻译，加上只看代码片段基本能猜出文章主要意思，毕竟看的是技术类文档而不是卷子上阅读理解。在中国这个开发环境下更需要 <strong>静心学习</strong> 的心态，该学的总要学。</p><p>我吃过的一个亏，比如 rollup 中文文档没有实时更新，导致一些配置没有体现出来，或者根本就是错的。（不过还是要感谢别人在中文资源付出的努力，毕竟无私的 <strong>开源精神</strong>）</p><p>你能看到如下，两个中英文文档在说明上的差异：</p><img src="/legacy/2019/11/01/my-frontend-best-practice-and-habit/better-en.png" class="" title="rollup 英文文档更多的参数说明"><h1 id="喜欢“整理”"><a href="#喜欢“整理”" class="headerlink" title="喜欢“整理”"></a>喜欢“整理”</h1><p>可以是项目配置、代码变量，或者建个专门的 workspace 放你的七七八八的项目，甚至收纳好你的电脑桌面。</p><p>相信将 <strong>杂乱不堪</strong> 的东西，变得 <strong>有条有理</strong>，定位文件或者问题将更加 <strong>高效</strong>。</p><p>最重要的是，提取出“规律”性的东西将成为 <strong>未来你改进的方向</strong>（比如重构，或者一些奇思妙想）</p><h2 id="“物理”层面"><a href="#“物理”层面" class="headerlink" title="“物理”层面"></a>“物理”层面</h2><p>举个例子：</p><p>我们有很多类似的项目，命名不统一，路径乱放，导致每次启动服务路径不一致，定位一个项目都要找一会儿。</p><p>如果把它们按照某个约定重命名好，在服务器上好辨识很多：</p><img src="/legacy/2019/11/01/my-frontend-best-practice-and-habit/clean-rename.png" class="" title="重新整理后就清爽许多"><p>然后因为测试服务器老是重启，每次进入对应的项目启动服务很繁琐。就通过外置一个 pm2 脚本批量 <strong>无脑</strong> 管理所有项目，也不会有所遗漏。</p><img src="/legacy/2019/11/01/my-frontend-best-practice-and-habit/pm2-json.png" class="" title="pm2"><h2 id="把“多变”变成“稳定”可配置"><a href="#把“多变”变成“稳定”可配置" class="headerlink" title="把“多变”变成“稳定”可配置"></a>把“多变”变成“稳定”可配置</h2><p>由于我们前端团队对样式这块没有太多的重视，导致很多类似的页面，由于不同的人员开发，在 css 上命名风格不同，维护起来相当麻烦。</p><p>比如，要求改一个页面 header 部分的底色，就存在多个页面底色相关的 className 命名不一致，要修改多处。</p><p>通过预编译 sass 可以完成这样的要求：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共库</span></span><br><span class="line"><span class="variable">$blue-100</span>: <span class="number">#7782e7</span>; <span class="comment">// 浅蓝</span></span><br><span class="line"><span class="variable">$blue-200</span>: <span class="number">#39418b</span>; <span class="comment">// 蓝色</span></span><br><span class="line"><span class="variable">$blue-300</span>: <span class="number">#202340</span>; <span class="comment">// 深蓝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> header(<span class="variable">$bg-color</span>) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$bg-color</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"><span class="selector-class">.header-wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> header(<span class="variable">$blue-100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些虽然在不同项目内容不同，但页面骨架布局却是类似的，我们可以沉淀成一份公共的样式库，这样以后有类似改动就可以大幅劳动力。</p><p>总之对于平时“头大”的修改，要尽可能优化，让开发的时间付出不要浪费在这些鸡毛蒜皮的事上。</p><p>更为重要的是，例如项目的 api 接口地址、端口、页面上的客服电话、某些特殊信息文案都需要配置化，也避免修改造成的线上事故。</p><h1 id="寻找“最优”-npm-模块，避免掉坑"><a href="#寻找“最优”-npm-模块，避免掉坑" class="headerlink" title="寻找“最优” npm 模块，避免掉坑"></a>寻找“最优” npm 模块，避免掉坑</h1><p>之前用过一个 <strong>gulp-jade-usemin</strong> 模块，模块本身没有什么问题，但为了贴近自己的业务需求，会更改其中部分的代码，我们没有 npm 私服，导致每次拉取项目都要对这个模块手动进行修改。</p><p>另外这个模块有时候还会出现些 <a href="https://github.com/niftylettuce/gulp-jade-usemin/issues/27" target="_blank" rel="noopener">warning: possible EventEmitter memory leak detected. 11</a>，对于有强迫症的我来说不能忍受，当然最后定位是对 node 的不熟悉所致。</p><p>建议还是在 npm 社区寻找一些高质量的模块投入使用，实在不行也可以尝试造些轮子。</p><p>真的出现问题，社区里会有可参考的解决方案，并经常进行迭代更新，有一些新的 feature 来把玩。</p><p>当然也不排除“天灾人祸”，像我们移动端项目，用了饿了吗的 <strong>mint-ui</strong> ，谁知道后面被阿里收购，移动端项目就不怎么维护了。</p><h1 id="“工具”代替不了框架"><a href="#“工具”代替不了框架" class="headerlink" title="“工具”代替不了框架"></a>“工具”代替不了框架</h1><p>相信你很熟悉 express、koa 这样面向 node 的 mvc 框架，他们上手很简单，轻松构建出一个 web 应用服务。</p><p>但是你要记住，他们只是一个 web 框架，而不是一个经过时间沉淀打造的企业级框架，某种程度他们只是个工具而已，相比于 java 的 spring 之类优秀的框架，我们前端这些真的太“轻量“了。</p><p>如果你和我一样在用他们，是不是感觉到随着项目的迭代，参与人员的变化，代码质量就得不到保证，风险、劳动力逐渐上升。</p><p>这里就要提到 egg ，如果你看过 egg ，就知道它是基于 koa <strong>为企业级框架和应用而生</strong> 的框架。</p><p>一切都是奉行『约定优于配置』，你会明确不同“层”做哪些对应的事情，通过它的规范让团队成员减少学习，沟通，劳动成本。任何一个新人完全可以在短时间内写出符合框架规范的代码。同时也有属于它的生态体系，你能找到不错的中间件、插件。</p><p>当然举例 egg ，只是希望各位能沉淀各自公司的代码，打造出更适合自己的框架，而非撸起袖子拿着 koa 直接“干架”。</p><h1 id="多向“别人”学习"><a href="#多向“别人”学习" class="headerlink" title="多向“别人”学习"></a>多向“别人”学习</h1><ol><li><p>npm module</p><p> 记得哪个大佬说，想要 JS 有所进步 ，每天看几个优秀 module。</p><p> 的确，技术成长过程中总会伴随着 <strong>瓶颈</strong>，不能向同事学习新东西，自己眼界和能力又限制住自己的发展。</p><p> 这阶段去看下 <strong>高度好评</strong> 的小模块，或者主流的框架源码，你马上就能被别人的编程思想，设计模式所“震撼”，仿佛投身于 BAT 一线大佬们的工作环境。</p><p> 比如：看了 koa 源码，你就能知道 <strong>洋葱模型</strong> 实现原理，其实核心用了 koa-compose</p><p> 当类似模块看多了，就见多识广了，<strong>万物关联</strong> 今天的准备是基建，相信量变总会质变，你会得到成长。</p></li><li><p>readme</p><p> 源码由于个人能力，不是那么快了解作者设计思路，理解其中原理。但优秀的框架，技术离不开质量高的文档，可以在其中快速掌握使用方法，理解作者意图。</p><p> 相比有什么不懂，直接面向搜索引擎编程，前者更知其源头。</p></li><li><p>抓住任何学习的机会</p><p> 工作时间久了，变成了老油条，会沉积于“死海”之中。改变不了环境，就要从自身出发，发掘身边所有可开发的资源。</p><p> 也许你的公司和我一样，每天的工作就那几样，重复繁琐的循环。这时候你就该分析这些事情：</p><ul><li><p>代码重构</p><p>  用自己学到的设计模式，逐步优化原先那些糟粕的代码</p></li><li><p>更新技术栈</p><p>  别人都大炮了，别自己还小米步枪，准备好新技术在合适的契机投入使用。比如：我们网站改版，就用 koa 替换了原先的 express，构建工具换成 webpack（虽然目前这些都不算什么）</p></li><li><p>“无中生有”</p><p>  不能因为是小公司，而忽视大厂或者主流方案的可行性。比如：自动化测试，持续集成等，很感谢我们的领导在这方面对我的引导。</p></li><li><p>自动化</p><p>  现在的前端依靠 node 有覆盖全平台的能力，我们可以写服务端，桌面应用，移动 app，当然也可以搞 <strong>自动化测试</strong>。为节约人力时间，最大程度保证项目的稳定性而探索。</p></li><li><p>everything</p><p>  保持思考，勇于探索尝试</p></li></ul></li></ol><h1 id="有东西输出"><a href="#有东西输出" class="headerlink" title="有东西输出"></a>有东西输出</h1><p>我的 blog 从上两年断断续续一直在坚持的，另外公众号也专门输出些技术类文章。虽然不像阮一峰之类的博主那么专业，有深度，但起码对自己在技术积累上有很大帮助。</p><p>甚至某个知识点隔了很长时间遗忘了，我还会打开自己的 Blog 寻找答案，而不是百度。</p><p>另外在工作闲暇之际，也会根据业务的需要，自己的兴趣着手一些 simple demo，技术这东西通过大量的 <strong>实践</strong> 才能形成认知。</p><p>你可以关注我的微信公众号【前端雨爸】。</p><h1 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h1><p><strong>专业化</strong> 这个词出自 《代码整洁之道–程序员的职业素养》 开篇。虽然毋庸置疑我们程序开发的本身是非常专业化的，但近年来我觉得自身离专业化还是有点距离，来举几个例子：</p><ul><li><p>是否掌握对应的技术栈内容</p><p>我工作中主要用 vue ，使用上没有大碍。但是真要谁问我原理实现，我很丢人的说不太深入。现在新技术层出不穷，对着 api 文档，估计半天就能弄出个像样的“成果”，无非就是坑踩熟不熟练。真要更高的层次走，必须静下心好好学习下底层源码。<br>​<br>这也是我为何前期会记录一些 vue 源码学习心得。</p><blockquote><p>​只有大浪褪去,才知道谁在裸泳。​</p></blockquote></li><li><p>预估能力</p><p>​工作中经常会遇到复杂的需求、新的技术，面对这些挑战你是否能有预估的能力？​你可以申请调研的时间，但最终需要有个明确的结论，可能能力不够完不成。但总不能说：“我去试下，可以的话就怎么样”，这样就显得非常不专业。</p></li><li><p>细节</p><p>前段日志在接触 ELK，搭建完环境也跑出了需要的 dashboard，但是对于里面细节的参数却无法解释。的确这不是我的领域，但既然我学习了并投入使用了，就务必对其有个详细的了解，不然会显得很 low，一切都是空中楼阁，不堪一击。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面列举了八条，都是经过这几年得出的非代码实现的一些建议，感谢从头到尾你的阅读，如果觉得有帮助可以推荐给更多的同学。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mintui loadmore 滚动加载和浏览器的兼容问题</title>
      <link href="/legacy/2019/10/29/vue-mintui-pagination-scroll/"/>
      <url>/legacy/2019/10/29/vue-mintui-pagination-scroll/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开篇之前，如果你要使用 mint-ui 作为 vue 的移动端 ui 框架的话，我给你的建议就是换个别的吧（原因就是这项目活跃度到冰点了），当然这丝毫不影响我们探究浏览器兼容那些事，积累经验就是不放过任何机会。</p><p>很早很早以前，使用饿了吗 的 mint-ui 移动框架时，就发现分页加载 loadmore 组件在部分浏览器中不能正常工作（上拉无法加载下一页）。说来惭愧，以前原以为是部分老机器的低版本浏览器问题，全当忽略了，只是简单写了一篇 <a href="https://eminoda.github.io/2018/09/04/vue-mintui-page/" target="_blank" rel="noopener">vue minuti 分页实现</a>，粗略带过了浏览器兼容性的一些问题。</p><p>近期又有高频类似的问题出现，甚至 chrome 也是，这就需要紧急解决了。借这个机会再次翻看 loadmore 组件，探究其中真相。</p><h2 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h2><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><p>这是第一个兼容问题，可以从这个 <a href="https://github.com/ElemeFE/mint-ui/commit/e7e6f0b1acc766e009dfa670e8a2adc091dc2a68" target="_blank" rel="noopener">PR</a> 上明白问题的原因。</p><img src="/legacy/2019/10/29/vue-mintui-pagination-scroll/scrollTop.png" class="" title="scrollTop"><p>原因就是不同浏览器厂商，对 scrollTop 的识别是不同的。</p><p>我们先搞清楚 scrollTop 是什么意思？</p><p>当页面内容过长，浏览器就会提供滚动条来存放这部分溢出页面。 scrollTop 就是该元素到窗口可见内容顶部那么个距离（如果没有发生垂直滚动，值就为 0 ）</p><p>虽然很多文章列出过 scrollTop 在不同浏览器的支持性，但没有关联版本信息的，随着浏览器的更新变化，无法确信是否现在还是列出过的那样。下面我列下我测试过的几款浏览器（当然主要是移动端，机型为小米）</p><table><thead><tr><th>浏览器</th><th>document.documentElement.scrollTop</th><th>document.body.scrollTop</th></tr></thead><tbody><tr><td>微信 v7.0.7 （安卓）</td><td>0</td><td>ok</td></tr><tr><td>小米 v11.0.10（安卓）</td><td>0</td><td>ok</td></tr><tr><td><strong>Chrome v78.0（安卓）</strong></td><td>ok</td><td>0</td></tr><tr><td>UC v12.7（安卓）</td><td>0</td><td>ok</td></tr><tr><td>搜狗 v8.5（PC 调试）</td><td>0</td><td>ok</td></tr><tr><td><strong>Chrome v76.0（PC 调试）</strong></td><td>ok</td><td>0</td></tr></tbody></table><p>排版原因，详细信息单独列出：</p><table><thead><tr><th>浏览器</th><th>详细信息</th></tr></thead><tbody><tr><td>微信 v7.0.7 （安卓）</td><td>Mozilla 5.0 (Linux; Android 9; MI 9 Build/PKQ1.181121.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/66.0.3359.126 MQQBrowser/6.2 TBS/044904 Mobile Safari/537.36 MMWEBID/3397 MicroMessenger/7.0.7.1521(0x2700073A) Process/tools NetType/WIFI Language/zh_CN</td></tr><tr><td>小米 v11.0.10（安卓）</td><td>Mozilla 5.0 (Linux; U; Android 9; zh-cn; MI 9 Build/PKQ1.181121.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.141 Mobile Safari/537.36 XiaoMi/MiuiBrowser/11.0.10</td></tr><tr><td><strong>Chrome（安卓）</strong></td><td>Mozilla 5.0 (Linux; Android 9; MI 9) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.62 Mobile Safari/537.36</td></tr><tr><td>UC（安卓）</td><td>Mozilla 5.0 (Linux; U; Android 9; zh-CN; MI 9 Build/PKQ1.181121.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.108 UCBrowser/12.7.1.1051 Mobile Safari/537.36</td></tr><tr><td>搜狗（PC 调试）</td><td>Mozilla 5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1</td></tr><tr><td><strong>Chrome（PC 调试）</strong></td><td>Mozilla 5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1</td></tr></tbody></table><p>很看到 Chrome 浏览器在 scrollTop 在 <strong>document.documentElement.scrollTop</strong> 上获取不到值，导致了 mint-ui 判断是否加载到页面底部的逻辑“失效”，导致上拉加载失败。</p><p>只要在原有判断基础上做如下处理即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollTop, <span class="built_in">document</span>.documentElement.scrollTop);</span><br></pre></td></tr></table></figure><p>因为个人喜好，我通常在搜狗浏览器做开发，但值得一提的是，<strong>虽然搜狗也用的是 Chrome 一样的内核，却在该属性取值却获取不到</strong>（这就很神奇了）。导致了主观上一直认为 Chrome 这样的浏览器不会出现兼容问题。</p><p>当然也可以使用 <strong>window.pageYOffset (window.scrollY)</strong> ，上述所测的浏览器都支持这属性。</p><p>另外我也同时列了 UC 做个特例说明，因为就算更正了判断逻辑，还是上拉加载还是有问题，这就涉及下个需要剖析的问题 —— <strong>屏幕可视高度</strong>。</p><h3 id="屏幕可视高度"><a href="#屏幕可视高度" class="headerlink" title="屏幕可视高度"></a>屏幕可视高度</h3><p>似乎调整了 scrollTop 的判断方式，有些浏览器功能得到了修复。但这里测试的 uc 浏览器还是不正常，这涉及浏览器的一些功能“优化”。</p><p>部分浏览器为了尽可能给用户呈现更多的页面内容，在上拉下拉时，会自动隐藏头部搜索框，或者底部的 tabbar 。这样做固然好，但对代码来说就会造成不小的麻烦。我截了些图来说下现象：</p><ol><li><p>页面初次加载</p><p>注意该属性的取值 document.documentElement.clientHeight = 727 （mint-ui 中可视区域的判断），原本如果浏览器不做优化，那什么问题都没有。</p><img src="/legacy/2019/10/29/vue-mintui-pagination-scroll/screen-init.png" class="" title="未拖动时状态"></li><li><p>当开始上拉后</p><p>浏览器头部搜索框开始隐藏，同时 window.innerHeight 开始随着拖动变化，document.documentElement.clientHeight 却一直为初始值。</p><img src="/legacy/2019/10/29/vue-mintui-pagination-scroll/screen-header.png" class="" title="状态栏变化"></li><li><p>上拉至顶部后</p><p>搜索框消失，document.documentElement.clientHeight 依旧没有变化，但 window.innerHeight 却为最大的屏幕可视高度</p><img src="/legacy/2019/10/29/vue-mintui-pagination-scroll/screen-end.png" class=""></li></ol><p>这样就解释了为何 uc 浏览器不行的原因，需要对原有逻辑做这样的调整：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.clientHeight, <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面两块内容只是针对 mint-ui loadmore 上拉加载功能的研究。</p><p>浏览器兼容问题处理起来很困难，需要你对相关 js api 都较高的熟悉程度，同时还需要反复的实践来摸索最终的答案。希望通过此文能对解决类似问题有个触类旁通的指引，也可以帮助到有类似问题的同学。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mint-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 分支合并策略</title>
      <link href="/legacy/2019/10/28/git-branch-merge-strategy/"/>
      <url>/legacy/2019/10/28/git-branch-merge-strategy/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git 依靠分布式版本控制、以及出众的分支功能受到互联网开发们的青睐，如果你上过 github 就离不开 git 的相关操作。</p><p>我司原来用的是 svn ，经过两年的时间，全项目都已换成 git ，我现在个人项目也全部用 github 和 gitee 。</p><p>但是，随着需求迭代周期的不断变化、发布的严格管控、线上问题的紧急修复等，开发分支时刻面临着来自不同需求方的“挑战”，合并到生产分支有时总会出现不可控的问题。</p><p>这些问题对开发人员管控代码造成了“不小的困扰”。归根到底就是没有对 git branch 的开发合并策略有个系统的认识。</p><p>借如下这张图，聊下 git 分支合并策略：</p><img src="/legacy/2019/10/28/git-branch-merge-strategy/git-branch-strategy.jpg" class="" title="git 分支合并策略"><p>相信有和我们一样的 git 分支合并问题的同学看过这图后，已经有了解决方案，可以忽略之后的内容了。当然看晕的同学，可以继续阅读下去，我会尽可能说清楚其中的方式。</p><h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h2><p>首先我们前端只是个几个人的团队，分支只有如下两种：</p><ul><li>develop：开发分支</li><li>product：发布分支</li></ul><p>以前就像前面说的一样，随着团队的逐日专业化，不能扛着小枪指哪打哪儿，面对各种“约束”，“困难”产生了如下些问题：</p><ul><li><p>在开发资源有限的前提下，面对多个需求，如何管理 develop 分支？</p></li><li><p>线上紧急 bug 的修复（紧急事件对分支的侵入）</p></li><li><p>怎么维护“相对”稳定的分支，作为发布分支（发布分支的管理）</p></li><li><p>线上发布后，因为某些“不可抗力”的原因，如何快速回滚上个版本（版本回滚）</p></li></ul><h2 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h2><h3 id="开发分支的细化"><a href="#开发分支的细化" class="headerlink" title="开发分支的细化"></a>开发分支的细化</h3><p>在项目“垦荒”阶段，或者迭代需求有规律，功能“轻量”时，往往一条开发分支就足够了（毕竟我们以前都那么干的），但产品上线后，面对八方的需求就有些捉襟见肘。</p><p>比如： A ， B 两个需求，A 预估 5 天，B 预估 10 天，但整个开发时间只有 10 天，势必 AB 两个需要不同开发人员同时进行。但更不幸的是，第 5 天时就要把 A 推到生产，一条 develop 分支完全不能应对（总不能 B 需求才完成一半），那怎么管理 develop 分支？</p><p>把 A ，B 两个需求单独创建分支，这类分支称为 <strong>feature branch</strong> ，那我们的 git 代码提交流程就会变成这样：</p><img src="/legacy/2019/10/28/git-branch-merge-strategy/feature.png" class="" title="git 开发分支的细化"><p>分别在 develop 分支上创建两条 feature 分支，对应 A，B 需求。这样三条分支在逻辑上互不干涉，如果 feature A 完成后即可推到 develop 上安排测试、发布等事项，feature B 可以继续安心的在属于它的分支上开发。</p><h3 id="创建-bug-分支"><a href="#创建-bug-分支" class="headerlink" title="创建 bug 分支"></a>创建 bug 分支</h3><p>面对紧急的线上 bug ，可以单独切一条临时的分支做处理，好处就是它对线上或者开发分支做的到“零侵入”。因为直接在 develop 上做 bug 修复，是不可靠的，因为整个团队的开发分支是不断在前行的。</p><img src="/legacy/2019/10/28/git-branch-merge-strategy/hotfix.png" class="" title="git 创建 bug 分支"><p>不用去关心 develop 的开发情况，从发布分支直接切出一个干净的 <strong>hotfix</strong> 分支，用于 bug 的修复，测试无问题后再推到发布分支上线。</p><h3 id="稳定的预发布分支"><a href="#稳定的预发布分支" class="headerlink" title="稳定的预发布分支"></a>稳定的预发布分支</h3><p>为了防止 product，develop 分支被开发人员在发布前后修改，造成发布代码功能问题，需要一个手段来“冻结”分支，以使其发布前后稳定。总不希望测试环境一切正常，但发布到线上却出现意料之外的问题（这样的事故，也是蛮那个啥的）。</p><p>这样的分支分为 <strong>release branch</strong> ：</p><img src="/legacy/2019/10/28/git-branch-merge-strategy/release.png" class="" title="git 稳定的预发布分支"><p>一旦把 develop 合并到 release 预发布分支，将把注意力放到 release 上，后续一切发现的问题将基于此分支进行，因为线上发布将以此为可靠稳定的基础。</p><p>为了让 <strong>稳定</strong> 不口头上说说，甚至可以将 release 立为保护分支（<a href="https://help.github.com/en/github/administering-a-repository/about-protected-branches" target="_blank" rel="noopener">protect branch</a>），所有的 push 请求将由项目管理人员来负责审核。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>和紧急 bug 修复类似，但有些不同。如果某些非开发原因（需求部门临时决定不上新功能等），需要把线上已发布的代码“撤下来”，但开发分支、或者发布分支都已经经历多次提交合并，已经难以定位之前的代码（除非有上次代码的备份记录，但这属于另一个范畴的问题）。需要有一种机制来快速回滚，可能上一次，可能上个月某天的发布。</p><p>为实现快速回滚，就要涉及 git 中 tag 的运用。</p><p>tag 顾名思义，给分支当前的状态打个标。并没有创建出一个新的节点，只是添加一些“备注”。</p><p>如果遇到 B 需求到了上线那天并且发布了，但因为突发情况需要回退到上次版本，所有的分支都做了合并，注意力都放在 B 需求的迭代，单纯的根据提交信息来回退代码是具有风险性的，最可靠的还是找到上次发布的代码来回滚。此时 tag 标签就发挥作用，如果上次发版在发布分支打了标签 1.0，这次就执行如下命令，就轻松回退：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1.0 # 将 HEAD 回退到 tag 1.0 时的代码状态</span><br><span class="line">git push --force origin master # 覆盖主线分支</span><br></pre></td></tr></table></figure><img src="/legacy/2019/10/28/git-branch-merge-strategy/tag.png" class="" title="git 版本回退"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解 git 分支合并策略将对项目代码的管控更为“自由”，虽然操作会复杂，但这些却是一定要做的。相信会在遇到上述这些问题时，起到确定性作用。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4js 在 pm2 cluster 下的配置</title>
      <link href="/legacy/2019/10/22/pm2-log4js-cluster-mode/"/>
      <url>/legacy/2019/10/22/pm2-log4js-cluster-mode/</url>
      
        <content type="html"><![CDATA[<p>log4js 算是“出镜率”很高的日志记录工具了，适用于大多数的日志需求（日志分级、按时间分割文件、按不同分类记录等…）。</p><p>但在 <strong>多线程</strong> 状态下，结果却不符合预期，比如：日志不输出、记录也不完整。</p><p>社区解决方案很详细，这里做个总结。</p><h2 id="普通的-log4js-配置（单线程）"><a href="#普通的-log4js-配置（单线程）" class="headerlink" title="普通的 log4js 配置（单线程）"></a>普通的 log4js 配置（单线程）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  appenders: &#123;</span><br><span class="line">    out: &#123;</span><br><span class="line">      type: <span class="string">"console"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    access: &#123;</span><br><span class="line">      type: <span class="string">"dateFile"</span>, <span class="comment">// 日期类型</span></span><br><span class="line">      filename: <span class="string">"log/node/buss"</span>, <span class="comment">// 日志输出路径，及命名</span></span><br><span class="line">      pattern: <span class="string">"yyyy-MM-dd.log"</span>, <span class="comment">// 日志命名的时间戳</span></span><br><span class="line">      alwaysIncludePattern: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: &#123;</span><br><span class="line">      type: <span class="string">"dateFile"</span>,</span><br><span class="line">      filename: <span class="string">"log/node/error"</span>,</span><br><span class="line">      pattern: <span class="string">"yyyy-MM-dd.log"</span>,</span><br><span class="line">      alwaysIncludePattern: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  categories: &#123;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      appenders: [<span class="string">"access"</span>, <span class="string">"out"</span>, <span class="string">"error"</span>],</span><br><span class="line">      level: <span class="string">"debug"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log4js = <span class="built_in">require</span>(<span class="string">"log4js"</span>);</span><br><span class="line">log4js.configure(<span class="built_in">require</span>(<span class="string">"./config.js"</span>));</span><br><span class="line"><span class="keyword">const</span> logger = log4js.getLogger(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"say somthing"</span>);</span><br></pre></td></tr></table></figure><p>一切都符合预期</p><h2 id="当遇到-PM2-时（cluster）"><a href="#当遇到-PM2-时（cluster）" class="headerlink" title="当遇到 PM2 时（cluster）"></a>当遇到 PM2 时（cluster）</h2><p>为充分利用 cpu ，给应用开启多核能力，最方便莫过于使用 pm2 模块。具体使用不做赘述，<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">简单使用，官网的文档足够了</a></p><p>但开启多 cluster 后，log4js 日志却没有输出，不然也不会有那么多人苦恼了。</p><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><p>直接贴出“可用”配置</p><p><strong>修改 log4js 配置</strong></p><p>回到官网，<a href="https://log4js-node.github.io/log4js-node/api.html#configuration-object" target="_blank" rel="noopener">看下有什么特殊配置，点击查看</a>，不过还得抱怨一下，log4js 的文档真的很“蛋疼”。</p><p>log4js.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * pm2 (boolean) (optional)</span></span><br><span class="line"><span class="comment">   * - set this to true if you’re running your app using pm2,</span></span><br><span class="line"><span class="comment">   * otherwise logs will not work (you’ll also need to install pm2-intercom as pm2 module: pm2 install pm2-intercom)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pm2: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * pm2InstanceVar (string) (optional, defaults to ‘NODE_APP_INSTANCE’)</span></span><br><span class="line"><span class="comment">   * - set this if you’re using pm2 and have changed the default name of the NODE_APP_INSTANCE variable.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pm2InstanceVar: <span class="string">"isMaster"</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * disableClustering (boolean) (optional)</span></span><br><span class="line"><span class="comment">   * - set this to true if you liked the way log4js used to just ignore clustered environments,</span></span><br><span class="line"><span class="comment">   * or you’re having trouble with PM2 logging. Each worker process will do its own logging. Be careful with this if you’re logging to files, weirdness can occur.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// disableClustering: true,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原有配置，这里不再列举</span></span><br><span class="line">  appenders: &#123;&#125;</span><br><span class="line">  categories: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pm2.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"apps"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"logger-test"</span>,</span><br><span class="line">      <span class="attr">"script"</span>: <span class="string">"http.js"</span>,</span><br><span class="line">      <span class="attr">"ignoreWatch"</span>: [<span class="string">"node_modules"</span>],</span><br><span class="line">      <span class="attr">"instances"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"watch"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"error_file"</span>: <span class="string">"log/pm2/error.log"</span>,</span><br><span class="line">      <span class="attr">"out_file"</span>: <span class="string">"log/pm2/out.log"</span>,</span><br><span class="line">      <span class="attr">"pid_file"</span>: <span class="string">"log/pm2/pid.log"</span>,</span><br><span class="line">      <span class="attr">"merge_logs"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"instance_var"</span>: <span class="string">"isMaster"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改配置说明"><a href="#修改配置说明" class="headerlink" title="修改配置说明"></a>修改配置说明</h3><p>pm2.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"instance_var": "NODE_APP_INSTANCE"</span><br></pre></td></tr></table></figure><p>设置 instance_var 实例变量，在交给 pm2 运行后，会自动赋值给 process.env.NODE_APP_INSTANCE 。详细说明可以看下 <a href="http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables" target="_blank" rel="noopener">官网说明</a></p><p>log4js.conf.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  pm2: <span class="literal">true</span>,</span><br><span class="line">  pm2InstanceVar: <span class="string">"NODE_APP_INSTANCE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先结合 pm2 的 instance_var 配置，看下 log4js 的 pm2InstanceVar ，这两者必须设置的值相同。因为有关 isPM2Master 的逻辑判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPM2Master = <span class="function"><span class="params">()</span> =&gt;</span> pm2 &amp;&amp; process.env[pm2InstanceVar] === <span class="string">"0"</span>;</span><br></pre></td></tr></table></figure><p>再来具体看下 log4js 相关代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\log4js\lib\clustering.js</span></span><br><span class="line"><span class="keyword">if</span> (!disabled) &#123;</span><br><span class="line">  configuration.addListener(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    (&#123;</span><br><span class="line">      pm2,</span><br><span class="line">      disableClustering: disabled,</span><br><span class="line">      pm2InstanceVar = <span class="string">"NODE_APP_INSTANCE"</span></span><br><span class="line">    &#125; = config);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// just in case configure is called after shutdown</span></span><br><span class="line">    <span class="keyword">if</span> (pm2) &#123;</span><br><span class="line">      process.removeListener(<span class="string">"message"</span>, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cluster &amp;&amp; cluster.removeListener) &#123;</span><br><span class="line">      cluster.removeListener(<span class="string">"message"</span>, receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disabled || config.disableClustering) &#123;</span><br><span class="line">      debug(<span class="string">"Not listening for cluster messages, because clustering disabled."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPM2Master()) &#123;</span><br><span class="line">      <span class="comment">// PM2 cluster support</span></span><br><span class="line">      <span class="comment">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></span><br><span class="line">      <span class="comment">// we only want one of the app instances to write logs</span></span><br><span class="line">      debug(<span class="string">"listening for PM2 broadcast messages"</span>);</span><br><span class="line">      process.on(<span class="string">"message"</span>, receiver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">      debug(<span class="string">"listening for cluster messages"</span>);</span><br><span class="line">      cluster.on(<span class="string">"message"</span>, receiver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      debug(<span class="string">"not listening for messages, because we are not a master process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据新增参数，预先移除原有的事件监听方式，当 isPM2Master 判断为 pm2 为主进程时，pm2-intercom 作为新的消息收发“中转站”。</p><p>这就是为何配置了 log4js 的配置，但 <strong>没有安装 pm2-intercom</strong> ，就会发生日志不输出的情况。</p><p>当然如果你图方便，在出现一些“未知错误”，可以尝试在 log4js 添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disableClustering: <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>它会使上面所说的方式失效，每个线程将会单独向目标日志文件输出内容，表明似乎问题可以解决，但是在高频访问下会出现日志缺失的情况。毕竟日志文件被多个进程写入放操作着。</p><h2 id="有效的日志管理"><a href="#有效的日志管理" class="headerlink" title="有效的日志管理"></a>有效的日志管理</h2><p>对于一个线上的项目，可能需要一些其他手段来对日志做维护管理。既然现在说 pm2 ，就要看下其日志插件：<strong>pm2-logrotate</strong></p><p>来看下具体配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pm2 get pm2-logrotate</span><br><span class="line">&#x3D;&#x3D; pm2-logrotate &#x3D;&#x3D;</span><br><span class="line">┌────────────────┬─────────────────────┐</span><br><span class="line">│ key            │ value               │</span><br><span class="line">├────────────────┼─────────────────────┤</span><br><span class="line">│ max_size       │ 10M                 │</span><br><span class="line">│ retain         │ 10                  │</span><br><span class="line">│ compress       │ false               │</span><br><span class="line">│ dateFormat     │ YYYY-MM-DD_HH-mm-ss │</span><br><span class="line">│ workerInterval │ 30                  │</span><br><span class="line">│ rotateInterval │ 0 0 * * *           │</span><br><span class="line">│ rotateModule   │ true                │</span><br><span class="line">└────────────────┴─────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="定时轮询"><a href="#定时轮询" class="headerlink" title="定时轮询"></a>定时轮询</h3><p><strong>rotateInterval</strong> 和 <strong>workerInterval</strong> 都有定时的作用。</p><p>前者通过编写 cron 表达式，约定每隔多少时间 <strong>强制</strong> 检查日志的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每日零点</span></span><br><span class="line">rotateInterval: 0 0 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash"> 每分钟</span></span><br><span class="line">rotateInterval: */1 * * * *</span><br></pre></td></tr></table></figure><p>后者 workerInterval 是约定固定秒数来查询日志状况。（默认 30 秒）</p><h3 id="日志分割条件"><a href="#日志分割条件" class="headerlink" title="日志分割条件"></a>日志分割条件</h3><p><strong>max_size</strong> 和 <strong>retain</strong> 分别来约束日志的大小，和文件个数</p><p>每次 <strong>定时轮询</strong> 触发后，会对文件大小，数量进行检查。超过约定的值，则会重新创建新文件。</p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>假设单日日志产出为 10G ，按照 rotateInterval 每天零点进行切割日志，虽然有章法，但如果要从 10G 大小的日志文件中排查问题，这似乎有些困难。</p><p>我们可以设置 max_size 为 100M ，这样 10G 总大小的文件，将在一天中被切成 100 个。</p><p>甚至如果每天的访问量有迹可循，比如上午 9-12 点会出现高峰，其他时间相对低频。可以进一步优化 workerInterval 和 rotateInterval cron 表达式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 set pm2-logrotate:workerInterval 3600 #每小时轮训检查</span><br><span class="line">pm2 set pm2-logrotate:rotateInterval 0/30 0,9,10,11,12 * * * #每天 0 点，以及 9~12 点每半小时触发</span><br></pre></td></tr></table></figure><p>这样在高访问时间段，可以跟有效的分割日志。（美中不足的是如果符合日志分割条件，00:00 和 00:30 时，会出现两份日志，强迫症表示不太适应）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://my.oschina.net/xuyang950520/blog/2934086" target="_blank" rel="noopener">记 nodejs 在 pm2 下使用 log4js cluster 模式的日志打印丢失问题</a></li><li><a href="https://juejin.im/post/5b7d0e20f265da43231f00d4" target="_blank" rel="noopener">再说打日志你不会，pm2 + log4js，你值得拥有</a></li><li><a href="https://claude-ray.github.io/2018/12/21/pm2-cluster-log4js/" target="_blank" rel="noopener">PM2 cluster + log4js？并不理想的组合</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pm2 </tag>
            
            <tag> log4js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue ssr 实践</title>
      <link href="/legacy/2019/10/14/ssr-vue/"/>
      <url>/legacy/2019/10/14/ssr-vue/</url>
      
        <content type="html"><![CDATA[<p>为了更好的 <strong>SEO 排名</strong> 和 <strong>性能优化</strong> 等要求，往往需要 <strong>服务端渲染</strong> 的支持。我的公司项目都是基于 vue 的单页面应用（那时候太年轻），那怎么实现服务端渲染呢？</p><p>社区早已有了解决方案，只是我还没有用过罢了，借这个机会快速的看下这块的实践，做些技术储备。</p><h2 id="vue-ssr-api-的介绍"><a href="#vue-ssr-api-的介绍" class="headerlink" title="vue-ssr api 的介绍"></a>vue-ssr api 的介绍</h2><p>有关 vue ssr 的实现都是依靠 <strong>vue-server-renderer</strong> 模块提供的功能，可以看如下 Demo：</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/vue-ssr-api" target="_blank" rel="noopener">点击访问：https://gitee.com/eminoda/ssr-learn/tree/vue-ssr-api</a></p></blockquote><p>下面会对 <strong>简单的渲染</strong> 和 <strong>结合 bundle&amp;manifest 文件做的渲染</strong> 做说明。</p><p>当然你可以看 <a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener">Vue SSR 官方文档说明</a>，真的是非常详细。</p><h3 id="简单渲染"><a href="#简单渲染" class="headerlink" title="简单渲染"></a>简单渲染</h3><p>这是个非常简单的例子，主要在没有其他代码的干扰下更可能示范 vue ssr 的本质。只需要 vue + htmlTemplate 就能搞定。</p><h4 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer"></a>createRenderer</h4><p>创建一个（模板）渲染器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createRenderer &#125; = <span class="built_in">require</span>(<span class="string">"vue-server-renderer"</span>);</span><br><span class="line"><span class="keyword">let</span> renderer = createRenderer(&#123;</span><br><span class="line">  template: templateFile</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个 templateFile 是字符串，而不是 require 的引用。这也好理解，毕竟服务端渲染的本质就是响应返回字符串。</p><h4 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: data.msg</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div&gt;数据绑定：&#123;&#123; msg &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="renderToString"><a href="#renderToString" class="headerlink" title="renderToString"></a>renderToString</h4><p>通过渲染器 renderer ，调用 <strong>renderToString</strong> ，把 vue 实例注入进去，得到字符串。</p><p>当然还可以通过 content 设置一些信息，比如 SEO 的 TDK。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = &#123;</span><br><span class="line">  title: <span class="string">"SSR-templateRender"</span></span><br><span class="line">&#125;;</span><br><span class="line">renderer.renderToString(app, content, (err, html) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    reject(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后你就能访问 url 看到页面内容（注意这并不是客户端 js mount 上去的）</p><p><img src="https://gitee.com/eminoda/ssr-learn/raw/vue-ssr-api/doc/templateRender.png" alt="模板渲染"></p><h3 id="JsonBundle-Manifest"><a href="#JsonBundle-Manifest" class="headerlink" title="JsonBundle + Manifest"></a>JsonBundle + Manifest</h3><p>当然真实的项目还更复杂些：</p><ul><li>Html 引用的资源需要“动态”的挂到标签上</li><li>服务端 router 每次解析不同地址，还需要“配合” vue router ，做对应的模板渲染</li><li>甚至还需要保持 vuex 的状态；异步请求的处理</li></ul><p>详细的项目配置，<a href="#相关-api">你可以在上面的 Demo 中看到</a> 看到，下面只是说核心部分。</p><h4 id="webpack-build"><a href="#webpack-build" class="headerlink" title="webpack build"></a>webpack build</h4><p>首先我们需要通过 webpack 不同的入口文件 entry 来构建 <strong>客户端的 manifest 文件</strong> 和 <strong>服务端的 server.bundle 文件</strong>。</p><p>这里就涉及 webpack 的两个 plugin：<strong>vue-server-renderer/client-plugin</strong>、<strong>vue-server-renderer/server-plugin</strong> ，分别生成 manifest 和 bundle：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.client.config</span></span><br><span class="line">plugins: [<span class="keyword">new</span> VueSSRClientPlugin()];</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.server.config</span></span><br><span class="line">plugins: [<span class="keyword">new</span> VueSSRServerPlugin()];</span><br></pre></td></tr></table></figure><p>构建成功就会在 output 目录下生成：vue-ssr-client-manifest.json、vue-ssr-server-bundle.json 。</p><p>通过 manifest ，vue 就知道如何往模板上挂在资源文件；同时每次渲染时，vue 也能依靠 bundle 知道取那部分 js 逻辑。</p><h4 id="修改服务端路由逻辑"><a href="#修改服务端路由逻辑" class="headerlink" title="修改服务端路由逻辑"></a>修改服务端路由逻辑</h4><p>拦截服务端所有的请求，交给 getResponseDataByBundleRender 处理，context 内包含当前请求的 url ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"*"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> ssr = <span class="keyword">new</span> SSRService(&#123;&#125;);</span><br><span class="line">  <span class="keyword">let</span> context = &#123;</span><br><span class="line">    title: <span class="string">"SSR-jsonBundleRender"</span>,</span><br><span class="line">    url: ctx.url</span><br><span class="line">  &#125;;</span><br><span class="line">  ctx.body = <span class="keyword">await</span> ssr.getResponseDataByBundleRender(context, &#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>getResponseDataByBundleRender 是一个封装的方法，和上面的简单渲染实现一样，只是额外需要 bundle、manifest 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getResponseDataByBundleRender(content) &#123;</span><br><span class="line">  <span class="keyword">let</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">    runInNewContext: <span class="literal">false</span>, <span class="comment">// 推荐</span></span><br><span class="line">    template: template,</span><br><span class="line">    clientManifest: clientManifest</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    renderer.renderToString(content, (err, html) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(html);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端和服务端功能的衔接"><a href="#客户端和服务端功能的衔接" class="headerlink" title="客户端和服务端功能的衔接"></a>客户端和服务端功能的衔接</h4><p>那客户端的请求地址怎么和 vue 的路由模式搭上关系？这就要回到上面的 webpack 配置不同的入口文件：</p><p>独立创建一个创建 vue 实例的文件，用于对不同端的 entry 入口文件解耦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\app.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123; router, store, <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App) &#125;);</span><br><span class="line">  <span class="comment">//   额外导出 router ，供 ssr 使用</span></span><br><span class="line">  <span class="keyword">return</span> &#123; app, router, store &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>server.entry.js</strong> 会将 store 注入到 window.__INITIAL_STATE__ 中，并且会根据请求地址，切换 vue 当前路由地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp();</span><br><span class="line"></span><br><span class="line">    router.push(context.url);</span><br><span class="line"></span><br><span class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents();</span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"访问页面不存在"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.all(</span><br><span class="line">        matchedComponents.map(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (Component.asyncData) &#123;</span><br><span class="line">            <span class="keyword">return</span> Component.asyncData(&#123;</span><br><span class="line">              store,</span><br><span class="line">              route: router.currentRoute</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span></span><br><span class="line">          context.state = store.state;</span><br><span class="line">          resolve(app);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(reject);</span><br><span class="line">    &#125;, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>client.entry.js</strong> 会加入如下逻辑，使客户端能将 window.__INITIAL_STATE__ 替换成 vue store :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src\entry-client.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, store &#125; = createApp();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 vue 的状态机制就得以还原。</p><p>之后你就能看到这样的效果：</p><p><img src="https://gitee.com/eminoda/ssr-learn/raw/vue-ssr-api/doc/vue-ssr.gif" alt="vue-ssr"></p><h2 id="koa-vue-ssr-的开发模式"><a href="#koa-vue-ssr-的开发模式" class="headerlink" title="koa + vue-ssr 的开发模式"></a>koa + vue-ssr 的开发模式</h2><p>在实际开发中，上面这些还远远不够。因为 manifest 和 bundle 的更新都需要重新加载到服务中；为了开发体验还需要 <a href="/2019/10/12/weback-middleware-in-hmr-development/">HMR 的开发方式</a>。</p><p>Vue 的作者 尤大大 给我们了个例子 <a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-hackernews-2.0</a>，参考它，就能很大程度解决上面的问题。</p><p>同样对其中的重点做个说明，备注：服务端用的 koa ：</p><h3 id="一个延迟启动"><a href="#一个延迟启动" class="headerlink" title="一个延迟启动"></a>一个延迟启动</h3><p>因为要把 webpack 构建包含到服务中，就要在服务启动前完成构建工作。</p><p>提供一个 ready 完成这项工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready(app).then(<span class="function"><span class="params">renderer</span> =&gt;</span> &#123;</span><br><span class="line">  app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// vue render</span></span><br><span class="line">  &#125;);</span><br><span class="line">  app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server is started on 3000 port "</span>, <span class="string">"http://127.0.0.1:3000"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 ready 中完成 vue ssr 需要的 bundle.json 和 manifest.json 构建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ready(app, cb) &#123;</span><br><span class="line">    <span class="comment">// 获取 webpack compiler 编译实例</span></span><br><span class="line">    <span class="keyword">const</span> clientCompiler = webpack(clientConfig);</span><br><span class="line"></span><br><span class="line">    clientCompiler.plugin(<span class="string">'done'</span>, stats =&gt; &#123;</span><br><span class="line">      stats = stats.toJson();</span><br><span class="line">      stats.errors.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</span><br><span class="line">      stats.warnings.forEach(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.warn(err));</span><br><span class="line">      <span class="keyword">if</span> (stats.errors.length) <span class="keyword">return</span>;</span><br><span class="line">      clientManifest = <span class="built_in">JSON</span>.parse(readFile(webpackDevMiddlewareWrap.fileSystem, <span class="string">'vue-ssr-client-manifest.json'</span>));</span><br><span class="line">      update();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> serverCompiler = webpack(serverConfig);</span><br><span class="line">    <span class="keyword">const</span> mfs = <span class="keyword">new</span> MFS();</span><br><span class="line">    serverCompiler.outputFileSystem = mfs;</span><br><span class="line">    serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      stats = stats.toJson();</span><br><span class="line">      <span class="keyword">if</span> (stats.errors.length) <span class="keyword">return</span>;</span><br><span class="line">      bundle = <span class="built_in">JSON</span>.parse(readFile(mfs, <span class="string">'vue-ssr-server-bundle.json'</span>));</span><br><span class="line">      update();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> readyPromise;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>拿到 clientManifest 和 bundle 再交给 update() 获取渲染解析器，就回归到 vue ssr api 那部分的运用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> update = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> createBundleRenderer(bundle, &#123;</span><br><span class="line">    runInNewContext: <span class="literal">false</span>,</span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>准备做完后，就根据 request 地址生成对应的 html 字符串。这些都是在服务启动前搞定了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ready(app).then(<span class="function"><span class="params">renderer</span> =&gt;</span> &#123;</span><br><span class="line">  app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;</span><br><span class="line">      title: <span class="string">'vue ssr by koa server'</span>, <span class="comment">// default title</span></span><br><span class="line">      url: ctx.request.url</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.body = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      renderer.renderToString(context, (err, html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(html);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动服务</span></span><br><span class="line">  app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server is started on 3000 port '</span>, <span class="string">'http://127.0.0.1:3000'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开启-HMR"><a href="#开启-HMR" class="headerlink" title="开启 HMR"></a>开启 HMR</h3><p><a href="/2019/10/12/weback-middleware-in-hmr-development/">我们已经知道了 HMR 的原理</a></p><p>首先模拟 webpack-dev-server （内存）静态文件服务，这样每次来次客户端的请求都会被 devMiddleware 拦截，根据请求响应对应的资源文件，包括热更新资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> webpackDevMiddlewareWrap = webpackDevMiddleware(clientCompiler, &#123;</span><br><span class="line">  publicPath: clientConfig.output.publicPath,</span><br><span class="line">  noInfo: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册中间件，webpack-dev-middleware</span></span><br><span class="line">app.use(devMiddleware(webpackDevMiddlewareWrap));</span><br></pre></td></tr></table></figure><p>再是创建通过 clientHotMiddleware 创建 socket 连接，时刻向服务端推送信息，告知本地代码更新状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(clientHotMiddleware(clientCompiler, &#123; <span class="attr">heartbeat</span>: <span class="number">5000</span> &#125;));</span><br></pre></td></tr></table></figure><p>这样一个 koa + vue 的 ssr 开发架构就初步成型。</p><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><blockquote><p>2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。</p></blockquote><p>主流 vue ssr 框架了，github 高 star 为使用它提供了足够的保障。</p><p>但我展示不打算使用它，因为上面的开发方式以及满足我的基本需求，过多的框架封装会让我迷失技术的原有“味道”，等有时间时再来填这里的坑。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener">Vue SSR 官方文档说明</a></li><li><a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-hackernews-2.0</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发中如何接入 HRM 到服务端</title>
      <link href="/legacy/2019/10/12/weback-middleware-in-hmr-development/"/>
      <url>/legacy/2019/10/12/weback-middleware-in-hmr-development/</url>
      
        <content type="html"><![CDATA[<h2 id="谈下开发"><a href="#谈下开发" class="headerlink" title="谈下开发"></a>谈下开发</h2><p>webpack 的 HMR 都用过，但简单入门的都是依靠 webpack-dev-server ，如果你是个全栈开发，必然会有个 node 服务，那一个粗暴的项目模式将是这样：</p><img src="/legacy/2019/10/12/weback-middleware-in-hmr-development/development-mode.png" class="" title="粗暴的开发模式"><p>这样就存在两个 Http 服务（webpack-dev-server 自带的 express 服务、和 node 服务）</p><p>当然你项目稍稍“复杂些”，涉及服务端渲染，那上面这个模式就会变得难以理解。</p><p>很不幸，我们的项目就是这样，未经推敲的构建方式，随着多页面的增多变得异常慢。抛开 webpack 优化，就连热更新都丢掉了。</p><p>想要精简，最快的就是去掉一个服务（本身就有些累赘），去除后 <strong>怎么实现 HMR （脱离了 webpack-dev-server）？</strong></p><p>先看下如下开发模式：</p><img src="/legacy/2019/10/12/weback-middleware-in-hmr-development/development-mode2.png" class="" title="精简的开发模式"><p>下面会对其中替代 webpack-dev-server 模块的 webpack-dev-middleware 和 webpack-hot-middleware 做说明：</p><p>当然你可以跳过如下说明，直接看我已经写的一个 Demo：</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/webpack-server-middleware" target="_blank" rel="noopener">点击访问，https://gitee.com/eminoda/ssr-learn/tree/webpack-server-middleware</a></p></blockquote><p><img src="https://gitee.com/eminoda/ssr-learn/raw/webpack-server-middleware/doc/webpack-middlemare.gif" alt="express 构建"></p><h2 id="拆解-webpack-dev-server"><a href="#拆解-webpack-dev-server" class="headerlink" title="拆解 webpack-dev-server"></a>拆解 webpack-dev-server</h2><p>如果移除了 webpack-dev-server ，我们要添加那些功能才能还原呢？</p><h3 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h3><p>首先看到 webpack-dev-server 使用了 webpack-dev-middleware 模块，它提供了如下功能：</p><ul><li>面对客户端资源的请求，从缓存中给出响应</li><li>监听本地代码的修改，让 webpack 编译</li></ul><p>看下它怎么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\Server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 webpack dev 中间件</span></span><br><span class="line">setupDevMiddleware() &#123;</span><br><span class="line">  <span class="comment">// middleware for serving webpack bundle</span></span><br><span class="line">  <span class="keyword">this</span>.middleware = webpackDevMiddleware(</span><br><span class="line">    <span class="keyword">this</span>.compiler,</span><br><span class="line">    <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.options, &#123; <span class="attr">logLevel</span>: <span class="keyword">this</span>.log.options.level &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到整个 express 中间链中</span></span><br><span class="line">setupMiddleware() &#123;</span><br><span class="line">  <span class="keyword">this</span>.app.use(<span class="keyword">this</span>.middleware);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 this.compiler 就是 webpack 编译实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler = webpack(config);</span><br></pre></td></tr></table></figure><p>把 compiler 传入到 webpack-dev-middleware 内部，它就会调用 compiler 相关 api 从而执行构建相关事情。</p><p>只要模仿 webpack-dev-server 把 webpack-dev-middleware 作为中间件加到我们自己的 node server 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">"./build/webpack.client.config"</span>);</span><br><span class="line"><span class="keyword">const</span> clientCompiler = webpack(clientConfig);</span><br><span class="line"><span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>)(clientCompiler, &#123;</span><br><span class="line">  publicPath: clientConfig.output.publicPath,</span><br><span class="line">  noInfo: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(devMiddleware);</span><br></pre></td></tr></table></figure><p>就上面一样，我们 node 中的代码就有了监听，构建的功能。<strong>为了加入 HMR 功能，还少了一些东西</strong>。</p><h3 id="客户端-HMR-代码的注入"><a href="#客户端-HMR-代码的注入" class="headerlink" title="客户端 HMR 代码的注入"></a>客户端 HMR 代码的注入</h3><p>像在 <strong><a href="/2019/10/12/webpack-dev-server-hmr/">探索 webpack-dev-server 的 HMR</a></strong> 说的，为了实现 HMR 功能，客户端代码需要提前埋入各种 runtime 代码。</p><p>这样我们就需要修改原有的 webpack config ，为客户端添加对应的 <strong>socket 监听代码</strong> 和 <strong>向服务端获取新资源的代码</strong> 。</p><p>这样就要用到 <strong>webpack-hot-middleware</strong> ，其提供了客户端 socket 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入 client 入口文件</span></span><br><span class="line">clientConfig.entry.app = [<span class="string">"webpack-hot-middleware/client"</span>, clientConfig.entry.app];</span><br><span class="line">clientConfig.output.filename = <span class="string">"[name].js"</span>;</span><br><span class="line"><span class="comment">// 构建时，加入 runtime 代码</span></span><br><span class="line">clientConfig.plugins.push(<span class="keyword">new</span> webpack.HotModuleReplacementPlugin());</span><br></pre></td></tr></table></figure><h2 id="webpack-hot-middleware"><a href="#webpack-hot-middleware" class="headerlink" title="webpack-hot-middleware"></a>webpack-hot-middleware</h2><p>完成上述两个步骤，并不能实现 HMR 功能，还差最后样东西：服务端与客户端通讯的 socket 通讯。</p><h3 id="eventsource-事件推送"><a href="#eventsource-事件推送" class="headerlink" title="eventsource 事件推送"></a>eventsource 事件推送</h3><p>在此之前，先了解下 eventsource ，它和 websocket 不同：</p><ul><li>eventsource 是 HTTP 协议，并且是单通道（服务端发送给客户端）</li><li>websocket 是 TCP 协议，支持双工通道（可以互相发送接收信息）</li></ul><p>当然还有实现机制、性能等区别，这里不做展开。对于开发阶段借助 eventsource 完成 HMR 的通知问题，我觉得主要还是简单，轻量，学习成本低。</p><p>我也已经准备了个 Demo ，你可以了解 eventsource 的效果:</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/eventsource" target="_blank" rel="noopener">点击访问 https://gitee.com/eminoda/ssr-learn/tree/eventsource</a></p></blockquote><p><img src="https://gitee.com/eminoda/ssr-learn/raw/eventsource/doc/eventsource.gif" alt="eventsource"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有了 eventsource 的基础后，看这块基本没什么问题了，毕竟相比 webpack-dev-server 复杂度下降不少。</p><p>首先在客户端的 Network 看到有 /__webpack_hmr 的请求，从这里开始初始化 eventsource 连接和相关事件方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-hot-middleware\client.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  source = <span class="keyword">new</span> <span class="built_in">window</span>.EventSource(options.path);</span><br><span class="line">  source.onopen = handleOnline;</span><br><span class="line">  source.onerror = handleDisconnect;</span><br><span class="line">  source.onmessage = handleMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过中间件，判断是否进行服务端的事件推送：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-hot-middleware\middleware.js</span></span><br><span class="line"><span class="keyword">var</span> middleware = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">return</span> next();</span><br><span class="line">  <span class="comment">// 请求地址不是 _webpack_hmr 则跳过</span></span><br><span class="line">  <span class="keyword">if</span> (!pathMatch(req.url, opts.path)) <span class="keyword">return</span> next();</span><br><span class="line">  eventStream.handler(req, res);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建后的 eventsource 中，还有健康检查，保持通讯的畅通：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> interval = setInterval(<span class="function"><span class="keyword">function</span> <span class="title">heartbeatTick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  everyClient(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    client.write(<span class="string">"data: \uD83D\uDC93\n\n"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, heartbeat).unref();</span><br></pre></td></tr></table></figure><p>客户端预埋的代码和 webpack\hot\only-dev-server 类似，在结果模块的比对后，如果需要更新，则会执行 <strong>module.hot.check()</strong> 开始向服务端拉取更新代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!upToDate(hash) &amp;&amp; <span class="built_in">module</span>.hot.status() == <span class="string">"idle"</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.log) <span class="built_in">console</span>.log(<span class="string">"[HMR] Checking for updates on the server..."</span>);</span><br><span class="line">  check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">module</span>.hot.check(<span class="literal">false</span>, cb);</span><br></pre></td></tr></table></figure><p>在 cb 中，就会拉取 hot-update.json ，hot-update.js 资源了。</p><h2 id="koa-的兼容方式"><a href="#koa-的兼容方式" class="headerlink" title="koa 的兼容方式"></a>koa 的兼容方式</h2><p>很不幸主流的模块都是 express 中间件规范，长这样 fn(req,res,next) ，对于 fn(ctx,next) 需要做一些 refactor 。</p><p>当然已经有人做了 koa 专用的模块了 <strong>koa-webpack</strong> （热更新使用 <strong>webpack-hot-client</strong> ），看下 koa-hmr 开发模式怎么实现：</p><p>准备了个 Demo :</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/webpack-server-koa" target="_blank" rel="noopener">点击访问：https://gitee.com/eminoda/ssr-learn/tree/webpack-server-koa</a></p></blockquote><p><img src="https://gitee.com/eminoda/ssr-learn/raw/webpack-server-koa/doc/koawebpack.gif" alt="koa 构建"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://www.jianshu.com/p/3d7b0bbf435a" target="_blank" rel="noopener">JS 实时通信三把斧系列之三: eventsource</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource/EventSource" target="_blank" rel="noopener">MDN - EventSource</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">MDN - addEventListener</a></li><li><a href="https://www.cnblogs.com/liuyt/p/7217024.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">koa2 + webpack 热更新</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> hmr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索 webpack-dev-server 的 HMR</title>
      <link href="/legacy/2019/10/11/webpack-dev-server-hmr/"/>
      <url>/legacy/2019/10/11/webpack-dev-server-hmr/</url>
      
        <content type="html"><![CDATA[<p>相比直接刷新浏览器，通过 webpack 的 HMR 模式更能对开发效率有显著提升。</p><p>试想下：开发时，你对客户端的 js、css 做了小改动，浏览器没有再次向服务端发起请求，页面的修改区域就更新了代码，那多美好。</p><p>本篇先从 webpack-dev-server 着手，探索 webpack HMR 更新机制，<del>以及结合 webpack 在服务端的 SSR 构建做一些实践。</del>（篇幅过长，<a href="/2019/10/12/weback-middleware-in-hmr-development/">另开一篇说明：开发中如何接入 HRM 到服务端</a>）</p><h2 id="webpack-dev-server-自带的-HMR"><a href="#webpack-dev-server-自带的-HMR" class="headerlink" title="webpack-dev-server 自带的 HMR"></a>webpack-dev-server 自带的 HMR</h2><p>可以借助 webpack-dev-server 来开启一个服务，它具备代理、静态文件等功能，当然还有本篇的重点功能 ——<br><strong>Hot Module Reload（HMR）</strong></p><h3 id="零障碍开启-HMR"><a href="#零障碍开启-HMR" class="headerlink" title="零障碍开启 HMR"></a>零障碍开启 HMR</h3><p>我已经参照 webpack 官网的 Guide 写了个 Demo :</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/webpack-hmr-practice" target="_blank" rel="noopener">点击访问 https://gitee.com/eminoda/ssr-learn/tree/webpack-hmr-practice</a></p></blockquote><p><img src="https://gitee.com/eminoda/ssr-learn/raw/webpack-hmr-practice/doc/hrm-reload.gif" alt="hrm-reload"></p><h2 id="webpack-dev-server-如何实现-HMR"><a href="#webpack-dev-server-如何实现-HMR" class="headerlink" title="webpack-dev-server 如何实现 HMR"></a>webpack-dev-server 如何实现 HMR</h2><p>精力有限，webpack 相关的不做涉及，围绕 webpack-dev-server 对 HMR 的实现做说明。</p><h3 id="server-服务的创建"><a href="#server-服务的创建" class="headerlink" title="server 服务的创建"></a>server 服务的创建</h3><p>webpack-dev-server 提供一个服务功能，首先找到 Server 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\Server.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(compiler, options = &#123;&#125;, _log) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.setupApp();</span><br><span class="line">  &#125;</span><br><span class="line">  setupApp() &#123;</span><br><span class="line">    <span class="keyword">this</span>.app = <span class="keyword">new</span> express();</span><br><span class="line">  &#125;</span><br><span class="line">  createServer() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.listeningApp = http.createServer(<span class="keyword">this</span>.app);</span><br><span class="line">  &#125;</span><br><span class="line">  createSocketServer() &#123;</span><br><span class="line">    <span class="comment">// socket 实现（默认 sockjs）</span></span><br><span class="line">    <span class="keyword">this</span>.socketServer = <span class="keyword">new</span> SocketServerImplementation(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// server 开启监听时，创建 socket</span></span><br><span class="line">  listen(port, hostname, fn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listeningApp.listen(port, hostname, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.createSocketServer();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在里面会创建一个 express 服务，在其中开启一个 socket 套接字服务。HMR 就以此为桥梁互相通讯。</p><h4 id="socket-怎么通讯？"><a href="#socket-怎么通讯？" class="headerlink" title="socket 怎么通讯？"></a>socket 怎么通讯？</h4><p>不清楚 socket 的同学可以看下这个 Demo，体验 socket 怎么桥接服务端和客户端的通讯问题:</p><blockquote><p><a href="https://gitee.com/eminoda/ssr-learn/tree/sockjs" target="_blank" rel="noopener">点击访问 https://gitee.com/eminoda/ssr-learn/tree/sockjs</a></p></blockquote><p><img src="https://gitee.com/eminoda/ssr-learn/raw/sockjs/sockjs.gif" alt="sockjs"></p><h3 id="注入客户端-HMR-代码"><a href="#注入客户端-HMR-代码" class="headerlink" title="注入客户端 HMR 代码"></a>注入客户端 HMR 代码</h3><h4 id="添加-entry-文件"><a href="#添加-entry-文件" class="headerlink" title="添加 entry 文件"></a>添加 entry 文件</h4><p>更新 compiler 时，在原有配置上会插入额外的 entry 文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\utils\updateCompiler.js</span></span><br><span class="line">addEntries(webpackConfig, options);</span><br></pre></td></tr></table></figure><h5 id="check-entry"><a href="#check-entry" class="headerlink" title="check entry"></a>check entry</h5><p>entry 由 wepback 提供，根据配置的 hot、hotOnly 选项，加载指定的 entry 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\utils\addEntries.js</span></span><br><span class="line"><span class="keyword">if</span> (options.hotOnly) &#123;</span><br><span class="line">  hotEntry = <span class="built_in">require</span>.resolve(<span class="string">"webpack/hot/only-dev-server"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.hot) &#123;</span><br><span class="line">  hotEntry = <span class="built_in">require</span>.resolve(<span class="string">"webpack/hot/dev-server"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>only-dev-server 和 dev-server 这两者最大的不同，就是在异常情况下，对浏览器是否进行强刷：window.location.reload();</p><h5 id="client-entry"><a href="#client-entry" class="headerlink" title="client entry"></a>client entry</h5><p>由 webpack-dev-server 提供，包括 socket 、reloadApp 等代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> additionalEntries = checkInject(options.injectClient, config, webTarget) ? [clientEntry] : [];</span><br></pre></td></tr></table></figure><p>最后统统加到我们自己的 wepack 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">additionalEntries.push(hotEntry);</span><br></pre></td></tr></table></figure><h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><p>可以看到原始的 webpack 的 plugins 配置自动添加了 <strong>HotModuleReplacementPlugin：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\utils\addEntries.js</span></span><br><span class="line">config.plugins.push(<span class="keyword">new</span> webpack.HotModuleReplacementPlugin());</span><br></pre></td></tr></table></figure><p>通过 <strong>HotModuleReplacementPlugin</strong> 给客户端添加向服务端请求用来获取 <strong>hot-update.json</strong> 和 <strong>hot-update.js</strong> 文件的代码，来实现 HMR 功能。</p><h5 id="hot-update-json"><a href="#hot-update-json" class="headerlink" title="hot-update.json"></a>hot-update.json</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\web\JsonpMainTemplate.runtime.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotDownloadManifest</span>(<span class="params">requestTimeout</span>) </span>&#123;</span><br><span class="line">  requestTimeout = requestTimeout || <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";</span></span><br><span class="line">    <span class="keyword">var</span> requestPath = $<span class="built_in">require</span>$.p + $hotMainFilename$;</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// success</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> update = <span class="built_in">JSON</span>.parse(request.responseText);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(update);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hot-update-js"><a href="#hot-update-js" class="headerlink" title="hot-update.js"></a>hot-update.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\web\JsonpMainTemplate.runtime.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotDownloadUpdateChunk</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  script.charset = <span class="string">"utf-8"</span>;</span><br><span class="line">  <span class="comment">// script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";</span></span><br><span class="line">  script.src = $<span class="built_in">require</span>$.p + $hotChunkFilename$;</span><br><span class="line">  <span class="keyword">if</span> ($crossOriginLoading$) script.crossOrigin = $crossOriginLoading$;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这两段预先埋到客户端中的代码何时触发，之后再看。</p><h3 id="服务端与客户端的交互"><a href="#服务端与客户端的交互" class="headerlink" title="服务端与客户端的交互"></a>服务端与客户端的交互</h3><h4 id="如何通过-socket-通讯"><a href="#如何通过-socket-通讯" class="headerlink" title="如何通过 socket 通讯"></a>如何通过 socket 通讯</h4><p>借助封装的 sockWrite 方法，服务端将发送 hot、liveReload、invalid、progress、ok 等关键词以及对应的 data 信息 send 给客户端。</p><p>像是这样：{type:’ok’,msg:’foo’}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\Server.js</span></span><br><span class="line">sockWrite(sockets, type, data) &#123;</span><br><span class="line">  sockets.forEach(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.socketServer.send(socket, <span class="built_in">JSON</span>.stringify(&#123; type, data &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端拿到这些关键词匹配对应的执行逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\client\socket.js</span></span><br><span class="line">client.onMessage(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handlers[msg.type]) &#123;</span><br><span class="line">    handlers[msg.type](msg.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="socket-建立后的准备"><a href="#socket-建立后的准备" class="headerlink" title="socket 建立后的准备"></a>socket 建立后的准备</h4><p>socket 服务创建连接后，随着 webpack 的构建，会同步向客户端发送 webpack 的构建进度信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.socketServer.onConnection(<span class="function">(<span class="params">connection, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.sockWrite([connection], <span class="string">'hot'</span>);</span><br><span class="line">  <span class="keyword">this</span>.sockWrite([connection], <span class="string">'liveReload'</span>, <span class="keyword">this</span>.options.liveReload);</span><br><span class="line">  <span class="keyword">this</span>.sockWrite([connection], <span class="string">'progress'</span>, <span class="keyword">this</span>.progress);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端就会接收到这些信息，并打印输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[HMR] Waiting for update signal from WDS...</span><br><span class="line">client:48 [WDS] Hot Module Replacement enabled.</span><br><span class="line">client:52 [WDS] Live Reloading enabled.</span><br><span class="line">[WDS] 0% - compiling.</span><br><span class="line">[WDS] 10% - building (0&#x2F;0 modules).</span><br><span class="line">...</span><br><span class="line">[WDS] 100% - Compilation completed.</span><br></pre></td></tr></table></figure><h4 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h4><p>webpack-dev-server 会监听本地文件的修改保存，每当 webpack 编译完成后就发送 socket ，通知客户端重载更新代码，触发 <strong>reloadApp</strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack-dev-server\lib\Server.js</span></span><br><span class="line">done.tap(<span class="string">"webpack-dev-server"</span>, stats =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>._sendStats(<span class="keyword">this</span>.sockets, <span class="keyword">this</span>.getStats(stats));</span><br><span class="line">  <span class="keyword">this</span>._stats = stats;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.sockWrite(sockets, <span class="string">"hash"</span>, stats.hash); <span class="comment">// 关键依据</span></span><br><span class="line"><span class="keyword">this</span>.sockWrite(sockets, <span class="string">"ok"</span>);</span><br></pre></td></tr></table></figure><p>注意，服务端发送 ok 标识后，视线就该转到客户端，因为 reloadApp 的代码在客户端中。</p><h4 id="reloadApp"><a href="#reloadApp" class="headerlink" title="reloadApp()"></a>reloadApp()</h4><p>注意上述的 hash ，每次构建后 webpack 会将最新的 <strong>currentHash</strong> 通过 socket 告诉客户端，这是 HMR 是否执行的依据。</p><p>通知 <strong>webpackHotUpdate</strong> 事件，并传递 <strong>currentHash</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadApp</span>(<span class="params">_ref, _ref2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hotReload = _ref.hotReload,</span><br><span class="line">    hot = _ref.hot,</span><br><span class="line">    liveReload = _ref.liveReload;</span><br><span class="line">  <span class="keyword">var</span> isUnloading = _ref2.isUnloading,</span><br><span class="line">    currentHash = _ref2.currentHash;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">    log.info(<span class="string">"[WDS] App hot update..."</span>);</span><br><span class="line">    <span class="keyword">var</span> hotEmitter = <span class="built_in">require</span>(<span class="string">"webpack/hot/emitter"</span>);</span><br><span class="line">    hotEmitter.emit(<span class="string">"webpackHotUpdate"</span>, currentHash);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webpackHotUpdate</strong> 收到 <strong>currentHash</strong> ，调用 <strong>check</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\hot\only-dev-server.js</span></span><br><span class="line"><span class="comment">// webpack 热更新状态</span></span><br><span class="line">hotEmitter.on(<span class="string">"webpackHotUpdate"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">currentHash</span>) </span>&#123;</span><br><span class="line">  lastHash = currentHash;</span><br><span class="line">  <span class="comment">// 未更新完毕，查看状态，执行 check</span></span><br><span class="line">  <span class="keyword">if</span> (!upToDate()) &#123;</span><br><span class="line">    <span class="keyword">var</span> status = <span class="built_in">module</span>.hot.status();</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">"idle"</span>) &#123;</span><br><span class="line">      <span class="comment">// 确认更新情况</span></span><br><span class="line">      log(<span class="string">"info"</span>, <span class="string">"[HMR] Checking for updates on the server..."</span>);</span><br><span class="line">      check();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="check"><a href="#check" class="headerlink" title="check()"></a>check()</h4><p><strong>check</strong> 内部会执行 <strong>module.hot.check()</strong>，根据 <strong>upToDate</strong> 更新情况判断是否继续 <strong>check</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\hot\only-dev-server.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="keyword">var</span> check = <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot</span><br><span class="line">      .check()</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">updatedModules</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!updatedModules) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>.hot</span><br><span class="line">          .apply(&#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span>(<span class="params">renewedModules</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 未更新完毕，继续 check</span></span><br><span class="line">            <span class="keyword">if</span> (!upToDate()) &#123;</span><br><span class="line">              check();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">require</span>(<span class="string">"./log-apply-result"</span>)(updatedModules, renewedModules);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (upToDate()) &#123;</span><br><span class="line">              log(<span class="string">"info"</span>, <span class="string">"[HMR] App is up to date."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>module.hot.check</strong> 是 <strong>hotCheck</strong> 的赋值变量。代码在开始时已经通过 <strong>HotModuleReplacementPlugin</strong> 被打包到客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\HotModuleReplacement.runtime.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotCheck</span>(<span class="params">apply</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hotStatus !== <span class="string">"idle"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"check() is only allowed in idle status"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  hotApplyOnUpdate = apply;</span><br><span class="line">  hotSetStatus(<span class="string">"check"</span>);</span><br><span class="line">  <span class="keyword">return</span> hotDownloadManifest(hotRequestTimeout).then(<span class="function"><span class="keyword">function</span>(<span class="params">update</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      hotDeferred = &#123;</span><br><span class="line">        resolve: resolve,</span><br><span class="line">        reject: reject</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    hotUpdate = &#123;&#125;;</span><br><span class="line">    hotEnsureUpdateChunk(chunkId); <span class="comment">// hot-update.js</span></span><br><span class="line">    hotUpdateDownloaded();</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#hot-update-json"><strong>hotDownloadManifest</strong> 就是生成拉取 <strong>hot-update.json</strong> 的代码，参照：注入客户端 HMR 代码</a></p><p>获取到的 hot-update.json 就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"h"</span>:<span class="string">"ba41c82ba5dfb16b4a29"</span>,<span class="string">"c"</span>:&#123;<span class="string">"app"</span>:<span class="literal">true</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>这样的文件是通过 webpack 输出在内存中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\HotModuleReplacementPlugin.js</span></span><br><span class="line">compilation.hooks.additionalChunkAssets.tap(<span class="string">"HotModuleReplacementPlugin"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> records = compilation.records;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> hotUpdateMainContent = &#123;</span><br><span class="line">    h: compilation.hash,</span><br><span class="line">    c: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(records.chunkHashs)) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunkId = <span class="built_in">isNaN</span>(+key) ? key : +key;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    hotUpdateMainContent.c[chunkId] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="#hot-update-js">之后再执行 <strong>hotEnsureUpdateChunk</strong> （内部调用 <strong>hotDownloadUpdateChunk</strong> ）向服务端获取对应的 js 的代码，参照：注入客户端 HMR 代码</a></p><p>同样看下这代码如何生成：</p><p>在热更新中会执行 <strong>HotModuleReplacementPlugin</strong> 和 <strong>JsonpMainTemplatePlugin</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\HotModuleReplacementPlugin.js</span></span><br><span class="line">mainTemplate.hooks.bootstrap.tap(<span class="string">"HotModuleReplacementPlugin"</span>, (source, chunk, hash) =&gt; &#123;</span><br><span class="line">  source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\webpack\lib\web\JsonpMainTemplatePlugin.js</span></span><br><span class="line">mainTemplate.hooks.hotBootstrap.tap(<span class="string">"JsonpMainTemplatePlugin"</span>, (source, chunk, hash) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> runtimeSource = Template.getFunctionContent(<span class="built_in">require</span>(<span class="string">"./JsonpMainTemplate.runtime"</span>));</span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个 <strong>JsonpMainTemplate.runtime</strong> 有往页面 Head 中添加标签的逻辑。</p><p>最后交给 <strong>HotModuleReplacementPlugin</strong> 中的 <strong>source</strong> 输出到客户端代码中，这样就能在 html 看到新增的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"app.a924ad7db1acc3cd4b8e.hot-update.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Network 中看到这样的请求：</p><img src="/legacy/2019/10/11/webpack-dev-server-hmr/hrm-fetch.png" class=""><p>同时完毕后，控制台会有如下打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[WDS] App hot update...</span><br><span class="line">&#x2F;&#x2F; hot update code</span><br><span class="line">Accepting the updated printMe module!</span><br><span class="line">[HMR] Updated modules:</span><br><span class="line">[HMR]  - .&#x2F;src&#x2F;print.js</span><br><span class="line">[HMR] App is up to date.</span><br></pre></td></tr></table></figure><h2 id="全览整个-HMR-过程（图）"><a href="#全览整个-HMR-过程（图）" class="headerlink" title="全览整个 HMR 过程（图）"></a>全览整个 HMR 过程（图）</h2><img src="/legacy/2019/10/11/webpack-dev-server-hmr/wds-hrm.png" class="" title="整个 HMR 过程"><ol><li>设置 hot ，开启 HMR 功能（会对 webpack 的构建配置做修改，添加 entry 和 plugin）</li><li>webpack 监听、构建本地代码</li><li>将构建结果推送到内存中（client 的请求将从这里获取）</li><li>webpack-dev-server 开启 express 服务，并创建 stock 连接</li><li>实时对客户端发送 server 端的进度状态</li><li>如有代码更新，执行 check 进行检查</li><li>做是否需要更新 client 代码的判断</li><li>拉取 hot-update.json ,获取更新 chunk，判断 chunk 是否有不同</li><li>若有差异，拉取 hot-update.js ，热替换 client 代码</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://blog.csdn.net/gitchat/article/details/78341649" target="_blank" rel="noopener">webpack 是如何实现 HMR 的以及实现的原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/30669007" target="_blank" rel="noopener">知乎 - Webpack HMR 原理解析</a></li><li><a href="https://juejin.im/post/5d145d4e6fb9a07eee5ededa" target="_blank" rel="noopener">掘金 - webpack 实现 HMR 及其实现原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> hmr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>令人“头大”的 Nodejs 内存泄露</title>
      <link href="/legacy/2019/09/09/how-terrible-in-memory-leak/"/>
      <url>/legacy/2019/09/09/how-terrible-in-memory-leak/</url>
      
        <content type="html"><![CDATA[<p>线上环境居然遇到了内存泄露，经过 3 天的摸索，算是解决了：</p><blockquote><p>更换 pm2 版本，由 v3.5.1 降为 v3.4.1</p></blockquote><p>对于这个结论还是不太满意，算是歪打正着。不过还是记录下这几天<strong>积累的经验</strong>，说不定对正在看此文的你会有帮助。</p><h2 id="前言（鼓励）"><a href="#前言（鼓励）" class="headerlink" title="前言（鼓励）"></a>前言（鼓励）</h2><p>有幸，我这次有充足的时间去排查，没有其他事情干扰。但线上出现<strong>内存泄漏</strong>，解决起来比业务代码 bug 更难解决，那种头皮发麻的难受。原因如下：</p><ul><li>项目代码复杂。排查“泄漏点”，犹如大海捞针</li><li>开放的前端模式。顾及不暇的 node_modules 模块</li><li>无形的压力。需要时间拿数据做佐证，时间等的越长，压力越来</li></ul><p>不管有没有精力 or 能力，我认为 <strong>解决内存泄漏的最佳实践是：积极的心态 + 冷静的问题定位</strong>。（没错，这是对目前没有解决问题的你说的）</p><h2 id="内存增长的原因"><a href="#内存增长的原因" class="headerlink" title="内存增长的原因"></a>内存增长的原因</h2><p>可以看下这篇文章 <a href="https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html" target="_blank" rel="noopener">Finding And Fixing Node.js Memory Leaks: A Practical Guide</a></p><ul><li>全局变量</li><li>代码缓存</li><li>闭包</li><li>…</li></ul><p>Anyway，其实不管什么原因，主要还是 <strong>各种引用</strong> 得不到 V8 GC 的释放。扔一段很经典的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round((data / <span class="number">1024</span> / <span class="number">1024</span>) * <span class="number">100</span>) / <span class="number">100</span> + <span class="string">" MB"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mem = process.memoryUsage();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"memory now:"</span>, calc(mem.rss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  logger();</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"未被调用，但 originalThing 有个 someMethod 的引用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">"*"</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"没做任何事情，但我是闭包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"parse"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>执行没多久，就从 20M 飚到 几百 M。究其原因，还是因为闭包引用没有及时被销毁。</p><p>具体原因如下：</p><p>虽然 <strong>unused</strong> 没有被调用，但是其中包含 <strong>originalThing</strong> 并指向 <strong>theThing</strong> <strong>，theThing</strong> 在定义时有个 <strong>someMethod</strong> 方法，其就是个闭包（可以访问到 <strong>originalThing</strong>） ，该闭包在 <strong>unused</strong> 中由于引用了 <strong>originalThing</strong> 一直没有被释放。</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/scope-ref.png" class="" title="层层嵌套的引用"><h2 id="对内存进行“检查”"><a href="#对内存进行“检查”" class="headerlink" title="对内存进行“检查”"></a>对内存进行“检查”</h2><p>如果你对这块有查询过相关资料， <strong>heapdump</strong> 这模块应该频繁出现，这里说下如何使用它来监控项目的内存情况。当然还有 <strong>memwatch</strong> …</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install heapdump -S</span><br></pre></td></tr></table></figure><p>如果你足够幸运，肯定会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: #error This version of node&#x2F;NAN&#x2F;v8 requires a C++11 compiler</span><br></pre></td></tr></table></figure><p>原版本过低，需要更新 linux 系统的 gcc 等相关库。</p><p>参考如下安装说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 repo 仓库</span></span><br><span class="line">wget http://people.centos.org/tru/devtools-2/devtools-2.repo</span><br><span class="line">mv devtools-2.repo /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装新库</span></span><br><span class="line">yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份原库</span></span><br><span class="line">mv /usr/bin/gcc /usr/bin/gcc-4.4.7</span><br><span class="line">mv /usr/bin/g++ /usr/bin/g++-4.4.7</span><br><span class="line">mv /usr/bin/c++ /usr/bin/c++-4.4.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建快捷方式，将新库链到需要目录</span></span><br><span class="line">ln -s /opt/rh/devtoolset-2/root/usr/bin/gcc /usr/bin/gcc</span><br><span class="line">ln -s /opt/rh/devtoolset-2/root/usr/bin/c++ /usr/bin/c++</span><br><span class="line">ln -s /opt/rh/devtoolset-2/root/usr/bin/g++ /usr/bin/g++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查版本，确定生效</span></span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p>当然系统是 window 可能还会有更坑的问题：安装 node-gyp、python 出错。</p><p>推荐如下 npm 模块：</p><blockquote><p>windows-build-tools</p></blockquote><p>一键安装相关组件依赖（我们只要静静的等待，因为时间有些久）。他会帮你安装 window 对应的 <strong>NET Framework</strong>，python 这些插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>线上很简单的做了一个控制台输出，用于定位问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heapdump = <span class="built_in">require</span>(<span class="string">"heapdump"</span>);</span><br><span class="line"><span class="keyword">let</span> startMem = process.memoryUsage();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round((data / <span class="number">1024</span> / <span class="number">1024</span>) * <span class="number">10000</span>) / <span class="number">10000</span> + <span class="string">" MB"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用的是 koa</span></span><br><span class="line">router.all(<span class="string">"/foo"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> mem = process.memoryUsage();</span><br><span class="line">  logger.debug(<span class="string">"memory before"</span>, calc(startMem.rss), <span class="string">"memory now:"</span>, calc(mem.rss), <span class="string">"diff increase"</span>, calc(mem.rss - startMem.rss));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就能实时看到系统的内存消耗（对比刚启动时）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:06.700] [DEBUG] transfer - memory before 55.5898 MB memory now: 95.1484 MB diff increase 39.5586 MB</span><br><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:07.724] [DEBUG] transfer - memory before 56.2148 MB memory now: 69.8438 MB diff increase 13.6289 MB</span><br><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:10.406] [DEBUG] transfer - memory before 56.2148 MB memory now: 70.5977 MB diff increase 14.3828 MB</span><br><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:11.018] [DEBUG] transfer - memory before 55.5898 MB memory now: 95.4219 MB diff increase 39.832 MB</span><br><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:12.827] [DEBUG] transfer - memory before 55.5898 MB memory now: 95.6797 MB diff increase 40.0898 MB</span><br><span class="line">2019-09-06 16:30 +08:00: [2019-09-06T16:30:12.952] [DEBUG] transfer - memory before 55.5898 MB memory now: 94.9688 MB diff increase 39.3789 MB</span><br></pre></td></tr></table></figure><p>添加个快照路由，在按照需要抓取内存此刻使用情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.all(<span class="string">"/snapshot"</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  heapdump.writeSnapshot(<span class="string">"./dump-"</span> + <span class="built_in">Date</span>.now() + <span class="string">".heapsnapshot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>导入到 chrome 的 profile 面板中，对比前后两个文件的变化，定位问题</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/devtools.png" class="" title="profile"><p>一切顺利就能很快定位到问题代码。但实际要更困难，更摸不着头脑。</p><h2 id="猜测的可能点"><a href="#猜测的可能点" class="headerlink" title="猜测的可能点"></a>猜测的可能点</h2><p>如果按照上述的“检查”操作还是没有定位到问题点，可能这段会对你有所帮助。</p><p>首先要知道自己着手的项目的用途，所用技术，它对你排查问题更有指向意义。</p><p>比如：此项目是基于 node 的中间层服务，对 api 接口进行转换。用于由后端 api 服务的“升级”平滑各客户端的发版时差。（服务可能在 api 调用上有性能瓶颈？）</p><p>技术栈：sequelize + koa + pm2 （熟悉项目的主要框架，从大技术方向着手）</p><p>有幸有个 项目 B 和此项目类似，技术上略有差异。</p><p>综上所述，就猜测了几个可能的 <strong>内存泄露</strong> 原因（附参考文章）：</p><ul><li>代码问题<ul><li>代码逻辑全局缓存问题<ul><li><a href="https://www.mattzeunert.com/2017/01/31/weak-maps.html" target="_blank" rel="noopener">Difference between Map and WeakMap in JavaScript</a></li></ul></li><li>项目本身负载能力</li></ul></li><li>访问量（项目 A 高于 项目 B）<ul><li>对数据库的查询的冲击（sequelize）<ul><li><a href="https://github.com/sequelize/sequelize/issues/9062" target="_blank" rel="noopener">sequelize 4.37.7 造成内存泄漏</a></li><li><a href="https://github.com/sequelize/sequelize/issues/9276" target="_blank" rel="noopener">sequelize 中 ladash api 变量未回收</a></li></ul></li><li>日志读写堆积（log4js）<ul><li><a href="https://claude-ray.github.io/2018/12/21/pm2-cluster-log4js/" target="_blank" rel="noopener">PM2 cluster + log4js？并不理想的组合</a></li></ul></li></ul></li><li>第三方依赖<ul><li>pm2<ul><li><a href="https://github.com/Unitech/pm2/issues/4302" target="_blank" rel="noopener">pm2 memory leak</a></li></ul></li></ul></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><table><thead><tr><th>可能原因</th><th>测试方式</th><th>验证结果</th><th>备注</th></tr></thead><tbody><tr><td>代码问题</td><td>ab 压测</td><td>ok</td><td>但需增加重视</td></tr><tr><td>sequlize 版本问题</td><td>ab 压测</td><td>ok</td><td>暂不尝试。目前使用 4.42.0，线上无法承担更换版本的风险</td></tr><tr><td>Ladash _.template</td><td>ab 压测</td><td>ok</td><td>保持现状</td></tr><tr><td>log4js 有背压问题</td><td>ab 压测</td><td>ok</td><td>pm2 &amp; log4js 使用不够友好，在有替代方案前（比如 winston），保持现状</td></tr><tr><td>pm2 版本问题</td><td>线上降低版本 3.5.1 -&gt; 3.4.1</td><td>待验证</td><td>项目 B 使用 3.4.1</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这两天从线上情况上看，修改 pm2 版本后，内存泄漏得到控制。下面由此结论反推验证步骤：</p><ol><li><p>使用 devtools ，发现一天的内存差异，TIMERWRAP 指标突增：</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/pm2-timewrap.png" class="" title="profile"><p>TIMERWRAP 是 Node 里 Timer 相关定义，猜测是否有定时器在有规律的无限刷新占用性能。</p></li><li><p>继续查看，发现 pm2 有些“格格不入”</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/pm2-httpMetrics.png" class="" title="profile"><p>metrics 心跳检测，是否有 setTimeout 之类的代码？</p></li><li><p>查看资料，发现相关 issus 中说代码有 leak</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/pm2-io.jpg" class="" title="@pm2&#x2F;io"><p>查看线上项目相关代码，的确有这段问题代码：</p><img src="/legacy/2019/09/09/how-terrible-in-memory-leak/pm2-memory-leak.png" class="" title="@pm2&#x2F;io"><p>对于为何这段 if/else 会造成内存泄漏，有空再研究下。估计类似 dom 的 event 绑定没有解除所致。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/40733281" target="_blank" rel="noopener">深入解析 ES Module</a></li><li><a href="https://www.mattzeunert.com/2017/01/31/weak-maps.html" target="_blank" rel="noopener">Difference between Map and WeakMap in JavaScript</a></li><li><a href="http://voidcanvas.com/map-weakmap-pojo/" target="_blank" rel="noopener">ES6 Map vs WeakMap vs plain Objects – Describing the differences</a></li><li><a href="https://github.com/sequelize/sequelize/issues/9062" target="_blank" rel="noopener">sequelize 4.37.7 造成内存泄漏</a></li><li><a href="https://github.com/sequelize/sequelize/issues/9276" target="_blank" rel="noopener">sequelize 中 ladash api 变量未回收</a></li><li><a href="https://claude-ray.github.io/2018/12/21/pm2-cluster-log4js/" target="_blank" rel="noopener">PM2 cluster + log4js？并不理想的组合</a></li><li><a href="https://github.com/Unitech/pm2/issues/4302" target="_blank" rel="noopener">pm2 memory leak</a></li><li><a href="https://blog.csdn.net/f_9628/article/details/88708763" target="_blank" rel="noopener">记录一次安装 heapdump,报 node-gyp rebuild failed 的问题</a></li><li><a href="https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html" target="_blank" rel="noopener">Finding And Fixing Node.js Memory Leaks: A Practical Guide</a></li><li><a href="https://www.cnblogs.com/mliudong/p/3635294.html" target="_blank" rel="noopener">JavaScript 内存优化</a></li><li><a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156?gi=3db08c12c287" target="_blank" rel="noopener">An interesting kind of JavaScript memory leak</a></li><li><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">4 类 JavaScript 内存泄漏及如何避免</a></li><li><a href="https://juejin.im/post/5b3ae7b8f265da62cb1db9e0" target="_blank" rel="noopener">JavaScript 闭包详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES Module 和 CommonJS 的区别</title>
      <link href="/legacy/2019/08/07/vue-esm-vs-commonjs/"/>
      <url>/legacy/2019/08/07/vue-esm-vs-commonjs/</url>
      
        <content type="html"><![CDATA[<h2 id="从一个错误开始"><a href="#从一个错误开始" class="headerlink" title="从一个错误开始"></a>从一个错误开始</h2><p>在开始前，先补充一个知识点，看如下 Vue 报错日志：</p><blockquote><p>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p></blockquote><p>这个错误牵扯到针对不同的 vue 版本，业务代码写法也会有区别。</p><p>官网有详细的说明，<a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">对不同构建版本的解释</a></p><p>这里列出其中两个版本：</p><table><thead><tr><th>版本</th><th>CommonJs</th><th>ES Module</th></tr></thead><tbody><tr><td>完整版（运行 + 编译）</td><td>vue.common.js</td><td>vue.esm.js</td></tr><tr><td>运行版</td><td>vue.runtime.common.js</td><td>vue.runtime.esm.js</td></tr></tbody></table><p>安装 Vue 后，就能在 <strong>node_modules/vue/dist/</strong> 下看到所有的版本文件</p><h3 id="报错时的代码"><a href="#报错时的代码" class="headerlink" title="报错时的代码"></a>报错时的代码</h3><p>webpack.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    vue$: <span class="string">'vue/dist/vue.runtime.common.js'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="string">`&lt;div&gt;&lt;/div&gt;`</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123; template &#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>构建时，选择了运行 runtime 版本，他没有编译器功能，所以编译后出现了如上错误。</p><p>runtime 版本缺如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/vue/src/platforms/web/entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount; <span class="comment">// 公共 $mount 方法</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 会初始化 render 方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><h4 id="改用完整版"><a href="#改用完整版" class="headerlink" title="改用完整版"></a>改用完整版</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    vue$: <span class="string">'vue/dist/vue.esm.js'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供-render-函数"><a href="#提供-render-函数" class="headerlink" title="提供 render 函数"></a>提供 render 函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App) &#125;);</span><br></pre></td></tr></table></figure><p>版本依旧使用：vue.runtime.common.js</p><p><strong>优势</strong>：运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本（这也是官方推荐的）。</p><h2 id="ES-Module-和-CommonJS-区别"><a href="#ES-Module-和-CommonJS-区别" class="headerlink" title="ES Module 和 CommonJS 区别"></a>ES Module 和 CommonJS 区别</h2><p>前奏很漫长，似乎和这篇文章没什么关系。但要注意到这里 runtime 的版本用的是 ES Module 的方式。</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>Node 中一个模块加载方案，在服务端运行时，同步加载。注意，虽说取出模块内部的子方法，但在运行加载时，是取出所有的 fs 内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure><h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>js 在模块管理上一直百家齐放，什么 CommonJS、CMD、AMD、UMD …</p><p>为了统一模块的加载方式，ES6 推出了模块 Module 的概念，归根结底尽量使得在前端构建编译时，能确定各个模块之间的依赖。可以做“静态优化”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// esm 举例</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br></pre></td></tr></table></figure><p>有没有试过 CommonJS 的模块引入方式？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>);</span><br><span class="line"><span class="keyword">const</span> App = <span class="built_in">require</span>(<span class="string">'./App.vue'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// import Vue from 'vue';</span></span><br><span class="line"><span class="comment">// import App from './App.vue';</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; router, <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App) &#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>然后就报错了…，看下控制台 App 对象的信息：</p><img src="/legacy/2019/08/07/vue-esm-vs-commonjs/esm.png" class="" title="demo"><p>注意到 App 导出方式是使用 exports default 方式，所以在 CommonJS 引用时，会多个 default 属性。</p><h2 id="ES-Module-中一个错误"><a href="#ES-Module-中一个错误" class="headerlink" title="ES Module 中一个错误"></a>ES Module 中一个错误</h2><p>比较下面两种 esm export 写法：</p><h3 id="对象字面量导出"><a href="#对象字面量导出" class="headerlink" title="对象字面量导出"></a>对象字面量导出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">'./test'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> test;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'./test2'</span>;</span><br></pre></td></tr></table></figure><p>esm 是不支持前者这种导出方式，只是构建工具可能“会出错”，导致我们一致认为这种方式是没有问题的。</p><h3 id="正确的-export-姿势"><a href="#正确的-export-姿势" class="headerlink" title="正确的 export 姿势"></a>正确的 export 姿势</h3><p><strong>default</strong> 默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Test&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ol><li>在前端代码中，统一为 ES Module 加载方式</li><li>在使用 export default 默认方式时，不要使用对象字面量</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">阮一峰-Module 的语法</a></li><li><a href="http://www.xgllseo.com/?p=5595" target="_blank" rel="noopener">js 模块化 CommonJS、AMD、CMD、UMD 是什么意思</a></li><li><a href="https://zhuanlan.zhihu.com/p/40733281" target="_blank" rel="noopener">深入解析 ES Module</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger 在前端的使用</title>
      <link href="/legacy/2019/08/06/swagger-use-in-frontend/"/>
      <url>/legacy/2019/08/06/swagger-use-in-frontend/</url>
      
        <content type="html"><![CDATA[<p>一直游走于客户端开发，服务端没怎么涉及。之前团队有过这样的议题：Rap2 vs Swagger 哪个好？我真不知道怎么回答，因为没用过两者。</p><p>这篇，将尽可能“从无到有”来说明使用 Swagger 写文档在前端的使用的可行性。置于前面那个问题，在长时间的使用下肯定会有定论。</p><h2 id="大背景（流水账）"><a href="#大背景（流水账）" class="headerlink" title="大背景（流水账）"></a>大背景（流水账）</h2><p>在开始使用 Swagger 之前，先看下我们公司目前的情况。</p><h3 id="谁在使用"><a href="#谁在使用" class="headerlink" title="谁在使用"></a>谁在使用</h3><p>Java 是服务端“大户”。随着前后端分离，“使用方”（原生开发 er、前端开发 er）的不断加入。Java 开发们从自给自足，这时需要给外界提供更好的 Api 文档机制。这通常也是开发 <strong>最头疼</strong> 的玩意。</p><p>不断尝试摸索，文档方式从原先 Excel ，到 Gitbook、Wiki ，当然对于我们“使用方”来说，早就受够了他们提供的这些糟粕的文档。</p><p>上年，他们转战 Spring boot 玩新项目时，开始用了 Swagger ，同时也是我首次接触这么个工具。</p><p>相对于前些方式，Swagger 无论文档质量，还是更新维护都给我留下了不错的使用体验。</p><h3 id="前端的契机"><a href="#前端的契机" class="headerlink" title="前端的契机"></a>前端的契机</h3><p>是契机还是“坑”？</p><p>随着后端 Java 的逐渐“沉淀”，越来越多的需求冲突，场景问题暴露在现实中。公司开始增加 Node 在项目中的比重，前端慢慢的担当起整个链路上的主角（只是没有光环而已 :sweat_smile:，出问题还要背锅）</p><p>既然 Node 会在后端提供服务，那不可避免会和 Java 一样需要输出 Api 文档。有文档，就需要维护，有维护就会有成本。</p><p>面对更多的技术挑战，这到底是坑，还是契机，需要各位执行判断了。</p><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="编辑服务"><a href="#编辑服务" class="headerlink" title="编辑服务"></a>编辑服务</h3><p>swagger-api 提供了基础的 Swagger 服务，通过它能搭建一个最简单的 API 服务。</p><p>假如你是个有经验的前端开发，以下这些都不是什么问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g swagger</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 hello-world 项目</span></span><br><span class="line">swagger project create hello-world</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swagger 文档编辑模式</span></span><br><span class="line">swagger project edit</span><br></pre></td></tr></table></figure><p>一切 ok，你将看到一个 Swagger 基础的编辑页面</p><img src="/legacy/2019/08/06/swagger-use-in-frontend/swagger-edit.png" class="" title="edit-page"><p>如果“使用方”不在意这样的编辑模式，完全可以把这个服务放到测试环境，供团队使用。</p><p>当然还有些问题：</p><ul><li>可以再用 start 命令起个供接口调用的服务，但服务就会变成两个（edit 和 start）不易维护</li><li>edit 虽然有点同步更新作用，但和项目代码“离得太远”</li><li>通过 edit 维护，成本太高</li></ul><h3 id="初版服务"><a href="#初版服务" class="headerlink" title="初版服务"></a>初版服务</h3><p>是否有类似 Java 注解解析生成 Swagger 文档的工具？</p><p>答案是有的。</p><h4 id="jsdoc"><a href="#jsdoc" class="headerlink" title="jsdoc"></a>jsdoc</h4><p>在开始之前，先介绍前端 <strong>注释解析生成文档的工具 —— jsdoc</strong>，我觉得说下很有必要</p><p>按照 jsdoc 的规范，描述一个方法将通过如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function </span>GET /</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>首页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>ctx &#123;Number&#125; ctx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>ctx.username &#123;String&#125; 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>ctx.password &#123;Number&#125; 密码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Html&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> ctx.render(<span class="string">'index'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的注释有什么用？</p><ul><li>更规范的注释结构</li><li>通过命名，会自动输出文档（egg 的文档就是这样输出的）</li></ul><img src="/legacy/2019/08/06/swagger-use-in-frontend/jsdoc.png" class="" title="jsdoc 部分文档"><h4 id="swagger-jsdoc"><a href="#swagger-jsdoc" class="headerlink" title="swagger-jsdoc"></a>swagger-jsdoc</h4><p>参照 jsdoc ，很容易找到社区有类似的插件 swagger-jsdoc，作用就不在解释了，可以直接输出 Swagger 可识别的 json 规则。</p><p>使用 @swagger 作为注释解析的专用标题，注释以 yaml 维护</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * /user:</span></span><br><span class="line"><span class="comment"> *   get:</span></span><br><span class="line"><span class="comment"> *     description: 用户信息</span></span><br><span class="line"><span class="comment"> *     tags:</span></span><br><span class="line"><span class="comment"> *      - Users</span></span><br><span class="line"><span class="comment"> *     parameters:</span></span><br><span class="line"><span class="comment"> *      - name: username</span></span><br><span class="line"><span class="comment"> *        in: query</span></span><br><span class="line"><span class="comment"> *        description: 用户名</span></span><br><span class="line"><span class="comment"> *        required: true</span></span><br><span class="line"><span class="comment"> *        type: string</span></span><br><span class="line"><span class="comment"> *        default: '18702141422'</span></span><br><span class="line"><span class="comment"> *     responses:</span></span><br><span class="line"><span class="comment"> *       200:</span></span><br><span class="line"><span class="comment"> *         description: users</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  ctx.body = &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>声明一个 Swagger 定义文件 swaggerOptions.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  info: &#123;</span><br><span class="line">    <span class="comment">// API informations (required)</span></span><br><span class="line">    title: <span class="string">'Hello World'</span>, <span class="comment">// Title (required)</span></span><br><span class="line">    version: <span class="string">'1.0.0'</span>, <span class="comment">// Version (required)</span></span><br><span class="line">    description: <span class="string">'A sample API'</span> <span class="comment">// Description (optional)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  schemes: [<span class="string">'http'</span>],</span><br><span class="line">  consumes: [<span class="string">'application/x-www-form-urlencoded'</span>],</span><br><span class="line">  produces: [<span class="string">'application/json'</span>],</span><br><span class="line">  apis: [<span class="string">'./routes/global.js'</span>, <span class="string">'./routes/users.js'</span>],</span><br><span class="line">  basePath: <span class="string">'/api'</span> <span class="comment">// Base path (optional)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行命令，输出 swagger.json （后续使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger-jsdoc -d .&#x2F;swaggerOptions.js</span><br></pre></td></tr></table></figure><h4 id="swagger-ui"><a href="#swagger-ui" class="headerlink" title="swagger-ui"></a>swagger-ui</h4><p>swagger-api 社区也提供了一个 Swagger 风格的 ui 模块 —— swagger-ui</p><p>你可以结合自己项目的情况，选择 swagger-ui 细致化构建。但我这里直接使用 swagger-ui-dist 直接使用。</p><p>既然你是个有经验的开发者，相信对 express 不陌生，swagger-ui-dist 提供了页面所需要的 ui 组件，作为外部资源挂在到 express 公共目录上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> pathToSwaggerUi = <span class="built_in">require</span>(<span class="string">'swagger-ui-dist'</span>).absolutePath();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(pathToSwaggerUi));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>还记得前面的 swagger.json 吗？swagger-ui 需要这样一个 json 数据包，来显示文档数据。（我把它放到测试机上，并用 Nginx 提供了服务地址）</p><img src="/legacy/2019/08/06/swagger-use-in-frontend/swagger-ui.jpg" class="" title="swagger-ui"><h4 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h4><p>通过这几步，一套初步的前端 Swagger 方案应该能看到了：</p><ol><li>维护 yaml 格式的 swagger 注释，描述 api 信息</li><li>通过脚本，生成 swagger.json</li><li>访问 swagger-ui 服务，输入 swagger 数据源 swagger.json</li><li>查看 api 文档</li></ol><h3 id="自动化服务"><a href="#自动化服务" class="headerlink" title="自动化服务"></a>自动化服务</h3><p>相信还是不完美，中间需要运行脚本，还要手动输入 swagger.json 的地址。那有没有办法让 Swagger 文档跟随项目服务，项目一旦有改动提交自动更新 swagger 数据。</p><p>你是个有经验的前端开发，答案依旧有。这里只提供思路。</p><p>上例中，swagger-ui 基于 express 的公共服务，可以把这些 node_modules/swagger-ui 资源文件导出，放到自己项目中某个目录。</p><p>假如你也用 express 服务，可以设置专门的 Swagger 路径，这些在 <a href="https://www.npmjs.com/package/serve-static" target="_blank" rel="noopener">serve-static</a> 都有参考。</p><p>关键是其中的 index.html 中间的 script 脚本。</p><p>参考 swagger-ui 文档，他们已经为你想到了这一步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SwaggerUIBundle = <span class="built_in">require</span>(<span class="string">'swagger-ui-dist'</span>).SwaggerUIBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ui = SwaggerUIBundle(&#123;</span><br><span class="line">  url: <span class="string">'https://petstore.swagger.io/v2/swagger.json'</span>, <span class="comment">// swagger.json</span></span><br><span class="line">  dom_id: <span class="string">'#swagger-ui'</span>,</span><br><span class="line">  presets: [SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset],</span><br><span class="line">  layout: <span class="string">'StandaloneLayout'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就解决了 Swagger 跟随项目这个问题。他们是捆绑在一起的，访问项目服务的特殊路径，就能看到 API 文档。</p><p>那如何识别自动更新？</p><p>构建项目时，加个脚本即可。这里就不再展开了，webpack、gulp 挑个用就行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://github.com/swagger-api/swagger-node" target="_blank" rel="noopener">swagger</a></li><li><a href="https://github.com/Surnet/swagger-jsdoc" target="_blank" rel="noopener">swagger-jsdoc</a></li><li><a href="https://github.com/swagger-api/swagger-ui/blob/551007fe473980427e8b08ff8796ddea5585210e/docs/SUMMARY.md" target="_blank" rel="noopener">swagger-ui</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter 获取资源文件</title>
      <link href="/legacy/2019/08/02/jmeter-retrieve-resource/"/>
      <url>/legacy/2019/08/02/jmeter-retrieve-resource/</url>
      
        <content type="html"><![CDATA[<p>通过问题形式，逐渐让大家对这内容有个认识：</p><h2 id="如何使用-Jmeter-测试页面上的异步资源？"><a href="#如何使用-Jmeter-测试页面上的异步资源？" class="headerlink" title="如何使用 Jmeter 测试页面上的异步资源？"></a>如何使用 Jmeter 测试页面上的异步资源？</h2><p>如果之前有类似经验，很容易知道下图的含义：</p><img src="/legacy/2019/08/02/jmeter-retrieve-resource/jmeter-resource.png" class=""><p>通常我们会压测某个 API 接口的性能情况，但是如果测试前端页面时，却不能反应真实的页面负载情况，因为页面上存在大量的异步资源（图片、js、css）</p><p>勾选 <strong>Retrieve All Embedded Resources</strong> ，Jmeter 将自动为我们从页面上解析这些资源，并向服务端请求。</p><h2 id="加载异步资源后，会对测试有什么不同结果？"><a href="#加载异步资源后，会对测试有什么不同结果？" class="headerlink" title="加载异步资源后，会对测试有什么不同结果？"></a>加载异步资源后，会对测试有什么不同结果？</h2><p>先看下 2 组测试：</p><ul><li>测试首页。并发 100 次，不含资源</li><li>测试首页。并发 10 次，含资源（大致 26 个异步资源）</li></ul><img src="/legacy/2019/08/02/jmeter-retrieve-resource/result-api.jpg" class="" title="不含资源"><img src="/legacy/2019/08/02/jmeter-retrieve-resource/result-resource.jpg" class="" title="含资源"><p>发现测试同一页面在是否勾选加载异步资源上，性能差别很大（即使这里给加载资源这组测试，并发调整为 10 次）</p><h2 id="为什么会变得如此之差？"><a href="#为什么会变得如此之差？" class="headerlink" title="为什么会变得如此之差？"></a>为什么会变得如此之差？</h2><p>这个就涉及该选项 <strong>Retrieve All Embedded Resources</strong>，对资源是 <strong>并发请求</strong> 还是 <strong>队列请求</strong>。</p><p>经过测试：将其中一个异步资源 hold on 10 秒，结果发现后续请求都被 <strong>堵塞</strong>，证明该选项是会使请求挨个发出。</p><img src="/legacy/2019/08/02/jmeter-retrieve-resource/result.jpg" class=""><h2 id="怎么改成并发请求？"><a href="#怎么改成并发请求？" class="headerlink" title="怎么改成并发请求？"></a>怎么改成并发请求？</h2><p>勾选：<strong>Parallel downloads</strong>，并设置加载数量 Number，就可以改变其方式。</p><img src="/legacy/2019/08/02/jmeter-retrieve-resource/result-all.jpg" class=""><p>发现最慢的接口挪到了最后位，页面上的所有资源没有被异常堵塞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 免密操作</title>
      <link href="/legacy/2019/08/02/git-grant-auth/"/>
      <url>/legacy/2019/08/02/git-grant-auth/</url>
      
        <content type="html"><![CDATA[<p>在码云上有个 work 的项目，每次拉取都需要输入账号/密码，很烦。</p><img src="/legacy/2019/08/02/git-grant-auth/auth.jpg" class=""><p>查看了下如何关闭相关授权操作，有需要的同学可以参考。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>实现已设置好 ssh 相关信息，这里不作展开，可参见附录</li><li><p>授权 gitee 码云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><p>起初认为按照如上操作，就会和 linux ssh 免密登录一样可事实并非如此</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ssh-copy-id -i</span><br></pre></td></tr></table></figure><p>可事实并非如此，虽然成功，但 Gitee 并没有提供更多的权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi XXX! You&#39;ve successfully authenticated, but Gitee.com does not provide shell access.</span><br></pre></td></tr></table></figure></li><li><p>设置 git config</p><p>通过设置 git 配置，保存用户名和密码，让 git 帮我们做一次登录动作</p><p><strong>设置账号密码的储存时效</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>不过首次需要人工输入，之后就可以达到免密登录了，可以在 git 授权文件中查看到相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shixinghao@Lenovo-PC MINGW64 ~&#x2F;.ssh</span><br><span class="line">$ vi ~&#x2F;.git-credentials</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;your username:your password@gitee.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://blog.csdn.net/fg881218/article/details/86017187" target="_blank" rel="noopener">Git 免密码操作</a></li><li><a href="https://gitee.com/help/articles/4181#article-header0" target="_blank" rel="noopener">码云-生成/添加 SSH 公钥</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个我自己的 promise</title>
      <link href="/legacy/2019/07/12/js-my-promise/"/>
      <url>/legacy/2019/07/12/js-my-promise/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在老项目开发某功能，为了实现方便想用 promise，但因为浏览器兼容问题没有直接使用 promise，使用了 jquery 的 deferred ，对原生 promise 有了些疑问？</p><ul><li>jquery 怎么通过 deferred 支持类 promise 操作</li><li>怎么写个 promise-polyfill</li></ul><h2 id="先了解下-Promise"><a href="#先了解下-Promise" class="headerlink" title="先了解下 Promise"></a>先了解下 Promise</h2><p>首先 Promise 是一种异步解决方案，更友好的解决 js 里的“地狱回调”。</p><p>比如：我们有多个异步操作，为了让变量按照预设逻辑执行，代码就会变成如下回调循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="number">0</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  data++;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    data++;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      data++;</span><br><span class="line">      <span class="built_in">console</span>.log(data); <span class="comment">//  3</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果使用 Promise 就可以变成如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(++data);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> timePromiseFn(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> timePromiseFn(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>对比 callback 方式，promise 无论在编码方式（异步转 <strong>同步</strong>），还是 <strong>可读性</strong> 上面都有这巨大的提升。</p><h2 id="MyPromise-简单实现"><a href="#MyPromise-简单实现" class="headerlink" title="MyPromise 简单实现"></a>MyPromise 简单实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">lazyFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.lazyFn = lazyFn;</span><br><span class="line">  <span class="keyword">this</span>._resolve = <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      callback(data);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.lazyFn(<span class="keyword">this</span>._resolve(callback)); <span class="comment">// 执行异步函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'ok'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的实现牵扯一个重要的概念 —— <strong>高阶函数</strong></p><p>this._resolve 会返回一个高阶 function，并且这个 function 的参数 data 是 resolve(‘ok’) 中的 ok ；</p><p>在新建 MyPromise 对象后，将初始化一个延迟函数 this.lazyFn ，其需要一个 resolve 函数 ，就和原生 Promise 需要 resolve 和 reject 一样；</p><p>调用 then 后，传入 callback 函数，其是在延迟函数执行完，通过 this._resolve 返回的高阶函数后触发执行。</p><h2 id="别人怎么做的"><a href="#别人怎么做的" class="headerlink" title="别人怎么做的"></a>别人怎么做的</h2><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>简单的看下 jq 中 deferred 的 promise.then 的实现：</p><img src="/legacy/2019/07/12/js-my-promise/jquery-deferred.png" class="" title="jquery-deferred"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuples = [</span><br><span class="line">  <span class="comment">// action, add listener, listener list, final state</span></span><br><span class="line">  [<span class="string">'resolve'</span>, <span class="string">'done'</span>, jQuery.Callbacks(<span class="string">'once memory'</span>), <span class="string">'resolved'</span>],</span><br><span class="line">  [<span class="string">'reject'</span>, <span class="string">'fail'</span>, jQuery.Callbacks(<span class="string">'once memory'</span>), <span class="string">'rejected'</span>],</span><br><span class="line">  [<span class="string">'notify'</span>, <span class="string">'progress'</span>, jQuery.Callbacks(<span class="string">'memory'</span>)]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>tuples 定义了 promise 相关调用的 api ，调用 then 时就会遍历这些 api ，看哪些被用户定义使用；</p><img src="/legacy/2019/07/12/js-my-promise/jquery-deferred-ajax.png" class="" title="jquery-deferred-ajax"><p>比如上图的 ajax 调用，会把 jqXHR 推入到 deferred.promise 函数中，在 ajax 请求完毕后，执行对应的 resolve 方法。最后通知到 newDefer 执行对应 callback 。</p><h2 id="promise-polyfill"><a href="#promise-polyfill" class="headerlink" title="promise-polyfill"></a>promise-polyfill</h2><p>相对于 bluebird ，promise-polyfill 是一个轻量级的“腻子”，<a href="https://github.com/taylorhakes/promise-polyfill/blob/master/src/index.js" target="_blank" rel="noopener">点击直接查看源码</a></p><p>借它，看下正儿八经的 promise 如何实现：</p><ol><li>首先初始化</li></ol><p>在 new Promise 时调用创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promises must be constructed via new'</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'not a function'</span>);</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;!number&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">this</span>._state = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;!boolean&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">this</span>._handled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;Promise|undefined&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;!Array&lt;!Function&gt;&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">this</span>._deferreds = [];</span><br><span class="line"></span><br><span class="line">  doResolve(fn, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构建一个高阶函数，并执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResolve</span>(<span class="params">fn, self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        resolve(self, value);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        reject(self, reason);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    reject(self, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fn 即是新建 Promise 传入的函数，并且参数列表 resolve、reject 是对应传入的两个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fooTimer(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">'ok'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 fn 执行完异步方法后，就触发：resolve(‘ok’)</p><ol start="3"><li>执行 resolve function</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    resolve(self, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里的 newValue 即是 resolve 实际的参数。会根据 newValue 类型来做后续的判断（promise 链式调用等）</p><p>这里 newValue 是 resolve(‘ok’) 中的 ok</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">self, newValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure</span></span><br><span class="line">    <span class="keyword">if</span> (newValue === self) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'A promise cannot be resolved with itself.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">      <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        self._state = <span class="number">3</span>;</span><br><span class="line">        self._value = newValue;</span><br><span class="line">        finale(self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        doResolve(bind(then, newValue), self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self._state = <span class="number">1</span>;</span><br><span class="line">    self._value = newValue;</span><br><span class="line">    finale(self);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(self, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 Promise._state = 1，执行 finale</p><ol start="4"><li>对 Promise 流程做最后的控制</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self._state === <span class="number">2</span> &amp;&amp; self._deferreds.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>._immediateFn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!self._handled) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>._unhandledRejectionFn(self._value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = self._deferreds.length; i &lt; len; i++) &#123;</span><br><span class="line">    handle(self, self._deferreds[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  self._deferreds = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然由于 Promise._state == 1,Promise._deferreds.length == 0 ,所以什么都不会发生，只是运行了异步函数。</p><ol start="5"><li>then 的触发</li></ol><p>一开始，用户会调用 then ，接受成功和失败两个方法，再次初始化 Promise ，作用就是构造一个空的 Promise chain；</p><p>并执行 handle ，对 Promise.deferreds 放入 new Handler ，注意这里的 this ，其实是一开始的 new Promise 的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">var</span> prom = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(noop);</span><br><span class="line"></span><br><span class="line">  handle(<span class="keyword">this</span>, <span class="keyword">new</span> Handler(onFulfilled, onRejected, prom));</span><br><span class="line">  <span class="keyword">return</span> prom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>handle 会拿 deferred 的成功和失败做 callback 函数，并最后执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">self, deferred</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (self._state === <span class="number">3</span>) &#123;</span><br><span class="line">    self = self._value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self._state === <span class="number">0</span>) &#123;</span><br><span class="line">    self._deferreds.push(deferred);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self._handled = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">Promise</span>._immediateFn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cb = self._state === <span class="number">1</span> ? deferred.onFulfilled : deferred.onRejected;</span><br><span class="line">    <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">      (self._state === <span class="number">1</span> ? resolve : reject)(deferred.promise, self._value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = cb(self._value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(deferred.promise, e);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(deferred.promise, ret);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然只是分析最简单的 Promise 方式，关于 Promise chain 就根据 self._deferreds 和 resolve 中 newValue 类型判断对 Promise._state 做不同的标记来区分</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">Promises MDN</a></li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise 对象 阮一峰</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 盒子模型</title>
      <link href="/legacy/2019/07/11/css-box-model/"/>
      <url>/legacy/2019/07/11/css-box-model/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>浏览器引擎会根据 css 的盒子模型标准，将 css 中的颜色，大小，位置等属性定义在盒子中来渲染显示。</p><h3 id="四个边界"><a href="#四个边界" class="headerlink" title="四个边界"></a>四个边界</h3><ul><li>内容边界 content edge</li><li>内边距边界 padding edge</li><li>边框边界 border edge</li><li>外边框边界 margin edge</li></ul><img src="/legacy/2019/07/11/css-box-model/css-box-edge.png" class="" title="各边界"><h3 id="四个区域"><a href="#四个区域" class="headerlink" title="四个区域"></a>四个区域</h3><ul><li>内容区域 content area （白色）</li><li>内边距区域 padding area （蓝色）</li><li>边框区域 border area （浅粉色）</li><li>外边距区域 margin area （绿色）</li></ul><img src="/legacy/2019/07/11/css-box-model/css-box-content.png" class="" title="各区域"><h2 id="浏览器对内容区域的计算"><a href="#浏览器对内容区域的计算" class="headerlink" title="浏览器对内容区域的计算"></a>浏览器对内容区域的计算</h2><p>IE 和 Chrome 对内容区域的长宽计算方式是不同的</p><p><strong>Chrome</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.demo2</span> <span class="selector-class">.box-content</span> &#123;</span></span><br><span class="line">    margin: 20px;</span><br><span class="line">    padding: 20px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ffcc99</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#6699ff</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-content"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: #fff"</span>&gt;</span>长宽取值<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前元素内容区域的宽 = 内边距区域 + 边框区域 + 内容区域 = 20*2 + 5*2 + 64 = 114</p><img src="/legacy/2019/07/11/css-box-model/css-box-width.png" class="" title="chrome"><p><strong>IE</strong></p><p>说是 IE8 以下的内容宽度计算 = 边框区域 + 内容区域 （但我没有试过）</p><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><p>有时候会有这样的情况：修改内部元素的 padding、border 会影响父元素的长宽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.demo3</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#6699ff</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/07/11/css-box-model/box-sizing1.png" class="" title="正常情况"><p>父元素的宽 = item 的宽 + margin = (100+10)*4 + 2 = 442</p><p>当如果对 item 添加如下样式，就会影响到父元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/07/11/css-box-model/box-sizing2.png" class="" title="父元素变宽"><p>多增加了：padding + border = (10+5*2)*4 = 80</p><p>如果要修正这一问题，就需要了解 <strong>box-sizing</strong> 中的两个属性的不同：</p><ul><li><p>content-box<br>默认值。实际宽度 = content + padding + border</p></li><li><p>border-box<br>实际宽度 = content , content 内含 padding + border</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 子元素中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2019/07/11/css-box-model/box-sizing3.png" class="" title="box-sizing"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="noopener">CSS 基础框盒模型介绍 MDN</a></li><li><a href="https://www.cnblogs.com/zhujl/archive/2012/03/20/2408976.html" target="_blank" rel="noopener">CSS 解决高度自适应问题 cnblogs</a></li><li><a href="https://segmentfault.com/a/1190000013069516" target="_blank" rel="noopener">CSS 盒模型完整介绍 segmentfault</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2009/09/%E5%AF%B9html%E4%B8%8Ebody%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A0%94%E7%A9%B6%E4%B8%8E%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">对 html 与 body 的一些研究与理解 张鑫旭</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch 查询语言 Query DSL</title>
      <link href="/legacy/2019/07/08/elasticsearch-detail-dsl/"/>
      <url>/legacy/2019/07/08/elasticsearch-detail-dsl/</url>
      
        <content type="html"><![CDATA[<h2 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener">Query DSL</a></h2><blockquote><p>Domain Specific Language</p></blockquote><p>某种领域中特定的查询语言，这是是指 elasticsearch 中的 query 语言</p><h2 id="Query-and-filter-context"><a href="#Query-and-filter-context" class="headerlink" title="Query and filter context"></a>Query and filter context</h2><p>一段查询语句的结果集取决于其中所使用的 <strong>查询内容 query context</strong> 和 <strong>过滤内容 filter context</strong></p><h3 id="Query-context"><a href="#Query-context" class="headerlink" title="Query context"></a>Query context</h3><blockquote><p>How well does this document match this query clause?</p></blockquote><p>这个文档内容匹配查询语句结果怎么样？</p><p>注意，查询结果中的 score 受 query context 影响。</p><h3 id="Filter-context"><a href="#Filter-context" class="headerlink" title="Filter context"></a>Filter context</h3><blockquote><p>Does this document match this query clause?</p></blockquote><p>这个文档内容匹配这个查询语句吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET *nginx*&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;nginx.access.url&quot;:   &quot;&#x2F;favicon.ico&quot;        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123; &quot;term&quot;:  &#123; &quot;nginx.access.method&quot;: &quot;GET&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;range&quot;: &#123; &quot;nginx.access.body_sent.bytes&quot;: &#123; &quot;gte&quot;: 3000 &#125;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>整个 query 属于查询内容 query context</li><li>bool 和 match 被用于 query context 中，会影响查询分数</li><li>filter 用于过滤查询内容</li><li>term 和 range 被用于 filter context 中，不会影响分数</li></ul><h2 id="Match-All-Query"><a href="#Match-All-Query" class="headerlink" title="Match All Query"></a>Match All Query</h2><h3 id="Match-All-Query-1"><a href="#Match-All-Query-1" class="headerlink" title="Match All Query"></a>Match All Query</h3><p>最简单的查询方式。查询所有匹配的 documents，如果全部查询出来，则 _score = 1.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET *nginx*&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以设置 boost 来改变结果分数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET *nginx*&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">      &quot;boost&quot; : 1.2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 8,</span><br><span class="line">    &quot;max_score&quot; : 1.2,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_score&quot; : 1.2,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Match-None-Query"><a href="#Match-None-Query" class="headerlink" title="Match None Query"></a>Match None Query</h3><p>是 match_all 的反例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET *nginx*&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_none&quot;:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 0,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Full-text-queries"><a href="#Full-text-queries" class="headerlink" title="Full text queries"></a>Full text queries</h2><p>全文查询允许搜索分析文本字段，在索引中，利用查询字符串处理相同的分析器。</p><p>预存数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;eminoda_test&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda&quot;,</span><br><span class="line">  &quot;age&quot;:30,</span><br><span class="line">  &quot;skill&quot;:&quot;vue node&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST &#x2F;eminoda_test&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;mike&quot;,</span><br><span class="line">  &quot;age&quot;:40,</span><br><span class="line">  &quot;skill&quot;:&quot;angular node&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST &#x2F;eminoda_test&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;cc&quot;,</span><br><span class="line">  &quot;age&quot;:50,</span><br><span class="line">  &quot;skill&quot;:&quot;reactive jquery&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-query"><a href="#match-query" class="headerlink" title="match query"></a>match query</h3><blockquote><p>The standard query for performing full text queries, including fuzzy matching and phrase or proximity queries.</p></blockquote><p>这是个标准的查询匹配方式来进行全文匹配,包括模糊，短语，近似查询。</p><p>match 接受 text/numerics/dates ，构造一个查询请求，并且分析查询结果。</p><p>查询 eminoda_test 索引，documents 中字段为 name ，值为 eminoda 的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;eminoda&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 1,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;max_score&quot; : 0.2876821,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;DP1sz2sBqZI9Rs_eLn_H&quot;,</span><br><span class="line">        &quot;_score&quot; : 0.2876821,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;name&quot; : &quot;eminoda&quot;,</span><br><span class="line">          &quot;age&quot; : 30,</span><br><span class="line">          &quot;skill&quot; : &quot;vue node&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>match query</strong> 处理结果是 bool 类型。会构造一个 bool 的查询对 text 文本的分析结果进行返回，默认会对 text 的内容进行 or 操作（有 or 和 and）。</p><p>默认搜索器：default search analyzer</p><p>比如，skill = jquery node 会返回 3 条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;skill&quot;: &quot;jquery node&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 3,</span><br><span class="line">  &quot;max_score&quot; : 0.2876821,</span><br><span class="line">  &quot;hits&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;Df1sz2sBqZI9Rs_eNn-v&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;mike&quot;,</span><br><span class="line">        &quot;age&quot; : 40,</span><br><span class="line">        &quot;skill&quot; : &quot;angular node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;Dv1sz2sBqZI9Rs_ePn_E&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;cc&quot;,</span><br><span class="line">        &quot;age&quot; : 50,</span><br><span class="line">        &quot;skill&quot; : &quot;reactive jquery&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;DP1sz2sBqZI9Rs_eLn_H&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;age&quot; : 30,</span><br><span class="line">        &quot;skill&quot; : &quot;vue node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置 operator = and ，则会对结果有影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;skill&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;jquery node&quot;,</span><br><span class="line">        &quot;operator&quot;:&quot;and&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 0,</span><br><span class="line">  &quot;max_score&quot; : null,</span><br><span class="line">  &quot;hits&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#fuzziness" target="_blank" rel="noopener">fuzziness</a></strong> 允许对模糊查询，并可以设置模糊度。规范讲应该是：<a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="noopener">Levenshtein Edit Distance</a></p><p>如，允许对 skill 的 text “出错” 2 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;skill&quot;:&#123;</span><br><span class="line">        &quot;query&quot;:&quot;angularjs&quot;,</span><br><span class="line">        &quot;fuzziness&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 1,</span><br><span class="line">  &quot;max_score&quot; : 0.2054872,</span><br><span class="line">  &quot;hits&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;Df1sz2sBqZI9Rs_eNn-v&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2054872,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;mike&quot;,</span><br><span class="line">        &quot;age&quot; : 40,</span><br><span class="line">        &quot;skill&quot; : &quot;angular node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-phrase-query"><a href="#match-phrase-query" class="headerlink" title="match_phrase query"></a>match_phrase query</h3><blockquote><p>Like the match query but used for matching exact phrases or word proximity matches.</p></blockquote><p>和 match query 类似，但多用于匹配短语 or 单词的接近匹配。</p><p>如果用 match 方式，则会返回 <strong>三条</strong> 记录，此匹配会以 text 内容做精确匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;skill&quot;: &quot;jquery node&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 0,</span><br><span class="line">  &quot;max_score&quot; : null,</span><br><span class="line">  &quot;hits&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-phrase-prefix-query"><a href="#match-phrase-prefix-query" class="headerlink" title="match_phrase_prefix query"></a>match_phrase_prefix query</h3><blockquote><p>Like the match_phrase query, but does a wildcard search on the final word.</p></blockquote><p>和 match_phrase query 类似，但通过通配符作用于最后个单词匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot;: &#123;</span><br><span class="line">      &quot;skill&quot;: &quot;a&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 1,</span><br><span class="line">  &quot;max_score&quot; : 0.2876821,</span><br><span class="line">  &quot;hits&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;Df1sz2sBqZI9Rs_eNn-v&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;mike&quot;,</span><br><span class="line">        &quot;age&quot; : 40,</span><br><span class="line">        &quot;skill&quot; : &quot;angular node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-bool-prefix-query"><a href="#match-bool-prefix-query" class="headerlink" title="match_bool_prefix query"></a>match_bool_prefix query</h3><blockquote><p>Creates a bool query that matches each term as a term query, except for the last term, which is matched as a prefix query</p></blockquote><p>创建一个 bool 查询来匹配查询结果，除了最后一个作为前缀查询匹配</p><h3 id="multi-match-query"><a href="#multi-match-query" class="headerlink" title="multi_match query"></a>multi_match query</h3><blockquote><p>The multi-field version of the match query.</p></blockquote><p>多结果匹配查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;eminoda learn angular&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;,&quot;skill&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 2,</span><br><span class="line">  &quot;max_score&quot; : 0.2876821,</span><br><span class="line">  &quot;hits&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;Df1sz2sBqZI9Rs_eNn-v&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;mike&quot;,</span><br><span class="line">        &quot;age&quot; : 40,</span><br><span class="line">        &quot;skill&quot; : &quot;angular node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;DP1sz2sBqZI9Rs_eLn_H&quot;,</span><br><span class="line">      &quot;_score&quot; : 0.2876821,</span><br><span class="line">      &quot;_source&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;age&quot; : 30,</span><br><span class="line">        &quot;skill&quot; : &quot;vue node&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="common-terms-query"><a href="#common-terms-query" class="headerlink" title="common terms query"></a>common terms query</h3><blockquote><p>A more specialized query which gives more preference to uncommon words.</p></blockquote><p>更特殊的查询方式，针对不友好的单词。</p><h3 id="query-string-query"><a href="#query-string-query" class="headerlink" title="query_string query"></a>query_string query</h3><blockquote><p>Supports the compact Lucene query string syntax, allowing you to specify AND|OR|NOT conditions and multi-field search within a single query string. For expert users only.</p></blockquote><p>支持 Lucene 查询字符串语法，允许使用特殊的条件（and、or、not），和多条件的搜索一个简单的查询字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda_test&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;query_string&quot;: &#123;</span><br><span class="line">      &quot;default_field&quot;: &quot;name&quot;,</span><br><span class="line">      &quot;query&quot;: &quot;mike or eminoda&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="simple-query-string-query"><a href="#simple-query-string-query" class="headerlink" title="simple_query_string query"></a>simple_query_string query</h3><blockquote><p>A simpler, more robust version of the query_string syntax suitable for exposing directly to users.</p></blockquote><h3 id="intervals-query"><a href="#intervals-query" class="headerlink" title="intervals query"></a>intervals query</h3><blockquote><p>A full text query that allows fine-grained control of the ordering and proximity of matching terms</p></blockquote><p>细粒度控制相近匹配结果</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上列出目前使用过的几种，其他方式未花时间做过多实践。可结合官网在做深入。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch Document 文档操作</title>
      <link href="/legacy/2019/07/05/elasticsearch-detail-document/"/>
      <url>/legacy/2019/07/05/elasticsearch-detail-document/</url>
      
        <content type="html"><![CDATA[<h2 id="Reading-and-Writing-documents"><a href="#Reading-and-Writing-documents" class="headerlink" title="Reading and Writing documents"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#_introduction" target="_blank" rel="noopener">Reading and Writing documents</a></h2><p>Elasticsearch 中的索引 index 被划分在 <strong>分片 shards</strong> 中，每个 shard 会有多个副本 copies。</p><p>这些 copies 称为副本集 <strong>replication group</strong>，在添加和移除 documents 的过程中会同步这些 copies。</p><p>因为数据集的同步化，让我们在不同 shards 中获取数据一致性，这样称为 replication model 数据副本模型。</p><p>Elasticsearch 的数据副本模型 replication model 基于主备份模型 primary-backup model，类似分布式存储系统（Replication in Log-Based Distributed Storage Systems）</p><p>关于 documents 的读写设计思想如下：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#_basic_write_model" target="_blank" rel="noopener">basic_write_model</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#_basic_read_model" target="_blank" rel="noopener">basic_read_model</a></li></ul><h2 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h2><h3 id="添加新索引（设置了索引-id）"><a href="#添加新索引（设置了索引-id）" class="headerlink" title="添加新索引（设置了索引 id）"></a>添加新索引（设置了索引 id）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT eminoda_test&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;30&quot;,</span><br><span class="line">  &quot;skill&quot;:&quot;vue node&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,  # 索引名称</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,           # 类型</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;               # 见下 shards 描述</span><br><span class="line">    &quot;total&quot; : 2,              # 一共在多少个 shard copies 上操作</span><br><span class="line">    &quot;successful&quot; : 1,         # 有多少个 shard copies 成功执行</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果再次执行上述操作，result 将为 updated ，可以设置 <strong>op_type</strong> 参数，使已创建的 doc 再次创建有报错提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT eminoda_test&#x2F;_doc&#x2F;1?op_type&#x3D;create</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;30&quot;,</span><br><span class="line">  &quot;skill&quot;:&quot;vue node&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[_doc][1]: version conflict, document already exists (current version [2])&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;bzQU4HCBRxeDAfyX7IPnHw&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;eminoda_test&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;[_doc][1]: version conflict, document already exists (current version [2])&quot;,</span><br><span class="line">    &quot;index_uuid&quot;: &quot;bzQU4HCBRxeDAfyX7IPnHw&quot;,</span><br><span class="line">    &quot;shard&quot;: &quot;3&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;eminoda_test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shards"><a href="#shards" class="headerlink" title="shards"></a>shards</h3><p>你可以直接阅读 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/scalability.html#scalability" target="_blank" rel="noopener">shards</a></p><p>首先，Elasticsearch 可以按照用户设置进行扩容 increase capacity ，会自动分发 automatically distributes 数据到节点，查询操作在各个节点上平衡负载。Elasticsearch 有自己的策略。</p><p>Elasticsearch 的 index 索引在一个逻辑分组上 or 多个物理分区上 physical shards ，每个分区 shards 又一个属于它的索引 index。</p><p>数据的分发将一个索引横跨多个 shards ，多个 shards 有横跨多个 nodes 节点。Elasticsearch 会自己控制数据的冗余 redundancy，使这些 shards 平衡。</p><p>shards 分为两种类型：</p><ul><li>primaries 主区</li><li>replicas 副本区</li></ul><p>replicas 是从 primaries 中备份数据，每个 document 索引 index 只属于一个 primaries。</p><h3 id="添加索引（未指定-id）"><a href="#添加索引（未指定-id）" class="headerlink" title="添加索引（未指定 id）"></a>添加索引（未指定 id）</h3><p>上例使用 PUT 指定了索引 id，使用 POST 可以使用让 elasticsearch 自己生成索引值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST eminoda_test&#x2F;\_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda2&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;30&quot;,</span><br><span class="line">  &quot;skill&quot;:&quot;vue node&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;I7nuwGsBjRxZrv4loy0h&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭新建索引"><a href="#关闭新建索引" class="headerlink" title="关闭新建索引"></a>关闭新建索引</h3><p>更改规则，关闭自建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster&#x2F;settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;persistent&quot;: &#123;</span><br><span class="line">    &quot;action.auto_create_index&quot;:&quot;false&quot; # 默认 true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个再通过 POST、PUT 就无法新建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &#123;</span><br><span class="line">    &quot;root_cause&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;no such index&quot;,</span><br><span class="line">        &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">        &quot;resource.id&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">        &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">        &quot;index&quot; : &quot;eminoda_test&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot; : &quot;index_not_found_exception&quot;,</span><br><span class="line">    &quot;reason&quot; : &quot;no such index&quot;,</span><br><span class="line">    &quot;resource.type&quot; : &quot;index_expression&quot;,</span><br><span class="line">    &quot;resource.id&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">    &quot;index_uuid&quot; : &quot;_na_&quot;,</span><br><span class="line">    &quot;index&quot; : &quot;eminoda_test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot; : 404</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>可以这是一个 <strong>控制器</strong> ，比如 routing，设置一个简单的映射关系，让查询更快速高效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST eminoda_test/_doc?routing=admin</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"eminoda2"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"30"</span>,</span><br><span class="line">  <span class="string">"skill"</span>:<span class="string">"vue node"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的数据中会新添加 _routing 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;X7n9wGsBjRxZrv4lpy1O&quot;,</span><br><span class="line">  &quot;_score&quot; : 1.0,</span><br><span class="line">  &quot;_routing&quot; : &quot;admin&quot;,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;name&quot; : &quot;eminoda2&quot;,</span><br><span class="line">    &quot;age&quot; : &quot;30&quot;,</span><br><span class="line">    &quot;skill&quot; : &quot;vue node&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h2><h3 id="指定-id-查询"><a href="#指定-id-查询" class="headerlink" title="指定 id 查询"></a>指定 id 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET eminoda_test&#x2F;_doc&#x2F;1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;name&quot; : &quot;eminoda&quot;,</span><br><span class="line">    &quot;age&quot; : &quot;30&quot;,</span><br><span class="line">    &quot;skill&quot; : &quot;vue node&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="屏蔽-source-数据信息"><a href="#屏蔽-source-数据信息" class="headerlink" title="屏蔽 _source 数据信息"></a>屏蔽 _source 数据信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET eminoda_test&#x2F;_doc&#x2F;1?_source&#x3D;false</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stored-fields-过滤信息"><a href="#stored-fields-过滤信息" class="headerlink" title="stored_fields 过滤信息"></a>stored_fields 过滤信息</h3><p>定义数据类型，每个字段 Field 上定义额外属性 store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT eminoda_test</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;_doc&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;nick&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">          &quot;store&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;nick2&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;text&quot;,</span><br><span class="line">          &quot;store&quot;:false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT eminoda_test&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;nick&quot;:&quot;abc&quot;,</span><br><span class="line">  &quot;nick2&quot;:&quot;efg&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <strong>stored_fields</strong> 查询，定义 store=false 的字段将被过滤出去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET eminoda_test&#x2F;_doc&#x2F;1?stored_fields&#x3D;nick,nick2</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;fields&quot; : &#123;</span><br><span class="line">    &quot;nick&quot; : [</span><br><span class="line">      &quot;abc&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h2><h3 id="删除单个"><a href="#删除单个" class="headerlink" title="删除单个"></a>删除单个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE eminoda_test&#x2F;_doc&#x2F;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;result&quot; : &quot;deleted&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 1,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全部删除"><a href="#全部删除" class="headerlink" title="全部删除"></a>全部删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE eminoda_test</span><br></pre></td></tr></table></figure><h2 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h2><p>如果没有特殊指定 op_type=create ，PUT 操作会对已添加的 doc 进行 udpate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUT eminoda_test&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;30&quot;,</span><br><span class="line">  &quot;skill&quot;:&quot;vue node&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda_test&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 1,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据查询语句更新"><a href="#根据查询语句更新" class="headerlink" title="根据查询语句更新"></a>根据查询语句更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST eminoda_test&#x2F;_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.age &#x3D; 33&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 7,             #操作用时</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;total&quot; : 1,</span><br><span class="line">  &quot;updated&quot; : 1,</span><br><span class="line">  &quot;deleted&quot; : 0,</span><br><span class="line">  &quot;batches&quot; : 1,</span><br><span class="line">  &quot;version_conflicts&quot; : 0,</span><br><span class="line">  &quot;noops&quot; : 0,</span><br><span class="line">  &quot;retries&quot; : &#123;</span><br><span class="line">    &quot;bulk&quot; : 0,</span><br><span class="line">    &quot;search&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;throttled_millis&quot; : 0,</span><br><span class="line">  &quot;requests_per_second&quot; : -1.0,</span><br><span class="line">  &quot;throttled_until_millis&quot; : 0,</span><br><span class="line">  &quot;failures&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bluk-API"><a href="#Bluk-API" class="headerlink" title="Bluk API"></a>Bluk API</h3><p>版本估计不对，没试出来</p><h3 id="ReIndex-API"><a href="#ReIndex-API" class="headerlink" title="ReIndex API"></a>ReIndex API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;eminoda_test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;:&#123;</span><br><span class="line">    &quot;index&quot;:&quot;eminoda_test_bak&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#! Deprecation: the default number of shards will change from [5] to [1] in 7.0.0; if you wish to continue using the default of [5] shards, you must manage this on the create index request or with an index template</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 97,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;total&quot; : 1,</span><br><span class="line">  &quot;updated&quot; : 0,</span><br><span class="line">  &quot;created&quot; : 1,</span><br><span class="line">  &quot;deleted&quot; : 0,</span><br><span class="line">  &quot;batches&quot; : 1,</span><br><span class="line">  &quot;version_conflicts&quot; : 0,</span><br><span class="line">  &quot;noops&quot; : 0,</span><br><span class="line">  &quot;retries&quot; : &#123;</span><br><span class="line">    &quot;bulk&quot; : 0,</span><br><span class="line">    &quot;search&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;throttled_millis&quot; : 0,</span><br><span class="line">  &quot;requests_per_second&quot; : -1.0,</span><br><span class="line">  &quot;throttled_until_millis&quot; : 0,</span><br><span class="line">  &quot;failures&quot; : [ ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能检查 performance</title>
      <link href="/legacy/2019/06/08/window-performance/"/>
      <url>/legacy/2019/06/08/window-performance/</url>
      
        <content type="html"><![CDATA[<p>看 Vue 时注意到如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span>;</span><br><span class="line">mark(startTag);</span><br><span class="line">do_work();</span><br><span class="line">vm._name = formatComponentName(vm, <span class="literal">false</span>);</span><br><span class="line">mark(endTag);</span><br><span class="line">measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag);</span><br></pre></td></tr></table></figure><p>基本能猜到里面是在做什么， 分别在 do_work() 前后打标点， 然后计算执行该方法的消耗</p><p>mark 和 measure 定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> perf = <span class="built_in">window</span>.performance;</span><br><span class="line">mark = <span class="function"><span class="params">tag</span> =&gt;</span> perf.mark(tag);</span><br><span class="line">measure = <span class="function">(<span class="params">name, startTag, endTag</span>) =&gt;</span> &#123;</span><br><span class="line">  perf.measure(name, startTag, endTag);</span><br><span class="line">  perf.clearMarks(startTag);</span><br><span class="line">  perf.clearMarks(endTag);</span><br><span class="line">  <span class="comment">// perf.clearMeasures(name)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我没有用过 window.performance， 那它到底是什么？ 现在开始学习吧。</p><h1 id="window-performance"><a href="#window-performance" class="headerlink" title="window.performance"></a>window.performance</h1><blockquote><p>Web Performance API 允许网页访问某些函数来测量网页和 Web 应用程序的性能， 包括 Navigation Timing API 和高分辨率时间数据。</p></blockquote><p>既然是性能测量， 那看下如何设置？</p><h2 id="如何预埋测试区域"><a href="#如何预埋测试区域" class="headerlink" title="如何预埋测试区域"></a>如何预埋测试区域</h2><p>这涉及 mark() 和 measure() 两个 api。</p><p><strong>mark()</strong></p><p>根据给出 name 值， 在浏览器的性能输入缓冲区中创建一个相关的 timestamp</p><p><strong>measure()</strong></p><p>在浏览器的指定 start mark 和 end mark 间的性能输入缓冲区中创建一个指定的 timestamp</p><p>看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> perf = <span class="built_in">window</span>.performance;</span><br><span class="line"></span><br><span class="line">perf.mark(<span class="string">'test-start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  perf.mark(<span class="string">'test-end'</span>);</span><br><span class="line">  perf.measure(<span class="string">'test'</span>, <span class="string">'test-start'</span>, <span class="string">'test-end'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>用 setTimeout 模拟执行某个耗时事件， 前后分别用 mark() 进行预埋测试点， 最后用 measure() 进行测试。</p><h2 id="怎么查看埋点性能值"><a href="#怎么查看埋点性能值" class="headerlink" title="怎么查看埋点性能值"></a>怎么查看埋点性能值</h2><p>我们可以使用如下方法获得所有的性能结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf.getEntries(); <span class="comment">// return PerformanceEntry</span></span><br></pre></td></tr></table></figure><p><strong>PerformanceEntry</strong></p><blockquote><p>对象代表了 performance 时间列表中的单个 metric 数据. 每一个 performance entry 都可以在应用运行过程中通过手动构建 mark 或者 measure (例如调用 mark() 方法) 生成. 此外, Performance entries 在资源加载的时候， 也会被动生成（例如图片、 script、 css 等资源加载）</p></blockquote><img src="/legacy/2019/06/08/window-performance/result.png" class="" title="getEntries"><p>以上结果较多， 可以用这两个 api 进行筛选输出（name or entryType）：</p><ul><li>performance.getEntriesByName(name, type);</li><li>performance.getEntriesByType(type);</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perf.getEntriesByName(<span class="string">'test'</span>);</span><br><span class="line"><span class="comment">// 会输出一个 [PerformanceMeasure] 数组对象</span></span><br><span class="line"><span class="comment">// [&#123;</span></span><br><span class="line"><span class="comment">//      duration: 1000.4449998959899</span></span><br><span class="line"><span class="comment">//      entryType: "measure"</span></span><br><span class="line"><span class="comment">//      name: "test"</span></span><br><span class="line"><span class="comment">//      startTime: 1374241.1400000565</span></span><br><span class="line"><span class="comment">// &#125;]</span></span><br></pre></td></tr></table></figure><h2 id="timing-和-memory"><a href="#timing-和-memory" class="headerlink" title="timing 和 memory"></a>timing 和 memory</h2><p>既然 performance 是获取有关浏览器性能的接口， 那肯定提供了页面性能的指标属性</p><ul><li><p>navigation</p><pre><code>提供了在指定的时间段里发生的操作相关信息， 包括页面是加载还是刷新、 发生了多少次重定向等等。</code></pre></li><li><p>timing</p><pre><code>包含延迟相关的性能信息。</code></pre></li><li><p>memory</p><pre><code>Chrome 添加的一个非标准扩展， 这个属性提供了一个可以获取到基本内存使用情况的对象。</code></pre></li></ul><p>通过这些属性， 类似上面 measure 的 demo， 就能知道浏览器在执行 dom， 请求响应， 加载等异步处理项目上的损耗。</p><img src="/legacy/2019/06/08/window-performance/timing.png" class="" title="timing"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>我只是知识点的“加工者”， 更多内容请查阅原文链接 :thought_balloon: ， 同时感谢原作者的付出：</p></blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/performance" target="_blank" rel="noopener">Window​.performance MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance MDN</a></li><li><a href="https://juejin.im/entry/58ba9cb5128fe100643da2cc" target="_blank" rel="noopener">前端性能监控： window.performance 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch —— 初识大概</title>
      <link href="/legacy/2019/05/21/elasticsearch-detail-overview/"/>
      <url>/legacy/2019/05/21/elasticsearch-detail-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>Elasticsearch 是高度可伸缩的开源全文搜索和分析引擎。 你可以即时存储、搜索并分析大容量数据。可靠的底层引擎和技术通常应对复杂的搜索场景和需求。</p><p>参考官方文档，初识 Elasticsearch 主要的 api 使用。</p><h2 id="核心理念-Basic-Concepts"><a href="#核心理念-Basic-Concepts" class="headerlink" title="核心理念 Basic Concepts"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-concepts.html" target="_blank" rel="noopener">核心理念 Basic Concepts</a></h2><ul><li>Near Realtime(NRT) 接近实时的搜索能力</li><li><p>Cluster &amp; Node （集群和节点）</p><p>集群由多个节点组成，每个节点参与集群的索引和搜索操作，每个节点独一无二，并都指向同一个集群。</p></li><li><p>Index &amp; Document （索引和文档）</p><p>Document 是被索引前的基础数据单位，一个 Index 索引将收集相同特征的文档集合，从而执行索引，搜索，更新等操作。</p></li></ul><p>等相关操作</p><ul><li>Shards &amp; Replicas 切片和备份</li></ul><h2 id="集群相关操作"><a href="#集群相关操作" class="headerlink" title="集群相关操作"></a>集群相关操作</h2><blockquote><p>以下操作均通过 Kibana &gt; Dev Tools &gt; Console 实践，当然也可以通过 Postman 等工具</p></blockquote><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;health?v</span><br><span class="line"></span><br><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1555385352 03:29:12  elasticsearch yellow          1         1     13  13    0    0       11             0                  -                 54.2%</span><br></pre></td></tr></table></figure><p>status 标识集群的“健康”指标，通常 Green、Yellow、Red 分类。Yellow 是指数据可用但没有做备份等处理</p><blockquote><p>Once that replica gets allocated onto a second node, the health status for this index will turn to green.</p></blockquote><h3 id="查询子节点信息"><a href="#查询子节点信息" class="headerlink" title="查询子节点信息"></a>查询子节点信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;nodes?v</span><br><span class="line"></span><br><span class="line">ip             heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">192.1.2.3           46          51   0    0.00    0.01     0.05 mdi       *      2EI_4xO</span><br></pre></td></tr></table></figure><h3 id="查询索引列表"><a href="#查询索引列表" class="headerlink" title="查询索引列表"></a>查询索引列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;indices?v</span><br><span class="line"></span><br><span class="line">health status index                     uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   .kibana_1                 3KNILZS5QeK5s_a-LlXfPQ   1   0         10            1      109kb          109kb</span><br><span class="line">yellow open   eminoda                   DUdSWSOcRl2EOnR6Qr9rCA   5   1          5            0     16.6kb         16.6kb</span><br><span class="line">yellow open   filebeat-6.7.1-2019.04.15 5JgqfpNLQ-ewjikehGDc2A   3   1      42103            0        9mb            9mb</span><br><span class="line">green  open   .kibana_task_manager      cI56liOAQgGERRqmqsJilw   1   0          2            0     12.8kb         12.8kb</span><br></pre></td></tr></table></figure><h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><p>所有的操作，遵循 Restful 规范，很容易理解</p><h3 id="create-创建索引"><a href="#create-创建索引" class="headerlink" title="create 创建索引"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-create-index.html" target="_blank" rel="noopener">create 创建索引</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;eminoda?pretty</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot; : true,</span><br><span class="line">  &quot;shards_acknowledged&quot; : true,</span><br><span class="line">  &quot;index&quot; : &quot;eminoda&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_cat&#x2F;indices?v</span><br><span class="line"></span><br><span class="line">health status index                        uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   eminoda                      63rQmVM4SX6dk4HCxSSzqQ   5   1          0            0      1.1kb          1.1kb</span><br></pre></td></tr></table></figure><h3 id="add-添加数据"><a href="#add-添加数据" class="headerlink" title="add 添加数据"></a>add 添加数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;节点名称&#x2F;文档标识&#x2F;Id</span><br><span class="line"># &lt;HTTP Verb&gt; &#x2F;&lt;Index&gt;&#x2F;&lt;Endpoint&gt;&#x2F;&lt;ID&gt;</span><br><span class="line">PUT &#x2F;eminoda&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda&quot;,</span><br><span class="line">  &quot;age&quot;:28</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="query-查询数据"><a href="#query-查询数据" class="headerlink" title="query 查询数据"></a>query 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_doc&#x2F;1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;name&quot; : &quot;eminoda&quot;,</span><br><span class="line">    &quot;age&quot; : 28</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-删除索引、数据"><a href="#delete-删除索引、数据" class="headerlink" title="delete 删除索引、数据"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-delete-index.html" target="_blank" rel="noopener">delete 删除索引、数据</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;eminoda&#x2F;_doc&#x2F;1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;result&quot; : &quot;deleted&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 1,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET &#x2F;eminoda&#x2F;_doc&#x2F;1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;found&quot; : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;eminoda</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update-修改数据"><a href="#update-修改数据" class="headerlink" title="update 修改数据"></a>update 修改数据</h3><p>id 不变，只改变 body 数据，就是更新数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;eminoda&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;eminoda2&quot;,</span><br><span class="line">  &quot;age&quot;:28</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 注意是 update 状态</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 1,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果更改 id ，就相当于新添加数据；也可以交给 elasticsearch 自己生成 id（随机编码），改用 POST 方法，同时不指定 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;eminoda&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;mike&quot;,</span><br><span class="line">  &quot;age&quot;:48</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;BE2uy2oB3Cyw7jMvGdJt&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要查询上述数据，就要拿指定的 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_doc&#x2F;BE2uy2oB3Cyw7jMvGdJt</span><br></pre></td></tr></table></figure><h3 id="batch-多数据操作"><a href="#batch-多数据操作" class="headerlink" title="batch 多数据操作"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-batch-processing.html" target="_blank" rel="noopener">batch 多数据操作</a></h3><p>批量添加数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;节点名称&#x2F;_bulk</span><br><span class="line">POST &#x2F;eminoda&#x2F;_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;, &quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Eminoda&quot; &#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;, &quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Shinoda&quot; &#125;</span><br></pre></td></tr></table></figure><p>注意：不能漏掉 _type，不然会报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Validation Failed: 1: type is missing;2: type is missing;&quot;</span><br></pre></td></tr></table></figure><p>批量复杂操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;eminoda&#x2F;_bulk</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;,&quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;:&quot;Lady GAGA&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;,&quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="查询-Search"><a href="#查询-Search" class="headerlink" title="查询 Search"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-search-API.html" target="_blank" rel="noopener">查询 Search</a></h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;:index&#x2F;_search</span><br><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 0,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;name&quot; : &quot;Shinoda&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;name&quot; : &quot;Eminoda&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>查询 index 中匹配所有的 document，并按照 _id 倒序</p><p>参数式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search?q&#x3D;*sort&#x3D;_id:desc</span><br></pre></td></tr></table></figure><p>命令式（Query DSL）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">       &quot;_id&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 sql，你也可以添加 类似 <strong>“分页”</strong> 的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 从第一条开始，查询两条数据</span><br><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;:2,</span><br><span class="line">  &quot;from&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义数据 <strong>_source</strong> 显示特定字段（Field）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;,&quot;age&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只限制 age=11 的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: 11</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分匹配-和-全文匹配"><a href="#部分匹配-和-全文匹配" class="headerlink" title="部分匹配 和 全文匹配"></a><strong>部分匹配</strong> 和 <strong>全文匹配</strong></h3><p>_source 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;eminoda&#x2F;_bulk?pretty</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;, &quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;first Juck&quot;, &quot;age&quot;:11 &#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;, &quot;_type&quot;:&quot;_doc&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;second Mike&quot;, &quot;age&quot;:22 &#125;</span><br></pre></td></tr></table></figure><p><strong>match</strong> 将搜索含有 first or Mike 的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;first Mike&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot; : [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">    &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">    &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">    &quot;_score&quot; : 0.2876821,</span><br><span class="line">    &quot;_source&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &quot;second Mike&quot;,</span><br><span class="line">      &quot;age&quot; : 22</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">    &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">    &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">    &quot;_score&quot; : 0.2876821,</span><br><span class="line">    &quot;_source&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &quot;first Juck&quot;,</span><br><span class="line">      &quot;age&quot; : 11</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>match_phrase</strong> 将一条都匹配不到，除非把 _id=1 的数据改为 first Mike</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;first Mike&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bool-查询"><a href="#bool-查询" class="headerlink" title="bool 查询"></a>bool 查询</h3><ul><li><strong>should</strong> or</li><li><strong>must</strong> and</li><li><strong>must_not</strong> all not</li></ul><p>上述三个条件可以混用，match 规则也可多条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;:&quot;Mike&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;name&quot;:&quot;first&quot; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;second&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter-过滤查询"><a href="#filter-过滤查询" class="headerlink" title="filter 过滤查询"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-filters.html" target="_blank" rel="noopener">filter 过滤查询</a></h3><p>filter 从属于 bool 属性，和 must 并列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;&quot;name&quot;:&quot;second Mike&quot;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 1,</span><br><span class="line">            &quot;lte&quot;: 20</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aggregation-聚合查询"><a href="#aggregation-聚合查询" class="headerlink" title="aggregation 聚合查询"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-aggregations.html" target="_blank" rel="noopener">aggregation 聚合查询</a></h3><p>类似 sql 的 group by 操作，分组后按照分组数据进行倒叙输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT state, COUNT(*) FROM bank GROUP BY state ORDER BY COUNT(*) DESC LIMIT 10;</span><br></pre></td></tr></table></figure><p>按照 nickname 字段分组，至多显示 10 组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;group_by_state&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;nickname.keyword&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 0,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 3,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;nickname&quot; : &quot;second Mike&quot;,</span><br><span class="line">          &quot;age&quot; : 22</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;nickname&quot; : &quot;first Juck&quot;,</span><br><span class="line">          &quot;age&quot; : 11</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;eminoda&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;3&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;nickname&quot; : &quot;second Mike&quot;,</span><br><span class="line">          &quot;age&quot; : 33</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;group_by_state&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;second Mike&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot; : &quot;first Juck&quot;,</span><br><span class="line">          &quot;doc_count&quot; : 1</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分组后，再按照 age 计算平均年龄，放入新字段 average_age，并且 nickname 分组的数据按照 average_age 升序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;eminoda&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;group_by_state&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;nickname.keyword&quot;,</span><br><span class="line">        &quot;size&quot;: 10,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;_term&quot;: &quot;asc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_age&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;age&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">  &quot;group_by_state&quot; : &#123;</span><br><span class="line">    &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">    &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">    &quot;buckets&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;key&quot; : &quot;second Mike&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 2,</span><br><span class="line">        &quot;average_age&quot; : &#123;</span><br><span class="line">          &quot;value&quot; : 27.5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;key&quot; : &quot;first Juck&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 1,</span><br><span class="line">        &quot;average_age&quot; : &#123;</span><br><span class="line">          &quot;value&quot; : 11.0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步函数 vs 回调函数</title>
      <link href="/legacy/2019/04/29/sync-vs-callback/"/>
      <url>/legacy/2019/04/29/sync-vs-callback/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>闲来蛋疼，为解决 <strong>window 无法删除 node_modules 此类长路径文件这问题</strong>。这两天在鼓弄一个 <a href="https://github.com/eminoda/deleteTool" target="_blank" rel="noopener">删除工具</a></p><blockquote><p><a href="https://github.com/eminoda/deleteTool" target="_blank" rel="noopener">https://github.com/eminoda/deleteTool</a> （喜欢的可以 start 下）</p></blockquote><p>但程序 <strong>删除速度</strong> 没有达到预期，觉得过慢。猜想应该是图方便快速使用了 <strong>fs xxSync()</strong> 方法导致（黑人脸）？</p><p>决定使用 callback 回调函数的 api 实现遍，做了如下测试，结果有些意思。</p><h2 id="实验-Demo"><a href="#实验-Demo" class="headerlink" title="实验 Demo"></a>实验 Demo</h2><p>分别选取 <strong>readdir/readdirSync</strong> 和 <strong>readFile/readFileSync</strong> 做简单的测试，代码见 <strong>附录</strong></p><h3 id="readdir-vs-readdirSync"><a href="#readdir-vs-readdirSync" class="headerlink" title="readdir vs readdirSync"></a>readdir vs readdirSync</h3><p>读取一个含有多目录的文件夹，重复 1w 次。</p><table><thead><tr><th>readdir</th><th>1</th><th>2</th><th>3</th><th>平均（ms）</th></tr></thead><tbody><tr><td>callback</td><td>744</td><td>770</td><td>815</td><td>776.3</td></tr><tr><td>sync</td><td>1327</td><td>1410</td><td>1450</td><td>1395.6</td></tr></tbody></table><h3 id="readFile-vs-readFileSync"><a href="#readFile-vs-readFileSync" class="headerlink" title="readFile vs readFileSync"></a>readFile vs readFileSync</h3><p>由于读取文件有打开数量限制，这里把重复次数改为 1k 次</p><table><thead><tr><th>readFile</th><th>1</th><th>2</th><th>3</th><th>平均（ms）</th></tr></thead><tbody><tr><td>callback</td><td>154</td><td>153</td><td>152</td><td>153</td></tr><tr><td>sync</td><td>184</td><td>180</td><td>182</td><td>183</td></tr></tbody></table><h3 id="deleteTool-两个版本的差异"><a href="#deleteTool-两个版本的差异" class="headerlink" title="deleteTool 两个版本的差异"></a>deleteTool 两个版本的差异</h3><p>删除一个稍大的 node_modules 文件</p><table><thead><tr><th>deleteTool</th><th>平均（ms）</th><th>备注</th></tr></thead><tbody><tr><td>callback</td><td>38890</td><td><a href="https://github.com/eminoda/deleteTool/tree/sync" target="_blank" rel="noopener">项目地址</a></td></tr><tr><td>sync</td><td>51461</td><td><a href="https://github.com/eminoda/deleteTool/tree/sync" target="_blank" rel="noopener">见 branch sync</a></td></tr></tbody></table><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上只是简单测试 2 个常用的 api，但结果基本趋于一致，使用 <strong>callback 方式比同步函数有更快的”速度”</strong></p><p>个人觉得还是和 <strong>Nodejs 事件 I/O</strong> 有关 ，<strong>异步非阻塞</strong> 这种设计模式本身就是优于 <strong>同步阻塞</strong> 的。syncXX 方法或许直接交给 libuv 同步处理。但紧接着就有一个疑问：为什么要推出 sync 这类方法？</p><p>或许为了提升代码可读性，对编码更为友好，增加开发体验？？？但似乎还是站不住脚，没做过多调研。</p><p>另一方面，考虑 Node 版本差异所致，上面 Demo 基于 v8.12，可能 <strong>用最新的 version 或许这两种方式差距就微乎其微了</strong>。这个结论或许你们亲自试过才知道。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>个人觉得这样写应该没啥 <strong>歧义</strong>，如果有问题欢迎 issue，一同交流</p><p><strong>callback 方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> pList = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> pItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.readdir(<span class="string">'./services'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">          resolve(files);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  pList.push(pItem());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>.all(pList);</span><br></pre></td></tr></table></figure><p><strong>sync 方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> pList = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> pItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> files = fs.readdirSync(<span class="string">'./services'</span>);</span><br><span class="line">        resolve(files);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  pList.push(pItem());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>.all(pList);</span><br></pre></td></tr></table></figure><p>计算时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">const</span> pAll = <span class="built_in">require</span>(<span class="string">'./callback'</span>);</span><br><span class="line"><span class="comment">// const pAll = require('./sync');</span></span><br><span class="line"></span><br><span class="line">pAll.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  caleTime(start);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caleTime</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="built_in">console</span>.log(end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filebeat 修改内置 modules （nginx）</title>
      <link href="/legacy/2019/04/12/elk-filebeat-module-nginx/"/>
      <url>/legacy/2019/04/12/elk-filebeat-module-nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="Filebeat-modules"><a href="#Filebeat-modules" class="headerlink" title="Filebeat modules"></a>Filebeat modules</h2><p>Filebeat 内置提供了许多 <strong>开箱即用</strong> 的 modules （模块），对日志文件做简单的收集和解析处理，相比于直接使用 logstash 方便了很多。</p><p>提供如下功能：</p><ul><li>Filebeat input 配置。设置 log 文件的抓取路径，能根据不同系统设置不同路径。</li><li>提供 Elasticsearch <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.0/ingest.html" target="_blank" rel="noopener">Ingest Node</a> pipeline definition。大概通过管道解析预处理元数据到 elasticsearch</li><li>Fields 字段定义</li><li>简单的 Kibana dashboards 仪表盘示例和 visualize 图标分析</li></ul><p>内置模块：<br><img src="/legacy/2019/04/12/elk-filebeat-module-nginx/modules.png" class="" title="内置模块"></p><p>这篇的目的通过修改 Filebeat 内置模块 nginx，以适应业务访问日志分析。</p><h2 id="修改-nginx-modules"><a href="#修改-nginx-modules" class="headerlink" title="修改 nginx modules"></a>修改 nginx modules</h2><p>内置的 nginx modules 只是针对 nginx 的默认 log 格式，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实，我们的 nginx log 会包含更多字段，比如：请求的响应时间、爬虫打标、登录用户 Id 记录…</p><p>这里示范如何修改默认 nginx 配置来达到业务需求。</p><h2 id="看下目前-nginx-日志格式"><a href="#看下目前-nginx-日志格式" class="headerlink" title="看下目前 nginx 日志格式"></a>看下目前 nginx 日志格式</h2><p>先来熟悉下目前 nginx 自定义设置的日志格式 format：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format main <span class="string">'$remote_addr $http_x_forwarded_for - '</span></span><br><span class="line">                    <span class="string">'[$time_local] $request $status $body_bytes_sent $request_time '</span></span><br><span class="line">                    <span class="string">'$uid '</span></span><br><span class="line">                    <span class="string">'$http_user_agent '</span></span><br><span class="line">                    <span class="string">'$spider'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认的日志格式上，简单做了取舍和顺序换位。也增加了业务上的字段，比如：用户 uid；爬虫标识 spider</p><p>实际日志输出（为方便对比，换行展示）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.125</span><span class="number">.71</span><span class="number">.107</span> - -</span><br><span class="line">[<span class="number">15</span>/May/<span class="number">2019</span>:<span class="number">13</span>:<span class="number">30</span>:<span class="number">27</span> +<span class="number">0800</span>] GET /news/d72203.html HTTP/<span class="number">1.1</span> <span class="number">200</span> <span class="number">28434</span> <span class="number">0.177</span></span><br><span class="line"><span class="number">1234567890</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (compatible; Baiduspider/<span class="number">2.0</span>; +http:<span class="comment">//www.baidu.com/search/spider.html)</span></span><br><span class="line">Baiduspider</span><br></pre></td></tr></table></figure><h2 id="修改解析规则"><a href="#修改解析规则" class="headerlink" title="修改解析规则"></a>修改解析规则</h2><ol><li><p>修改 modules 默认引导文件 manifest.yml</p><p>可能 nginx 输出的 log 路径有所不同，需要修改日志读取目录路径；已经新定义 ingest 解析规则文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /mydata/filebeat<span class="number">-6.7</span><span class="number">.1</span>-linux-x86_64/<span class="built_in">module</span>/nginx/access/manifest.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">paths</span></span><br><span class="line">        <span class="attr">default:</span></span><br><span class="line">            <span class="comment"># 如果你 nginx log 输出路径和默认不一致，需要修改</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/log/nginx/*access.log*</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    <span class="comment"># 重新指定提取规则文件</span></span><br><span class="line">    <span class="comment"># ingest_pipeline: ingest/default.json</span></span><br><span class="line">    <span class="attr">ingest_pipeline:</span> <span class="string">ingest/pro.json</span></span><br></pre></td></tr></table></figure></li><li><p>修改 ingest 规则文件</p><p>参照上一个修改，此处文件已经变更为 pro.json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /mydata/filebeat<span class="number">-6.7</span><span class="number">.1</span>-linux-x86_64/<span class="built_in">module</span>/nginx/access/ingest/pro.json</span><br></pre></td></tr></table></figure><p>注意：patterns 为单行内容（为方便对比，换行展示）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"grok"</span>: &#123;</span><br><span class="line">    <span class="string">"field"</span>: <span class="string">"message"</span>,</span><br><span class="line">    <span class="string">"patterns"</span>: [</span><br><span class="line">        <span class="string">"\"?%&#123;IP_LIST:nginx.access.remote_ip_list&#125; %&#123;IP_LIST:nginx.access.forward_ip_list&#125; -</span></span><br><span class="line"><span class="string">        \\[%&#123;HTTPDATE:nginx.access.time&#125;\\] %&#123;GREEDYDATA:nginx.access.info&#125; %&#123;NUMBER:nginx.access.response_code:long&#125; %&#123;NUMBER:nginx.access.body_sent.bytes:long&#125; %&#123;NUMBER:nginx.access.request_time:float&#125;</span></span><br><span class="line"><span class="string">        (%&#123;NUMBER:nginx.access.uid&#125;|-)</span></span><br><span class="line"><span class="string">        %&#123;GREEDYDATA:nginx.access.agent&#125;</span></span><br><span class="line"><span class="string">        %&#123;SPIDER:nginx.access.spider&#125;"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"pattern_definitions"</span>: &#123;</span><br><span class="line">        <span class="string">"IP_LIST"</span>: <span class="string">"%&#123;IP&#125;(\"?,?\\s*%&#123;IP&#125;)*|-"</span>,</span><br><span class="line">        <span class="string">"SPIDER"</span>: <span class="string">"%&#123;WORD&#125;|-"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ignore_missing"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>基本是在原有基础上做字段的位置变更，和字段的添加，没有对配置文件 <strong>大改</strong> （也怕改崩 :neutral_face:）</p></li><li><p>清空 elastisearch 相关内容（未了解，很佛系的操作）</p><p>主要作用是清除旧索引、模板等历史“缓存”数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http:<span class="comment">//192.168.1.65:9201/_ingest/pipeline/*</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http:<span class="comment">//192.168.1.65:9201/_template/*</span></span><br></pre></td></tr></table></figure></li><li><p>重启 Filebeat ，读取新数据</p></li><li><p>重建 Kibana Index 索引</p><p>如果你能搜索到你新添加的 Field 字段，恭喜你成功了。</p><img src="/legacy/2019/04/12/elk-filebeat-module-nginx/request_time.png" class=""><p>如果失败，可能有如下原因：</p><ul><li>参照步骤 4，可能还有其他数据需要删除</li><li>解析规则有问题，比如少个引号，少个空格之类</li></ul></li></ol><h2 id="Dashboard-实际效果"><a href="#Dashboard-实际效果" class="headerlink" title="Dashboard 实际效果"></a>Dashboard 实际效果</h2><p>成功添加字段后，可以在 Kibana 有更丰富的展示</p><img src="/legacy/2019/04/12/elk-filebeat-module-nginx/dashboard.png" class="" title="Dashboard"><p>左下角的耗时 pipe，根据 request_time 字段统计得出</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 水平和垂直居中的几种方式</title>
      <link href="/legacy/2019/04/12/css-center/"/>
      <url>/legacy/2019/04/12/css-center/</url>
      
        <content type="html"><![CDATA[<p>简单列举 css 中水平和垂直的居中方式，网上资料大把，十几种实现方式，这里拿其中常用的几种作为复习巩固。</p><h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><img src="/legacy/2019/04/12/css-center/c-1.jpg" class="" title="水平"><h2 id="text-align-方式"><a href="#text-align-方式" class="headerlink" title="text-align 方式"></a>text-align 方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. text-align 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>非块级元素 inline-block; 也适用<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:inline-block;"</span>&gt;</span>非块级元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定宽-margin-auto-方式"><a href="#定宽-margin-auto-方式" class="headerlink" title="定宽 + margin auto 方式"></a>定宽 + margin auto 方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2. 定宽 + margin auto 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:0 auto;width:200px;text-align: center;"</span>&gt;</span>自身定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="flex-方式"><a href="#flex-方式" class="headerlink" title="flex 方式"></a>flex 方式</h2><p>弹性布局方式也是最快容易上手，也好配置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>3. flex 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span> <span class="attr">style</span>=<span class="string">"display: flex;justify-content: center;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span>利用 justify-content 方式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="position-float-方式"><a href="#position-float-方式" class="headerlink" title="position + float 方式"></a>position + float 方式</h2><p>比较骚气的操作，通过父子标签设置相对定位，再通过相反的浮动偏移量进行居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>4. position + float 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span> <span class="attr">style</span>=<span class="string">"clear: both;overflow: hidden;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:left;position:relative;left:50%"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"float:right;position:relative;;left:-50%"</span>&gt;</span>多设置了一个元素，与父元素交错<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><img src="/legacy/2019/04/12/css-center/h-1.jpg" class="" title="垂直-1"><h2 id="line-height-方式"><a href="#line-height-方式" class="headerlink" title="line-height 方式"></a>line-height 方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. line-height 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span> <span class="attr">style</span>=<span class="string">"height:100px;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"line-height: 100px;"</span>&gt;</span>内联元素设置和父级一致的行高<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="table-方式"><a href="#table-方式" class="headerlink" title="table 方式"></a>table 方式</h2><p>除了一定要显示 <strong>表格</strong> 的界面，基本个人不怎么用这玩意，div 用得太多了，导致太陌生了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2. table 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100px; display: table;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"display: table-cell;vertical-align: middle;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>父级设置 table 布局，子级使用 table cell，设置垂直居中属性<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="flex-方式-1"><a href="#flex-方式-1" class="headerlink" title="flex 方式"></a>flex 方式</h2><p>同水平布局，配置的问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>3. flex 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"height:100px;display: flex;align-items: center;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>使用 flex，设置 align-items<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/legacy/2019/04/12/css-center/h-2.jpg" class="" title="垂直-2"><h2 id="position-margin-偏移-方式"><a href="#position-margin-偏移-方式" class="headerlink" title="position + margin 偏移 方式"></a>position + margin 偏移 方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>4. position + margin 偏移 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"height:100px;position: relative;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: absolute;top: 0;line-height: 50px;margin-top: 25px;"</span>&gt;</span>偏移本元素的 1/2 高<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="position-margin-auto-方式"><a href="#position-margin-auto-方式" class="headerlink" title="position + margin auto 方式"></a>position + margin auto 方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>5. position + margin auto 方式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"height:100px;position: relative;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: absolute;margin:auto;top: 0;bottom: 0;height: 50px;line-height: 50px;"</span>&gt;</span>position 上下都为 0，margin auto<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="position-transform"><a href="#position-transform" class="headerlink" title="position + transform"></a>position + transform</h2><p>算是 css3 比较骚气的方法，如果兼容没有问题，通过 transform 做到 <strong>中心定位</strong> 也是最方便和理解的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>6. position + transform<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border"</span> <span class="attr">style</span>=<span class="string">"height:100px;position: relative;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: absolute;top: 50%;left:50%; transform: translate(-50%,-50%);height: 50px;line-height: 50px;"</span>&gt;</span></span><br><span class="line">      translate 本元素的 -1/2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK 上手使用</title>
      <link href="/legacy/2019/04/10/elk-quickstart/"/>
      <url>/legacy/2019/04/10/elk-quickstart/</url>
      
        <content type="html"><![CDATA[<h2 id="ELK-简单介绍"><a href="#ELK-简单介绍" class="headerlink" title="ELK 简单介绍"></a>ELK 简单介绍</h2><p>ELK 是三个开源框架的缩写（Elasticsearch、Logstash、Kibana），用于收集海量日志，并做统计分析。<br>这样一套协议栈称为 ELK Stack（Elastic Stack）</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a></p><blockquote><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p></blockquote><p><a href="https://www.elastic.co/guide/en/beats/filebeat/current/index.html" target="_blank" rel="noopener">Filebeat</a></p><blockquote><p>Filebeat 作为一个轻量级的日志数据收集和发送工具。安装在日志生产服务器后，将按照你指定的日志进行监控，并发送给 Elasticsearch、Logstash 等服务进行后续操作。</p></blockquote><p><a href="https://www.elastic.co/guide/en/logstash/current/introduction.html" target="_blank" rel="noopener">logstash</a></p><blockquote><p>Logstash 是个开源的数据收集引擎，通过管道能对数据实时做处理。其周边有丰富的插件来对：输出流、过滤器、输出流等做强大的控制。</p></blockquote><p><a href="https://www.elastic.co/guide/en/kibana/current/introduction.html" target="_blank" rel="noopener">kibana</a></p><blockquote><p>Kibana 和 Elasticsearch 一同工作，利用 Kibana 可以用图形化，更简便的方式对 Elasticsearch 中的索引进行搜索操作，也能只做图标来更好的分析数据的价值。</p></blockquote><p><a href="https://www.elastic.co/cn/cloud/elasticsearch-service" target="_blank" rel="noopener">Elasticsearch Service 云服务（阿里云的产品）</a></p><h2 id="下载和启动"><a href="#下载和启动" class="headerlink" title="下载和启动"></a>下载和启动</h2><p>官网上已有很每一步的安装说明，如果有其他问题可以参照本文 <strong>附录</strong></p><ul><li><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">Download elasticsearch</a></li><li><a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">Download kibana</a></li><li><a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">Download logstash</a></li><li><a href="https://www.elastic.co/cn/downloads/beats/filebeat" target="_blank" rel="noopener">Download Filebeat</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 以下非守护模式</span><br><span class="line">[elker@localhost elasticsearch-6.7.0]$ bin&#x2F;elasticsearch</span><br><span class="line">[root@localhost kibana-6.7.0-linux-x86_64]# .&#x2F;bin&#x2F;kibana</span><br><span class="line">[root@localhost logstash-6.7.0]# .&#x2F;bin&#x2F;logstash -f logstash.conf</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>Elasticsearch、logstash、kibana 为了方便测试都在一台测试机上</p><h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><p>由于默认 elasticsearch、kibana 只开放 localhost 权限（可能我配置问题），所以通过 nginx 反向代理对外暴露服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># elk elasticsearch</span><br><span class="line">server &#123;</span><br><span class="line">listen          9201;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_pass  http:&#x2F;&#x2F;localhost:9200;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># elk kibana</span><br><span class="line">server &#123;</span><br><span class="line">listen          5602;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_pass  http:&#x2F;&#x2F;localhost:5601;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动-Elasticsearch-和-Kibana"><a href="#启动-Elasticsearch-和-Kibana" class="headerlink" title="启动 Elasticsearch 和 Kibana"></a>启动 Elasticsearch 和 Kibana</h2><h2 id="配置-logstash"><a href="#配置-logstash" class="headerlink" title="配置 logstash"></a>配置 logstash</h2><ol><li><p>先了解数据 input、output 解析结果</p><p>通过控制台键入数据，已 debug 的方式查看 logstash 输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span><br></pre></td></tr></table></figure><p>启动后在控制台输入 <strong>helloworld</strong> 看下输出内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logstash-6.7.0]# bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span><br><span class="line">...</span><br><span class="line">helloworld</span><br><span class="line">&#x2F;mydata&#x2F;ELK&#x2F;logstash-6.7.0&#x2F;vendor&#x2F;bundle&#x2F;jruby&#x2F;2.5.0&#x2F;gems&#x2F;awesome_print-1.7.0&#x2F;lib&#x2F;awesome_print&#x2F;formatters&#x2F;base_formatter.rb:31: warning: constant ::Fixnum is deprecated</span><br><span class="line">&#123;</span><br><span class="line">      &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class="line">      &quot;message&quot; &#x3D;&gt; &quot;helloworld&quot;,</span><br><span class="line">    &quot;@timestamp&quot; &#x3D;&gt; 2019-04-09T02:30:45.390Z,</span><br><span class="line">          &quot;host&quot; &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nginx 日志解析</p><p>将 input 数据替换成本地的 nginx 访问日志，修改 <strong>logstash.conf</strong></p><p>通过 gork 自定义匹配 log 数据，一一映射。并将 output 挂到 elasticsearch 节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path &#x3D;&gt; &quot;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&quot;</span><br><span class="line">    start_position &#x3D;&gt; &quot;beginning&quot;</span><br><span class="line">    type &#x3D;&gt; &quot;my-nginx-log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># nginx 日志格式</span><br><span class="line"># log_format main</span><br><span class="line">#   $remote_addr $http_x_forwarded_for [$time_local]</span><br><span class="line">#   $request $status $body_bytes_sent $request_time $http_user_agent&#39;;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;IPORHOST:remote_addr&#125; - \[%&#123;HTTPDATE:time_local&#125;\] %&#123;NOTSPACE:method&#125; %&#123;NOTSPACE:request_url&#125; HTTP&#x2F;%&#123;NUMBER:httpversion&#125; %&#123;INT:status&#125; %&#123;INT:body_bytes_sent&#125; %&#123;NUMBER:request_time:float&#125; %&#123;GREEDYDATA:http_user_agent&#125;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123; hosts &#x3D;&gt; [&quot;localhost:9200&quot;] &#125;</span><br><span class="line">  stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 logstash 安装目录下，启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost logstash-6.7.0]# bin&#x2F;logstash -f logstash.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>如果日志数据被 logstash 定义的规则命中后，就会输出给 Elasticsearch，最后体现在 kibana 主页面上</p><p>同时也能绘制简单的图标，用来分析数据</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><ol><li><p>指定 JDK 版本</p><p>可能项目环境不支持需要低版本 JDK，ElasticSearch 至少需要 1.8 版本。需要修改启动文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># CONTROLLING STARTUP:</span><br><span class="line">#</span><br><span class="line"># This script relies on a few environment variables to determine startup</span><br><span class="line"># behavior, those variables are:</span><br><span class="line">#</span><br><span class="line"># ES_PATH_CONF -- Path to config directory</span><br><span class="line"># ES_JAVA_OPTS -- External Java Opts on top of the defaults set</span><br><span class="line">#</span><br><span class="line"># Optionally, exact memory values can be set using the &#96;ES_JAVA_OPTS&#96;. Note that</span><br><span class="line"># the Xms and Xmx lines in the JVM options file must be commented out. Example</span><br><span class="line"># values are &quot;512m&quot;, and &quot;10g&quot;.</span><br><span class="line">#</span><br><span class="line"># ES_JAVA_OPTS&#x3D;&quot;-Xms8g -Xmx8g&quot; .&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;mydata&#x2F;jdk1.8.0_144</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">source &quot;&#96;dirname &quot;$0&quot;&#96;&quot;&#x2F;elasticsearch-env</span><br></pre></td></tr></table></figure></li><li><p>不允许 root 用户启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost elasticsearch-6.7.0]# bin&#x2F;elasticsearch</span><br><span class="line">[2019-04-04T16:27:25,217][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [unknown] uncaught exception in thread [main]</span><br><span class="line">org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</span><br></pre></td></tr></table></figure><p>添加 <strong>新用户</strong>，授权到对一目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ELK]# useradd elker</span><br><span class="line">[root@localhost ELK]# passwd elker</span><br><span class="line">[root@localhost ELK]# chown -R elker .&#x2F;elasticsearch-6.7.0</span><br><span class="line">[root@localhost ELK]#</span><br><span class="line">[root@localhost ELK]# cd elasticsearch-6.7.0</span><br><span class="line">[root@localhost elasticsearch-6.7.0]# bin&#x2F;elasticsearch</span><br></pre></td></tr></table></figure></li><li><p>filebeat 开启 kibana dashboards 报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@station74 filebeat-6.7.1-linux-x86_64]# .&#x2F;filebeat setup --dashboards</span><br><span class="line">Loading dashboards (Kibana must be running and reachable)</span><br><span class="line">Exiting: fail to create the Kibana loader: Error creating Kibana client: Error creating Kibana client: fail to get the Kibana version: HTTP GET request to &#x2F;api&#x2F;status fails: fail to execute the HTTP GET request: Get http:&#x2F;&#x2F;localhost:5601&#x2F;api&#x2F;status: dial tcp 127.0.0.1:5601: connect: connection refused. Response: .</span><br></pre></td></tr></table></figure><p>设置 filebeat.yml kibana host 地址</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/index.html" target="_blank" rel="noopener">集中式日志系统 ELK 协议栈详解</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html" target="_blank" rel="noopener">ELK+Filebeat 集中式日志解决方案详解</a></p></li><li><p><a href="https://www.cnblogs.com/hark0623/p/7418385.html" target="_blank" rel="noopener">删除 ELK 历史数据</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初涉 JMeter</title>
      <link href="/legacy/2019/03/27/jmeter-quickstart/"/>
      <url>/legacy/2019/03/27/jmeter-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h1><blockquote><p>用 Java 设计的测试工具，初衷设计用来测试 web 应用，现在扩展到更多的测试领域</p></blockquote><p>这是一个最最最简单的入门，了解 <strong>阿里云 PTS</strong> 测试时顺带看下 jmeter，什么术业有专攻，在前（quan）端（zhan）面前全是浮云。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>jdk 安装</strong></p><p>网上一大把资料，这里不再描述</p><p><strong>JMeter 安装</strong></p><p><a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载地址</a></p><p>在上面下载页中，找到 <strong>apache-jmeter-5.x.x.tgz</strong> 下载（最低需要 java 8+ 以上的版本）</p><p>一顿无脑安装，在 <strong>安装目录下</strong>（jmeter\apache-jmeter-5.1.1\bin） 找到 <strong>jmeter.bat</strong> 点击运行</p><h1 id="举一个例子"><a href="#举一个例子" class="headerlink" title="举一个例子"></a>举一个例子</h1><p>模拟一个 Http 测试计划，来介绍 JMeter 的配置</p><h2 id="创建一个新任务"><a href="#创建一个新任务" class="headerlink" title="创建一个新任务"></a>创建一个新任务</h2><p>所有 TestPlan 都是需要线程作为用户来运作，首先需要新建 Thread Group</p><img src="/legacy/2019/03/27/jmeter-quickstart/ThreadGroup-1.png" class="" title="新建 TreadGroup"><img src="/legacy/2019/03/27/jmeter-quickstart/ThreadGroup-2.png" class="" title="主界面"><p><strong>主要参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Number of Threads(users)</td><td>线程数（虚拟用户）</td></tr><tr><td>Ramp-Up Period(in seconds)</td><td>每秒增加用户数</td></tr><tr><td>Loop Count</td><td>循环次数</td></tr></tbody></table><p>举例：</p><ol><li><p>明白 Ramp-Up Period 参数</p><ul><li>Number of Threads = 10</li><li>Ramp-Up Period = 20</li><li>Loop Count = 1</li></ul><p>将准备 10 个线程，每 2 秒（Ramp-Up Period/Number of Threads）后创建新线程运行 plan，总共循环 1 次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:23 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:25 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:27 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:29 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:31 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:33 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:35 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:37 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:39 +0800]</span><br><span class="line">[26&#x2F;Mar&#x2F;2019:13:18:41 +0800]</span><br></pre></td></tr></table></figure></li><li><p>每秒发送一个请求持续 1 分钟</p><ul><li>Number of Threads = 1</li><li>Ramp-Up Period = 1</li><li>Loop Count = 60</li></ul></li></ol><h2 id="创建一个-Http-用例"><a href="#创建一个-Http-用例" class="headerlink" title="创建一个 Http 用例"></a>创建一个 Http 用例</h2><p>注意是在 TreadGroup 这栏，右键创建<br><img src="/legacy/2019/03/27/jmeter-quickstart/HttpRequest-1.png" class=""></p><img src="/legacy/2019/03/27/jmeter-quickstart/HttpRequest-2.png" class="" title="主界面"><p>这里可以设置 Http 请求所有的内容：协议、方法、地址、端口、参数。按照具体要求设置。</p><p><strong>值得一提</strong> 的是在 Advanced tab 选项中，可以设置：<strong>Retrieve All Embedded Resources</strong></p><img src="/legacy/2019/03/27/jmeter-quickstart/HttpRequest-3.png" class="" title="异步资源"><p>一般情况下测试一个页面，测试工具只是拿到页面的 document 内容，不会对页面中异步资源（js、css、images）做二次请求（包括 ab），如果勾选了上面这个选项，就会请求所有异步资源。</p><h2 id="Http-公用配置"><a href="#Http-公用配置" class="headerlink" title="Http 公用配置"></a>Http 公用配置</h2><p>Jmeter 也提供了很多自定义的配置，方便公用</p><p>这里举个维护 Http 请求头的例子：</p><img src="/legacy/2019/03/27/jmeter-quickstart/Config-1.png" class="" title="Http-Header"><img src="/legacy/2019/03/27/jmeter-quickstart/Config-Http.png" class="" title="Http-Agent"><h2 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h2><p>运行完，你也不知道发生什么。通常还需要设置一个监听，这样所有的用例结果就会提现出来</p><img src="/legacy/2019/03/27/jmeter-quickstart/Listener.png" class=""><img src="/legacy/2019/03/27/jmeter-quickstart/Listener-Result.png" class=""><p>这图正好有两条记录，分别测试 Retrieve All Embedded Resources 选项的区别，能看到响应时间差的不是一点半点。</p><h1 id="Jmeter-报告"><a href="#Jmeter-报告" class="headerlink" title="Jmeter 报告"></a>Jmeter 报告</h1><p>需要一个图形化统计来量化这些测试结果数据</p><p>具体 api 解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">To run Apache JMeter in NON_GUI mode and generate a report at end :</span><br><span class="line">Open a command prompt (or Unix shell) and type:</span><br><span class="line"></span><br><span class="line">jmeter.bat(Windows)&#x2F;jmeter.sh(Linux) -n -t test-file [-p property-file] [-l results-file] [-j log-file] -e -o [Path to output folder]</span><br></pre></td></tr></table></figure><p>参考脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter\apache-jmeter-5.1.1\bin&gt;jmeter -n -t .&#x2F;jm&#x2F;indexPlan.jmx -l .&#x2F;jm&#x2F;result&#x2F;log -e -o .&#x2F;jm&#x2F;output</span><br></pre></td></tr></table></figure><p><strong>可能出现的问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Could not open&#x2F;create prefs root node Software\JavaSoft\Prefs at root 0x80000002. Windows RegCreateKeyEx(...) returned error code 5.</span><br></pre></td></tr></table></figure><p>登录注册表：regedit，修改/新添加：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Prefs</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>上面都是些简单操作，更多的需要专业的测试人员来接入。这里补充一点其他基础内容：</p><h2 id="一个页面总用时时间消耗在哪些方面？"><a href="#一个页面总用时时间消耗在哪些方面？" class="headerlink" title="一个页面总用时时间消耗在哪些方面？"></a>一个页面总用时时间消耗在哪些方面？</h2><p>首先，在服务器端，某页面请求 nginx 日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[26&#x2F;Mar&#x2F;2019:10:34:51 +0800] Mozilla&#x2F;5.0 ... Chrome&#x2F;49.0.2623.221 1.0 GET &#x2F; HTTP&#x2F;1.1 200 24612 0.042 -</span><br></pre></td></tr></table></figure><p>最后位 0.042 代表耗时 42ms</p><p>而然，在浏览器端却耗时 93ms，相差一半。放张图，聪明的你一看就明白我想说什么了：</p><img src="/legacy/2019/03/27/jmeter-quickstart/request.png" class=""><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>Queueing</td><td>浏览器内部的发请求排队时间</td></tr><tr><td>Stalled</td><td>发送请求前，准备的时间</td></tr><tr><td>Proxy negotiation</td><td>代理商解析时间</td></tr><tr><td>DNS Lookup</td><td>DNS 解析时间</td></tr><tr><td>Initial connection</td><td>TCP 握手时间</td></tr><tr><td>Request sent</td><td>请求信息发出时间</td></tr><tr><td>Waiting (TTFB)</td><td>服务器响应时间</td></tr><tr><td>Content Download</td><td>响应资源下载时间</td></tr></tbody></table><p>上面内容可能解释有出入，但基本也解释了这一半多时间消耗在哪方面。</p><h2 id="阿里云-PTS"><a href="#阿里云-PTS" class="headerlink" title="阿里云 PTS"></a>阿里云 PTS</h2><blockquote><p>性能测试（Performance Testing Service，简称 PTS）是具备强大的分布式压测能力的 SaaS 压测平台，可模拟海量用户的真实业务场景，全方位验证业务站点的性能、容量和稳定性。</p></blockquote><p>下面是 200 并发，对首页做的测试：<br><img src="/legacy/2019/03/27/jmeter-quickstart/pts.png" class="" title="pts"><br><img src="/legacy/2019/03/27/jmeter-quickstart/pts2.png" class="" title="pst-time"></p><ul><li>TPS:188.33 （事务/秒）</li><li>请求总数：11577 （个）</li></ul><p>对比 ab，结果差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@iZbp15avj2fzy1tjdlwce7Z ~]# ab -n 11500 -c 200 http:&#x2F;&#x2F;www.niu100.com</span><br><span class="line"></span><br><span class="line">Document Path:          &#x2F;</span><br><span class="line">Document Length:        35695 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      200</span><br><span class="line">Time taken for tests:   60.122 seconds</span><br><span class="line">Complete requests:      11500</span><br><span class="line">Failed requests:        1179</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 1179, Exceptions: 0)</span><br><span class="line">Write errors:           0</span><br><span class="line">Total transferred:      406280852 bytes</span><br><span class="line">HTML transferred:       404440852 bytes</span><br><span class="line">Requests per second:    191.28 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       1045.606 [ms] (mean)</span><br><span class="line">Time per request:       5.228 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          6599.19 [Kbytes&#x2F;sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+&#x2F;-sd] median   max</span><br><span class="line">Connect:        1    1   0.3      1      13</span><br><span class="line">Processing:    28 1020 949.6    740    4324</span><br><span class="line">Waiting:       26 1019 949.6    738    4323</span><br><span class="line">Total:         29 1021 949.6    742    4325</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    742</span><br><span class="line">  66%   1124</span><br><span class="line">  75%   1457</span><br><span class="line">  80%   1651</span><br><span class="line">  90%   3035</span><br><span class="line">  95%   3117</span><br><span class="line">  98%   3208</span><br><span class="line">  99%   3481</span><br><span class="line"> 100%   4325 (longest request)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_20881087/article/details/56682525" target="_blank" rel="noopener">timing 含义解释</a><br><a href="http://www.jsjtt.com/java/javaceshi/124.html" target="_blank" rel="noopener">jmeter 压力测试 设置一秒发送一次请求，一秒两次请求</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启 Express 模板缓存</title>
      <link href="/legacy/2019/03/14/node-express-cache/"/>
      <url>/legacy/2019/03/14/node-express-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>昨天压测某品牌网站首页，效果非常不理想：</p><blockquote><p>ab 参数：数量 -n 1000，并发 -c 100</p></blockquote><img src="/legacy/2019/03/14/node-express-cache/ab1.png" class=""><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td>每秒请求数（个/秒）</td><td>5.95</td></tr><tr><td>单个请求平均用时（ms）</td><td>168ms</td></tr><tr><td>50% 以上请求用时（s）</td><td>16-28</td></tr></tbody></table><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于首页接口调用繁重，定位问题有些“困难”，一步步看吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首页</span></span><br><span class="line">router.get(<span class="string">'/'</span>, interceptor.fn, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.all([</span><br><span class="line">    newsService.findAllChannel(),</span><br><span class="line">    newsService.findByAdspaceId(),</span><br><span class="line">    newsService.findFriendLinks(),</span><br><span class="line">    newsService.findAllChannel(),</span><br><span class="line">    ...</span><br><span class="line">  ]).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    res.render(<span class="string">'page/index.pug'</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="先排除首页内部第三方服务接口的瓶颈"><a href="#先排除首页内部第三方服务接口的瓶颈" class="headerlink" title="先排除首页内部第三方服务接口的瓶颈"></a>先排除首页内部第三方服务接口的瓶颈</h3><p>首页需支持 SEO，做了服务端渲染，并且至少 5 次会调用第三方 api。但这些接口用 ab 比较难制定，用 node 专门写了个测试 api 组合的压测，ab 结果如下：</p><img src="/legacy/2019/03/14/node-express-cache/ab3.png" class=""><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td>每秒请求数（个/秒）</td><td>88.02</td></tr><tr><td>单个请求平均用时（ms）</td><td>11.361</td></tr><tr><td>50% 以上请求用时（s）</td><td>0.9-8s</td></tr></tbody></table><p>由于这些第三方服务数据量虽然重，但之前已经做过缓存优化。从结果可以发现并不是瓶颈的主要原因。</p><h3 id="排除自身服务接口影响"><a href="#排除自身服务接口影响" class="headerlink" title="排除自身服务接口影响"></a>排除自身服务接口影响</h3><p>内部服务采用 java，首页对其依赖很少，数据也很轻量。</p><p>拿了一个主要接口做测试，结果很理想：</p><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td>每秒请求数（个/秒）</td><td>569.12</td></tr><tr><td>单个请求平均用时（ms）</td><td>1.757</td></tr><tr><td>50% 以上请求用时（s）</td><td>0.1-0.7</td></tr></tbody></table><h3 id="node-非模板接口"><a href="#node-非模板接口" class="headerlink" title="node 非模板接口"></a>node 非模板接口</h3><p>找了一个 <strong>非模板渲染</strong> 的接口，做压测：</p><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td>每秒请求数（个/秒）</td><td>1347.95</td></tr><tr><td>单个请求平均用时（ms）</td><td>0.742</td></tr><tr><td>50% 以上请求用时（s）</td><td>0.07-0.09</td></tr></tbody></table><p>结果甚至比 java 服务还要优秀，符合 node 本身的事务处理能力</p><p><a href="https://eminoda.github.io/2018/11/08/pressure-test-node-java/" target="_blank" rel="noopener">可参考：node 和 java 性能对比</a></p><h3 id="最终定位到-node-渲染层"><a href="#最终定位到-node-渲染层" class="headerlink" title="最终定位到 node 渲染层"></a>最终定位到 node 渲染层</h3><p>对比之下，首页就多了 render 页面渲染功能。果断打开 express 模板缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view cache'</span>, <span class="literal">true</span>);</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'pug'</span>);</span><br></pre></td></tr></table></figure><p><strong>对比之前未打开缓存</strong>，结果如下：</p><img src="/legacy/2019/03/14/node-express-cache/ab2.png" class=""><table><thead><tr><th>指标</th><th>结果</th></tr></thead><tbody><tr><td>每秒请求数（个/秒）</td><td>92.68 vs 5.95</td></tr><tr><td>单个请求平均用时（ms）</td><td>10.790 vs 168</td></tr><tr><td>50% 以上请求用时（s）</td><td>0.68-3 vs 16-28</td></tr></tbody></table><p>可以发现性能 <strong>大幅提升</strong>，元凶找到。</p><p>具体缓存实现，参见附录。</p><h2 id="附录（express-cache-原理）"><a href="#附录（express-cache-原理）" class="headerlink" title="附录（express cache 原理）"></a>附录（express cache 原理）</h2><p>express 在启动时，会初始化 render options</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">'view cache'</span>, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">app.render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">name, options, callback</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// set .cache unless explicitly provided</span></span><br><span class="line">    <span class="keyword">if</span> (renderOptions.cache == <span class="literal">null</span>) &#123;</span><br><span class="line">        renderOptions.cache = <span class="keyword">this</span>.enabled(<span class="string">'view cache'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>express 通过 View 对视图做解析，根据 ext 来选择指定模板引擎，同时第三方模板库会暴露一个 <strong>__express</strong> 供 express 此处调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">name, options</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!opts.engines[<span class="keyword">this</span>.ext]) &#123;</span><br><span class="line">        <span class="comment">// load engine</span></span><br><span class="line">        <span class="keyword">var</span> mod = <span class="keyword">this</span>.ext.substr(<span class="number">1</span>)</span><br><span class="line">        debug(<span class="string">'require "%s"'</span>, mod)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default engine export</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="built_in">require</span>(mod).__express</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Module "'</span> + mod + <span class="string">'" does not provide a view engine.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        opts.engines[<span class="keyword">this</span>.ext] = fn</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pug express 扩展</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Express support.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">exports.__express = <span class="function"><span class="keyword">function</span>(<span class="params">path, options, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.compileDebug == <span class="literal">undefined</span> &amp;&amp; process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    options.compileDebug = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  exports.renderFile(path, options, fn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>打开 express ‘view cache’ 后，每次模板调用就会事先到缓存中命中，免去文件 io 的损耗和解析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pug 模板缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTemplateCache</span>(<span class="params">options, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key = options.filename;</span><br><span class="line">  <span class="keyword">if</span> (options.cache &amp;&amp; exports.cache[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> exports.cache[key];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="literal">undefined</span>) str = fs.readFileSync(options.filename, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">var</span> templ = exports.compile(str, options);</span><br><span class="line">    <span class="keyword">if</span> (options.cache) exports.cache[key] = templ;</span><br><span class="line">    <span class="keyword">return</span> templ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云 CDN 使用</title>
      <link href="/legacy/2019/02/18/performance-aliyun-cdn/"/>
      <url>/legacy/2019/02/18/performance-aliyun-cdn/</url>
      
        <content type="html"><![CDATA[<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><blockquote><p>阿里云内容分发网络（Alibaba Cloud Content Delivery Network，简称 CDN）将您源站资源缓存至阿里云遍布全球的加速节点上。当终端用户请求访问和获取这些资源时，无需回源，系统将就近调用 CDN 节点上已经缓存的资源。</p></blockquote><blockquote><p>在不同区域、不同场景下使用 CDN 加速您网站内容的分发，将有效分担源站压力，避免网络拥塞，提升用户访问资源的速度和体验。</p></blockquote><h1 id="阿里云-CDN-服务"><a href="#阿里云-CDN-服务" class="headerlink" title="阿里云 CDN 服务"></a>阿里云 CDN 服务</h1><p><a href="https://help.aliyun.com/document_detail/27144.html?spm=5176.11785003.0.0.50bc142faX2uwE" target="_blank" rel="noopener">万网/阿里云解析与配置 CNAME 流程</a></p><h2 id="开通-CDN"><a href="#开通-CDN" class="headerlink" title="开通 CDN"></a>开通 CDN</h2><p>默认开通是 <strong>流量模式</strong>，根据不同站点的流量选择不同类型的套餐。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>进到 CDN 控制台，添加新配置</li></ol><ul><li><strong>加速域名</strong> 支持泛解析。（这是给 <strong>使用方</strong> 的域名）</li><li>缓存资源类型 这里选择小文件，诸如：js、css 等</li><li><p>来源 目前选择域名来源，自定义不同的二级域名</p><img src="/legacy/2019/02/18/performance-aliyun-cdn/setting-cdn.png" class="" title="示例"></li></ul><ol start="2"><li><p>记录 CNAME 设置完后，稍等片刻就会出现 CNAME，之后域名解析需要使用</p><img src="/legacy/2019/02/18/performance-aliyun-cdn/setting-cdn-result.png" class="" title="示例"></li><li><p><strong>域名解析</strong> 配置修改新增一条 CNAME 类型的记录</p><img src="/legacy/2019/02/18/performance-aliyun-cdn/setting-domain.png" class="" title="示例"> <img src="/legacy/2019/02/18/performance-aliyun-cdn/setting-domain-result.png" class="" title="示例"></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>验证 CDN 是否配置正确：确认 cdn 域名是否解析到 CNAME 上。 <img src="/legacy/2019/02/18/performance-aliyun-cdn/ok.png" class="" title="示例"></p><p>实际效果：</p><p>比如之前有个资源地址：<a href="http://image.shidouhua.cn/cdn1.png" target="_blank" rel="noopener">http://image.shidouhua.cn/cdn1.png</a></p><p>当来自客户端的请求获取服务器资源时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次 200</span></span><br><span class="line"><span class="number">58.247</span><span class="number">.91</span><span class="number">.82</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">17</span>:<span class="number">27</span>:<span class="number">00</span> +<span class="number">0800</span>] <span class="string">"GET /cdn1.png HTTP/1.1"</span> <span class="number">200</span> <span class="number">117773</span> <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="string">"-"</span></span><br><span class="line"><span class="comment">// 第二次 因为浏览器缓存，304</span></span><br><span class="line"><span class="number">58.247</span><span class="number">.91</span><span class="number">.82</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">17</span>:<span class="number">27</span>:<span class="number">11</span> +<span class="number">0800</span>] <span class="string">"GET /cdn1.png HTTP/1.1"</span> <span class="number">304</span> <span class="number">0</span> <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure><p>当有了 CDN 后，资源地址 <strong>更改</strong> 为：<a href="http://imagecdn.shidouhua.cn/cdn1.png" target="_blank" rel="noopener">http://imagecdn.shidouhua.cn/cdn1.png</a></p><p>如果配置都 ok ，客户端不会从服务器获取资源，而是从 CDN 节点拿数据，从而 <strong>降低服务器负载，加速网站</strong></p><h2 id="更新-CDN-缓存"><a href="#更新-CDN-缓存" class="headerlink" title="更新 CDN 缓存"></a>更新 CDN 缓存</h2><p>因为缓存，所以就算原服务器更新的资源，客户端也不会及时生效，这就需要在资源变动时主动通知 CND 节点更新新资源。</p><p>手动方式：</p><img src="/legacy/2019/02/18/performance-aliyun-cdn/fresh.png" class="" title="示例"><p>缺点：对于大量资源通过这种方式很难控制</p><p>接口方式： <a href="https://help.aliyun.com/document_detail/27200.html?spm=a2c4g.11186623.6.809.24182c7dfXR2eu" target="_blank" rel="noopener">RefreshObjectCaches 等</a></p><p>优点：可定制化</p><p>缺点：需要开发（但可参考<a href="https://www.npmjs.com/package/refresh-aliyun-cdn" target="_blank" rel="noopener">refresh-aliyun-cdn</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins 执行脚本成功，但进程未启动</title>
      <link href="/legacy/2019/02/13/jenkins-shell-kill/"/>
      <url>/legacy/2019/02/13/jenkins-shell-kill/</url>
      
        <content type="html"><![CDATA[<p>记录个问题，jenkins 成功执行了脚本，但是后台却未见服务进程。</p><h2 id="还原经过"><a href="#还原经过" class="headerlink" title="还原经过"></a>还原经过</h2><p>设置如下：<br><img src="/legacy/2019/02/13/jenkins-shell-kill/1.png" class="" title="示例"></p><p>jenkins 构建时，shell 基本操作都执行 ok（创建文件夹，目录切换），同时 <strong>xx.sh</strong> 脚本也正常运行，所有输出都打在 jenkins 的控制台上。</p><p>蛋疼的事情来了，进到服务器却没有看到 <strong>xx.sh</strong> 脚本启动的新服务。可是控制台却告诉我服务启动成功的（一个黑人脸）</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>也不知道怎么去百度这个问题，好在看到 google 2 篇文章基本知道了原由所在。</p><p>原链接如下，相同问题的道友可以直接看下：<br><a href="https://blog.csdn.net/u011781521/article/details/80210985" target="_blank" rel="noopener">Jenkins 中通过 execute shell 无法启动进程-解决方案合集</a><br><a href="https://blog.csdn.net/weixin_39483907/article/details/80840948" target="_blank" rel="noopener">jenkins 自动部署中执行 shell 脚本启动 tomcat，但是 tomcat 不启动的问题</a></p><p><a href="https://wiki.jenkins.io/display/JENKINS/ProcessTreeKiller#space-menu-link-content" target="_blank" rel="noopener">和 <strong>processTreeKiller</strong> 有关</a></p><blockquote><p>To reliably kill processes spawned by a job during a build, Jenkins contains a bit of native code to list up such processes and kill them. This is tested on several platforms and architectures, but if you find a show-stopper problem because of this, you can disable this feature by setting a Java property named “hudson.util.ProcessTree.disable” to the value “true”.</p></blockquote><p>大概是：在 job 构建时会杀掉进程，我们如上写的 shell 脚本相当于在 jenkins 提供的容器环境中执行，完事后 jenkins 就会回收掉。如果想要避免就要按照 jenkins 提供的参数，设置 hudson.util.ProcessTree.disable 为 true 解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dhudson.util.ProcessTree.disable=<span class="literal">true</span> -jar jenkins.war</span><br></pre></td></tr></table></figure><p>当然在没有找到这个原因时，我这边通过其他方式解决，如果官方方式没有用的同学可以参考下：</p><p>利用 Send build artifacts over SSH</p><p>在该插件中，维护 Exec command 选项，输入需求的 sh 脚本即可。</p><img src="/legacy/2019/02/13/jenkins-shell-kill/2.png" class="" title="示例">]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端做 form 表单提交</title>
      <link href="/legacy/2019/02/13/http-form-submit/"/>
      <url>/legacy/2019/02/13/http-form-submit/</url>
      
        <content type="html"><![CDATA[<p>服务端怎么做 form 表单提交？</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有个 node 服务 serverA 用于做业务接口中间层，完成和下游服务器之间的数据“加工”。普通 ajax api 完全可以胜任，但是遇到 <strong>表单提交</strong> 脑袋就有些懵逼。</p><p>比如：serverA 有个 order 订单接口，需要把客户端传过来的数据处理成 form 格式，然后再 submit 到第三方服务端，第三方服务端将回告一个支付页面给客户端。</p><p>如果在浏览器端，我们可以直接这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"xxx"</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后 js 一个 submit 就完事了，现在因为这个中间层，这样的动作需要放到服务端来完成，就有些不知所措（在 <strong>林同学</strong> 点播后有了如下方案）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在服务端创建一个新接口，用于接受到 order 请求后，把下游服务器换成自己这个新接口（自己请求自己）</p><p>在这个新接口，处理客户端数据，并且提供一个渲染页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>platform<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form1"</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"$&#123;ctx.query.url&#125;"</span> <span class="attr">method</span>=<span class="string">"$&#123;ctx.query.method&#125;"</span>&gt;</span></span><br><span class="line">      $&#123;inputList&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// “自动” 提交</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">'form1'</span>).submit();</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当客户端接口到此页面后自动提交表单给第三方服务，即可</p><img src="/legacy/2019/02/13/http-form-submit/1.png" class="" title="示例"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于这样一个业务场景的解决方案，不需要高超的代码能力，但一定要有坚实的实战经验，和牢靠基础知识。</p><p>说个玩笑话：</p><blockquote><p>我们有个坚强的后盾——Nodejs</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg agent 怎么通知 master 我准备好了</title>
      <link href="/legacy/2019/02/11/egg-agent-how-to-start/"/>
      <url>/legacy/2019/02/11/egg-agent-how-to-start/</url>
      
        <content type="html"><![CDATA[<p>egg <strong>为企业级框架和应用而生</strong>。在国内，像我们这种小创业公司如果需要 Node 服务端的支持，egg 是不错的框架选型（不吹不黑，很省力）。</p><p>学习需要，看了部分源码遇到些“困难”，百度后大多源码解析的 blog 未找到合适的解答（可能我这问题太小了），所以对部分逻辑做了些阅读，这里留做记录。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>首先 egg 是通过 parent、master、agent、app 之间的相互通讯对整个应用的“生命周期”进行细致的控制，如下图：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * master messenger,provide communication between parent, master, agent and app.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             ┌────────┐</span></span><br><span class="line"><span class="comment"> *             │ parent │</span></span><br><span class="line"><span class="comment"> *            /└────────┘\</span></span><br><span class="line"><span class="comment"> *           /     |      \</span></span><br><span class="line"><span class="comment"> *          /  ┌────────┐  \</span></span><br><span class="line"><span class="comment"> *         /   │ master │   \</span></span><br><span class="line"><span class="comment"> *        /    └────────┘    \</span></span><br><span class="line"><span class="comment"> *       /     /         \    \</span></span><br><span class="line"><span class="comment"> *     ┌───────┐         ┌───────┐</span></span><br><span class="line"><span class="comment"> *     │ agent │ ------- │  app  │</span></span><br><span class="line"><span class="comment"> *     └───────┘         └───────┘</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>顺着这样的事件通讯方式，找到如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// agent_worker.js</span></span><br><span class="line">agent.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    agent.removeListener(<span class="string">'error'</span>, startErrorHandler);</span><br><span class="line">    process.send(&#123; <span class="attr">action</span>: <span class="string">'agent-start'</span>, <span class="attr">to</span>: <span class="string">'master'</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>很明显，猜都能猜到这代码作用：通过 IPC 把数据传送给 master。</p><p>但是 <strong>疑问</strong> 来了 agent_worker 的 agent-start 怎么告知 master 他准备好了，来执行之后的逻辑？</p><h1 id="找答案"><a href="#找答案" class="headerlink" title="找答案"></a>找答案</h1><p>源码只要抽丝剥茧总能找到答案，这个开卷考试一样，虽然简单，但漏看一些细节可能会消耗你大量的时间。起码我花了一点精力才捋顺出来（:grimacing: level 不够），下面逐步详细说明：</p><h2 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h2><p>egg 的 master-worker 模式在 egg-cluster 模块中实现，由 egg-script 所触发运行。</p><p>首先通过 spawn 创建一个新进程去执行 egg 的 master-worker 模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// egg-scripts\lib\cmd\start.js</span></span><br><span class="line"><span class="keyword">const</span> child = (<span class="keyword">this</span>.child = spawn(command, eggArgs, options));</span><br></pre></td></tr></table></figure><p>spawn 的 eggArgs 实际会运行如下 script：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// egg-cluster\index.js</span></span><br><span class="line">exports.startCluster = <span class="function"><span class="keyword">function</span>(<span class="params">options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Master(options).ready(callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Master 实例化后，会创建 agent 进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork agent worker (agent_worker.js)</span></span><br><span class="line"><span class="keyword">const</span> agentWorker = childprocess.fork(<span class="keyword">this</span>.getAgentWorkerFile(), args, opt);</span><br></pre></td></tr></table></figure><p>在 agent_worker.js 中代码很简短，很明显能看到如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// agent_worker.js</span></span><br><span class="line">agent.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    agent.removeListener(<span class="string">'error'</span>, startErrorHandler);</span><br><span class="line">    process.send(&#123; <span class="attr">action</span>: <span class="string">'agent-start'</span>, <span class="attr">to</span>: <span class="string">'master'</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可能就会产生这几个疑问：</p><ul><li>process.send 肯定会把 <strong>agent-start</strong> 发送出去，master 怎么接收到 <strong>agent-start</strong> 事件？</li><li>agent_worker fork 完后是不是默认就加载 ready 方法了？</li></ul><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p>先来看第一个问题</p><blockquote><p>master 怎么接收到 <strong>agent-start</strong> 事件？</p></blockquote><p>Master 继承 EventEmitter，初始化时会监听一系列方法，这里就定义了 <strong>agent-start</strong> 事件的监听，并且只执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'agent-exit'</span>, <span class="keyword">this</span>.onAgentExit.bind(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'agent-start'</span>, <span class="keyword">this</span>.onAgentStart.bind(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'app-exit'</span>, <span class="keyword">this</span>.onAppExit.bind(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'app-start'</span>, <span class="keyword">this</span>.onAppStart.bind(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">this</span>.on(<span class="string">'reload-worker'</span>, <span class="keyword">this</span>.onReload.bind(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork app workers after agent started</span></span><br><span class="line">        <span class="keyword">this</span>.once(<span class="string">'agent-start'</span>, <span class="keyword">this</span>.forkAppWorkers.bind(<span class="keyword">this</span>));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 messenger 消息传递方法，建立 master 和 worker 之间的 <strong>事件通讯</strong>。其实内部就是 emit 和 on 的 api 关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// messenger.js</span></span><br><span class="line">sendToMaster(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.master.emit(data.action, data.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 fork agent_worker.js 后，会有个 message 事件监听 agent_worker send 出来的事件，并且也通过 messenger 告知 master。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">forkAgentWorker()&#123;</span><br><span class="line">    ...</span><br><span class="line">    agentWorker.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> msg === <span class="string">'string'</span>) msg = &#123; <span class="attr">action</span>: msg, <span class="attr">data</span>: msg &#125;;</span><br><span class="line">        msg.from = <span class="string">'agent'</span>;</span><br><span class="line">        <span class="keyword">this</span>.messenger.send(msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没弄清 agent.ready() 这个方法，上面这些都只属于“合理”的猜测。</p><h2 id="get-ready"><a href="#get-ready" class="headerlink" title="get-ready"></a>get-ready</h2><p>再来是第二个问题：</p><blockquote><p>agent_worker fork 完后是不是默认就加载 ready 方法了？</p></blockquote><p>这里开始会涉及 <strong>get-ready</strong> 和 <strong>ready-callback</strong> 阿里大佬写的 npm 工具包，这是解决这个疑问的 <strong>关键之处</strong>。</p><p>应该注意到整个 egg 到处都有 ready(…) 式的方法。</p><p>首先来看下 <a href="https://www.npmjs.com/package/get-ready" target="_blank" rel="noopener"><strong>get-ready</strong></a> 有什么用？</p><ul><li>通过 ready.mixin 将目标对象 obj 绑定到 ready 共享属性上</li><li>定义 obj.ready(fn)，将 fn 推到 READY_CALLBACKS 队列中</li><li>传入指定的 flagOrFunction 类型（true），来执行 ready 中预定义好的 READY_CALLBACKS 队列</li></ul><p>来看下 agent 相关整个链路怎么做的：</p><p>实例化 Agent 对象，调用父类 ready 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> agent = <span class="keyword">new</span> Agent(options);</span><br><span class="line">agent.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    process.send(&#123; <span class="attr">action</span>: <span class="string">'agent-start'</span>, <span class="attr">to</span>: <span class="string">'master'</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Agent 继承于 EggApplication，并且 EggApplication 也调用父类 ready 方法。同时 EggApplication 继承于 EggCore。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">extends</span> <span class="title">EggApplication</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggApplication</span> <span class="keyword">extends</span> <span class="title">EggCore</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.ready(<span class="function"><span class="params">()</span> =&gt;</span> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EggCore 初始化创建了 Lifecycle，并定义了 ready 方法，实际上返回 Lifecycle 实例方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EggCore</span> <span class="keyword">extends</span> <span class="title">KoaApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = <span class="keyword">new</span> Lifecycle(&#123;...&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ready(flagOrFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lifecycle.ready(flagOrFunction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 Lifecycle 中使用了 get-ready 模块，并且通过 mixin 将 ready 绑定到 this 上。这样 agent_worker 中定义的 agent.ready function 就被加入到队列中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getReady = <span class="built_in">require</span>(<span class="string">'get-ready'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        getReady.mixin(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>[INIT_READY]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个链路算是走到底了，但是没有发现那里触发 ready 中定义的 READY_CALLBACKS，即 ready(true) 类似这句话。这就和另一个模块 ready-callback 有关了。</p><h2 id="ready-callback"><a href="#ready-callback" class="headerlink" title="ready-callback"></a>ready-callback</h2><p>在 Lifecycle 初始化时，调用 [INIT_READY] 方法，实例化了 Ready 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Ready &#125; = <span class="built_in">require</span>(<span class="string">'ready-callback'</span>);</span><br><span class="line">[INIT_READY]() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadReady = <span class="keyword">new</span> Ready(&#123; <span class="attr">timeout</span>: <span class="keyword">this</span>.readyTimeout &#125;);</span><br><span class="line">    <span class="keyword">this</span>[DELEGATE_READY_EVENT](<span class="keyword">this</span>.loadReady);</span><br><span class="line">    <span class="keyword">this</span>.loadReady.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.bootReady = <span class="keyword">new</span> Ready(&#123; <span class="attr">timeout</span>: <span class="keyword">this</span>.readyTimeout, <span class="attr">lazyStart</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>[DELEGATE_READY_EVENT](<span class="keyword">this</span>.bootReady);</span><br><span class="line">    <span class="keyword">this</span>.bootReady.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.ready(err || <span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ready-callback 属于 get-ready 的上层封装，也 mixin 到 Ready 对象上，具备 ready 属性。</p><p>在执行相关初始化 api 时，就能看到如下调用逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start() &#123;</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.ready(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样所有的 ready 定义的方法将会被按顺序执行，解释了 agent.ready 的运行触发点。</p><p>到此算是解答了开头两个疑问。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题其实不算复杂，主要牵扯的对象太多容易乱。这里贴下简易 demo 版本说明下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ready = <span class="built_in">require</span>(<span class="string">'get-ready'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Life</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ready.mixin(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  start(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ready = fn;</span><br><span class="line">    <span class="keyword">this</span>.ready(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = <span class="keyword">new</span> Life();</span><br><span class="line">  &#125;</span><br><span class="line">  ready(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lifecycle.start(fn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">extends</span> <span class="title">Core</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ready.mixin(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.ready(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'master ready'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// this.ready(true);</span></span><br><span class="line">    <span class="keyword">this</span>.callAgent();</span><br><span class="line">  &#125;</span><br><span class="line">  callAgent() &#123;</span><br><span class="line">    <span class="keyword">const</span> agent = <span class="keyword">new</span> Agent();</span><br><span class="line">    agent.ready(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'agent ready'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Master().ready(<span class="literal">undefined</span>); <span class="comment">//agent ready</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm cheerio 模块</title>
      <link href="/legacy/2019/01/24/npm-cheerio/"/>
      <url>/legacy/2019/01/24/npm-cheerio/</url>
      
        <content type="html"><![CDATA[<p>昨天在爬禅道页面的数据，用到了 cheerio ，觉得不错，这里简单介绍下</p><h1 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a><a href="https://www.npmjs.com/package/cheerio" target="_blank" rel="noopener">cheerio</a></h1><p>cheerio 用于在 server 端，解析 Html 模板。语法和 jQuery 差不多，很简单。</p><p>可以看下官方的描述：</p><blockquote><p>Fast, flexible &amp; lean implementation of core jQuery designed specifically for the server.</p></blockquote><p>每周将近 200w 的下载量，证明是个不错的包。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>简单说明下怎么用它来解析 HTML 数据</p><p>通过 fetch 获取页面 body 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'/zentao/bug-browse-10-resolvedByMe-0--205-1000-1.html'</span>;</span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">await</span> promiseFetchUrl(url);</span><br></pre></td></tr></table></figure><p>使用 cheerio 加载页面数据，使用类似 jq selector 规则进行源数据的获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = cheerio.load(data.toString());</span><br><span class="line"><span class="keyword">var</span> $list = $(<span class="string">'#bugList tbody'</span>).find(<span class="string">'tr'</span>);</span><br></pre></td></tr></table></figure><p>遍历，根据数据位置加工成目标数据，存放于 list 对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; $list.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> $item = $list.eq(i).find(<span class="string">'td'</span>);</span><br><span class="line">  <span class="keyword">var</span> id = $item</span><br><span class="line">    .eq(<span class="number">0</span>)</span><br><span class="line">    .find(<span class="string">'a'</span>)</span><br><span class="line">    .text();</span><br><span class="line">  <span class="keyword">var</span> creator = $item.eq(<span class="number">4</span>).text();</span><br><span class="line">  <span class="keyword">var</span> title = $item</span><br><span class="line">    .eq(<span class="number">3</span>)</span><br><span class="line">    .find(<span class="string">'a'</span>)</span><br><span class="line">    .text();</span><br><span class="line">  <span class="keyword">var</span> href = $item</span><br><span class="line">    .eq(<span class="number">0</span>)</span><br><span class="line">    .find(<span class="string">'a'</span>)</span><br><span class="line">    .attr(<span class="string">'href'</span>);</span><br><span class="line">  <span class="keyword">var</span> index = i + <span class="number">1</span>;</span><br><span class="line">  list.push(&#123;</span><br><span class="line">    index,</span><br><span class="line">    id,</span><br><span class="line">    creator,</span><br><span class="line">    title,</span><br><span class="line">    href</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">index: <span class="number">1</span>,</span><br><span class="line">id: <span class="string">'039'</span>,</span><br><span class="line">creator: <span class="string">'xx'</span>,</span><br><span class="line">title: <span class="string">'xxx'</span>,</span><br><span class="line">href: <span class="string">'/zentao/bug-view-39.html'</span>,</span><br><span class="line">time: <span class="string">'2015-10-10 11:42:09'</span>,</span><br><span class="line">time2: <span class="string">'2015-10-10'</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="“链式”请求"><a href="#“链式”请求" class="headerlink" title="“链式”请求"></a>“链式”请求</h2><p>可能需要更多详细数据，但是这个页面没有提供，需要根据 a 标签再发起请求进行获取。但实际过程会遇到某些问题：</p><p>对于上面的 list.href，通过遍历很容易拿到。那怎么在循环里继续发起请求？</p><p>可能你会想到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    list[i].data = <span class="keyword">await</span> fetch(list[i].href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 list.length 过大，势必会让这样的同步函数执行时间过长，那是不是可以用 promise.all 解决？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promiseList = [];</span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    promiseList.push(fetchPromise(list[i].href));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all(promiseList).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看似很 ok ，其实万万没想到禅道居然还有 <strong>并发限制</strong>，于是有了如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise function</span></span><br><span class="line"><span class="keyword">var</span> getTime = <span class="keyword">async</span> href =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> promiseFetchUrl(href);</span><br><span class="line">  <span class="keyword">var</span> $$ = cheerio.load(data.toString());</span><br><span class="line">  <span class="keyword">var</span> time = $$(<span class="string">'#legendLife table tr'</span>)</span><br><span class="line">    .eq(<span class="number">0</span>)</span><br><span class="line">    .find(<span class="string">'td'</span>)</span><br><span class="line">    .text()</span><br><span class="line">    .split(<span class="string">'于 '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">100</span>; <span class="comment">// 并发次数max限制</span></span><br><span class="line"><span class="keyword">let</span> loop = $list.length / count; <span class="comment">//分批次数</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> promiseTimeFn = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = pos; j &lt; count + pos &amp;&amp; j &lt; $list.length; j++) &#123;</span><br><span class="line">    <span class="comment">// 组装每批 promise</span></span><br><span class="line">    promiseTimeFn.push(getTime(list[j].href));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promiseTimeFn);</span><br><span class="line">  <span class="comment">// 数据处理</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="number">0</span>; d &lt; data.length; d++) &#123;</span><br><span class="line">    list[d + pos].time = data[d];</span><br><span class="line">    list[d + pos].time2 = data[d].split(<span class="string">' '</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 准备下批数据</span></span><br><span class="line">  pos = count + pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux signals 标识</title>
      <link href="/legacy/2019/01/21/linux-signals/"/>
      <url>/legacy/2019/01/21/linux-signals/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-standard-signals"><a href="#linux-standard-signals" class="headerlink" title="linux standard signals"></a>linux standard signals</h1><p>15 年左右，阿里的“死马”（我忘记花名叫啥了）提到了 <a href="https://www.npmjs.com/package/graceful-process" target="_blank" rel="noopener">graceful-process</a> ，然后看到如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.once(<span class="string">'SIGTERM'</span>, () =&gt; &#123;</span><br><span class="line">  printLogLevels.info &amp;&amp; logger.info(<span class="string">'[%s] receive signal SIGTERM, exiting with code:0'</span>, label);</span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>process 因为是 EventEmitter 的延伸类，具备监听事件功能。但是 <strong>SIGTERM</strong> 是什么？在 Node 官网只看到这样一个地址：<a href="http://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/signal.7.html</a></p><p>下面一起来了解下：</p><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>首先 <strong>signal</strong> 是 Linux 支持 POSIX 范式约定的标识。</p><p>signal 用途分类：</p><table><thead><tr><th>dispositions</th><th>描述</th></tr></thead><tbody><tr><td>Term</td><td>Default action is to terminate the process.</td></tr><tr><td>Ign</td><td>Default action is to ignore the signal.</td></tr><tr><td>Core</td><td>Default action is to terminate the process and dump core (see</td></tr><tr><td>core(5)).</td></tr><tr><td>Stop</td><td>Default action is to stop the process.</td></tr><tr><td>Cont</td><td>Default action is to continue the process if it is currently stopped.</td></tr></tbody></table><p><strong>Standard signals</strong> 标准信号：</p><blockquote><p>Linux supports the standard signals listed below. Several signal numbers are architecture-dependent, as indicated in the “Value” column. (Where three values are given, the first one is usually valid for alpha and sparc, the middle one for x86, arm, and most other architectures, and the last one for mips. (Values for parisc are not shown; see the Linux kernel source for signal numbering on that architecture.) A dash (-) denotes that a signal is absent on the corresponding architecture.</p></blockquote><p>SIGTERM 是 <strong>Standard signals</strong> 的一种，见下表：</p><table><thead><tr><th>Signal</th><th>Value</th><th>Action</th><th>Comment</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>Term</td><td>Hangup detected on controlling terminal or death of controlling process</td></tr><tr><td>SIGINT</td><td>2</td><td>Term</td><td>Interrupt from keyboard</td></tr><tr><td>SIGQUIT</td><td>3</td><td>Core</td><td>Quit from keyboard</td></tr><tr><td>SIGILL</td><td>4</td><td>Core</td><td>Illegal Instruction</td></tr><tr><td>SIGABRT</td><td>6</td><td>Core</td><td>Abort signal from abort(3)</td></tr><tr><td>SIGFPE</td><td>8</td><td>Core</td><td>Floating-point exception</td></tr><tr><td>SIGKILL</td><td>9</td><td>Term</td><td>Kill signal</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Core</td><td>Invalid memory reference</td></tr><tr><td>SIGPIPE</td><td>13</td><td>Term</td><td>Broken pipe: write to pipe with no readers; see pipe(7)</td></tr><tr><td>SIGALRM</td><td>14</td><td>Term</td><td>Timer signal from alarm(2)</td></tr><tr><td>SIGTERM</td><td>15</td><td>Term</td><td>Termination signal</td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>Term</td><td>User-defined signal 1</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>Term</td><td>User-defined signal 2</td></tr><tr><td>SIGCHLD</td><td>20,17,18</td><td>Ign</td><td>Child stopped or terminated</td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td>Cont</td><td>Continue if stopped</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>Stop</td><td>Stop process</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>Stop</td><td>Stop typed at terminal</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>Stop</td><td>Terminal input for background process</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>Stop</td><td>Terminal output for background process</td></tr></tbody></table><p>能看到 <strong>SIGTERM</strong> 归类在 Term ，用于终止程序运行，当然根据更细致的行为可能要选择不同的 signal。</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>大概了解了 <strong>signals</strong>，之后可以再回顾下 <strong>kill</strong> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill</span><br><span class="line">kill: usage: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]</span><br><span class="line">[root@localhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>能看到里面提供一大堆 signal 选项。</p><p>平时使用的如下命令，作用就是结合上面的 <strong>Standard signals</strong> 的 Value 来进行操作的。很容易查找出 -9 对应 <strong>SIGKILL</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">-9</span> process id</span><br></pre></td></tr></table></figure><p>到此，回到最初的 node 代码，就知晓其中的含义了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 脚本执行</title>
      <link href="/legacy/2019/01/12/npm-bin/"/>
      <url>/legacy/2019/01/12/npm-bin/</url>
      
        <content type="html"><![CDATA[<h1 id="npm-脚本执行"><a href="#npm-脚本执行" class="headerlink" title="npm 脚本执行"></a>npm 脚本执行</h1><p>先看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// egg package.json</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"egg-scripts start --daemon --title=egg-server-example"</span>,</span><br><span class="line">    <span class="string">"stop"</span>: <span class="string">"egg-scripts stop --title=egg-server-example"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后问几个问题：</p><ul><li><strong>egg-scripts</strong> 没有全局安装，怎么能使用？</li><li>怎么没有类似 <strong>bin/<a href="http://www.js" target="_blank" rel="noopener">www.js</a></strong> 的启动文件？</li><li><strong>–daemon –title=egg-server-example</strong> 怎么起效果？</li></ul><p>如果你对这些很模糊，就有必要看下这里解释了。</p><h1 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h1><h2 id="node-modules-执行环境"><a href="#node-modules-执行环境" class="headerlink" title="node_modules 执行环境"></a>node_modules 执行环境</h2><blockquote><p>Q1: <strong>egg-scripts</strong> 没有全局安装，怎么能使用？</p></blockquote><p>既然没有执行 <strong>npm install egg-scripts -g</strong> ，为什么能找到这个插件，不是应该报这种错误么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: xx: command not found</span><br></pre></td></tr></table></figure><p>首先要知道 <strong>npm install xx -g</strong> 怎么能使得某命令全局范围生效？</p><p>先查看下 <strong>系统环境变量</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shixinghaodeMacBook-Pro:bin shixinghao$ env</span><br><span class="line">PATH=<span class="regexp">/usr/</span>local/bin:<span class="regexp">/usr/</span>bin:<span class="regexp">/bin:/u</span>sr/sbin:<span class="regexp">/sbin</span></span><br></pre></td></tr></table></figure><p>然后再看对应的 /usr/local/bin/ 下有哪些程序链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shixinghaodeMacBook-Pro:bin shixinghao$ cd /usr/local/bin/</span><br><span class="line">shixinghaodeMacBook-Pro:bin shixinghao$ ls</span><br><span class="line">cnpmngnpmyarn</span><br><span class="line">egg-initnodenpxyarnpkg</span><br></pre></td></tr></table></figure><p>这就是控制台键入 <strong>node -v</strong> 能输出版本号等信息的原因。</p><p>然后再看下我们安装的 global modules ，用 ls -l 查看下会发现全局包最终的原地址就是 <strong>/usr/local/lib/node_modules/</strong> 下  的文件（其实就是超链接）。因为有了这些定义好的系统环境上的变量，就能在控制台输入 egg-init 等命令就能执行相关程序文件。</p><p>要完全回答第一个问题，还要继续看下个点。</p><h2 id="package-json-bin-配置"><a href="#package-json-bin-配置" class="headerlink" title="package.json bin 配置"></a>package.json bin 配置</h2><p>那么我运行本地安装的 node_modules 可不可行呢？其实这很打脸，明显不行。但不妨一试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /egg-example/node_modules/ademo-bin 自定义的包</span></span><br><span class="line">shixinghaodeMacBook-Pro:egg-example shixinghao$ ademo-bin</span><br><span class="line">bash: ademo-bin: command not found</span><br></pre></td></tr></table></figure><p>如果想要本地安装的 modules 和全局安装和相同的效果，就要通过 npm 来实现和系统环境一样的逻辑，接下来就要了解下 <a href="https://docs.npmjs.com/cli/bin.html" target="_blank" rel="noopener">npm bin</a> 相关机制。</p><blockquote><p>Print the folder where npm will install executables.</p></blockquote><p>有了上面解释 <strong>环境变量</strong> 一些概念加上 bin 的一些解释，很容易明白 .bin 文件夹的含义。</p><p>简单说安装好本地 modules 后，npm 会自动把 modules bin 文件扔到 node_modules/.bin 下。我们可以检查下已有的 npm bin 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shixinghaodeMacBook-Pro:egg-example shixinghao$ npm bin</span><br><span class="line">&#x2F;Applications&#x2F;eminoda&#x2F;github_project&#x2F;egg-example&#x2F;node_modules&#x2F;.bin</span><br><span class="line">shixinghaodeMacBook-Pro:egg-example shixinghao$ npm bin -g</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p>来翻下 egg 项目 .bin 目录：</p><img src="/legacy/2019/01/12/npm-bin/1.png" class=""><p>发现了 egg-script 的踪迹，那么问题又来了，怎么就自动添加到 .bin 中呢？</p><p>原理不说了，可以直接看这个链接 <a href="https://docs.npmjs.com/files/package.json#bin" target="_blank" rel="noopener">https://docs.npmjs.com/files/package.json#bin</a> ,下面实际操作下：</p><p>这里写了个简单的 module：<a href="https://www.npmjs.com/package/demo-bin-test" target="_blank" rel="noopener">demo-bin-test</a>，用来测试 bin 配置。</p><p><strong>npm -i demo-bin-test</strong> 后，可以看到在 package.json 维护的 bin 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">    <span class="string">"demo-bin-test"</span>: <span class="string">"bin/index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置很重要，在 npm install 的时候就解析这句配置，然后在 node_modules/.bin 添加我们定义的 demo-bin-test 命令脚本。在执行该命令时，就是先从 npm 的本地 bin 环境作用域开始寻找，再从 global 范围寻找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"demo-bin-test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以直接运行 npm start 看会出现什么效果？</p><p>调用了 /node_modules/demo-bin-test/bin/index.js 本地文件。到此就解释了第一个问题。</p><h2 id="egg-的启动文件"><a href="#egg-的启动文件" class="headerlink" title="egg 的启动文件"></a>egg 的启动文件</h2><blockquote><p>怎么没有类似 <strong>bin/<a href="http://www.js" target="_blank" rel="noopener">www.js</a></strong> 的启动文件？</p></blockquote><p>通常我们都是定义如下的程序启动文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>:&#123;</span><br><span class="line">    <span class="string">"start"</span>:<span class="string">"node ./bin/www.js"</span> <span class="comment">// npm [run] start 运行项目下 /bin/www.js 文件，从而开启应用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在举例的 script start 却没有启动文件，这就牵扯到 egg 运行机制上的一些东西，简单说 <strong>入口文件</strong> 被 egg 所封装起来。</p><p>虽然本文不是详细介绍 egg ，但理解透彻这完整的 script 脚本很有必要，简单说明下怎么找到真实的入口 js：</p><ol><li><p>运行启动文件</p><p>当然没有全局安装过 egg-scripts ，后面解释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span>: <span class="string">"egg-scripts start ..."</span></span><br></pre></td></tr></table></figure></li><li><p>运行 <strong>start-cluster</strong></p><p>进入到本地 node_modules 找到 egg-scripts ，其实核心通过继承 <strong>Command</strong> 实现了自己脚本命令的方式（第三个问题在做说明）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /egg-example/node_modules/egg-scripts/lib/cmd/start.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(rawArgv) &#123;</span><br><span class="line">        <span class="comment">// 注意这个文件</span></span><br><span class="line">        <span class="keyword">this</span>.serverBin = path.join(__dirname, <span class="string">'../start-cluster'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化的时候运行</span></span><br><span class="line">    * run(context) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">const</span> eggArgs = [ ...(execArgv || []), <span class="keyword">this</span>.serverBin, clusterOptions, <span class="string">`--title=<span class="subst">$&#123;argv.title&#125;</span>`</span> ];</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// child_spawn 开启新的子命令窗口，执行相关 args</span></span><br><span class="line">        <span class="keyword">const</span> child = <span class="keyword">this</span>.child = spawn(command, eggArgs, options);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 start-cluster 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /egg-example/node_modules/egg-scripts/lib/start-cluster</span></span><br><span class="line"><span class="built_in">require</span>(options.framework).startCluster(options);</span><br></pre></td></tr></table></figure><p>startCluster 这个方法其实就是在 <strong>egg</strong> 中定义的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /egg-example/node_modules/egg/index.js</span></span><br><span class="line">exports.startCluster = <span class="built_in">require</span>(<span class="string">'egg-cluster'</span>).startCluster;</span><br></pre></td></tr></table></figure></li><li><p>egg</p><p>找着找着，你就会发现其实就是调用 app_worker</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Applications/eminoda/github_project/egg-example/node_modules/egg-cluster/lib/app_worker.js</span></span><br><span class="line"><span class="keyword">const</span> Application = <span class="built_in">require</span>(options.framework).Application;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>备注下：framework 其实就是前面在 egg-script 中定义好的 egg modules 的框架路径</p><p>到这里基本也能猜到后续怎么回事了，更深层次的内容请各位看官线下继续学习 :grimacing:</p></li></ol><h1 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h1><p>再来看最后个问题：</p><blockquote><p><strong>–daemon –title=egg-server-example</strong> 怎么起效果？</p></blockquote><p>这用到了 <a href="https://www.npmjs.com/package/common-bin" target="_blank" rel="noopener"><strong>command-bin</strong></a> 模块</p><p><strong>Build a bin tool for your team</strong></p><blockquote><p>You maybe need a custom xxx-bin to implement more custom features.</p></blockquote><p>具体怎么回事，同样可以参考如下的 demo 示例（<a href="https://www.npmjs.com/package/demo-bin-test" target="_blank" rel="noopener">demo-bin-test</a>）：</p><p>继承 Command ，定义相关配置（控制台使用说明文件、加载命令脚本、别名定义）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo-bin-test/bin/command.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Command = <span class="built_in">require</span>(<span class="string">'common-bin'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawArgv) &#123;</span><br><span class="line">    <span class="keyword">super</span>(rawArgv);</span><br><span class="line">    <span class="keyword">this</span>.usage = <span class="string">'Usage: demo &lt;command&gt; [options]'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load entire command directory</span></span><br><span class="line">    <span class="keyword">this</span>.load(path.join(__dirname, <span class="string">'cmd'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.yargs.alias(<span class="string">'v'</span>, <span class="string">'version'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MainCommand;</span><br></pre></td></tr></table></figure><p>然后执行该 js，就能看到控制台出现如下信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shixinghaodeMacBook-Pro:demo-bin-test shixinghao$ node ./bin/command.js</span><br><span class="line">Usage: demo &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  command.js completion  generate bash completion script</span><br><span class="line">  command.js start</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  -h, --help                显示帮助信息                                                                          [布尔]</span><br><span class="line">  -v, --version, --version  显示版本号                                                                            [布尔]</span><br></pre></td></tr></table></figure><p>再定义具体命令参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo-bin-test/cmd/start.js</span></span><br><span class="line"><span class="keyword">const</span> Command = <span class="built_in">require</span>(<span class="string">'common-bin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(rawArgv) &#123;</span><br><span class="line">    <span class="keyword">super</span>(rawArgv);</span><br><span class="line">    <span class="keyword">this</span>.options = &#123;</span><br><span class="line">      name: &#123;</span><br><span class="line">        type: <span class="string">'string'</span>,</span><br><span class="line">        description: <span class="string">'project name'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  *run(&#123; argv &#125;) &#123;</span><br><span class="line">    <span class="comment">// input：start --name=test</span></span><br><span class="line">    <span class="comment">// console.log(argv)</span></span><br><span class="line">    <span class="keyword">let</span> ls = spawn(<span class="string">'node'</span>, [<span class="string">'./say.js'</span>], &#123;&#125;);</span><br><span class="line">    ls.stdout.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = StartCommand;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /demo-bin-test/say.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br></pre></td></tr></table></figure><p>定义一个 start.js ，然后在上面的命令后追加 start 并执行，Command 就会调用 run 方法，输出需要的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shixinghaodeMacBook-Pro:demo-bin-test shixinghao$ node ./bin/command.js start</span><br><span class="line">stdout: say</span><br></pre></td></tr></table></figure><p>点到为止，其实就是参照 egg-scripts 写了个简单的 Demo。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为做其他事情需要，有了开头三个小问题，没想到会牵扯那么多知识点。拖的时间有些长，不过还是蛮有意义的。</p><p>参考：</p><ul><li><a href="https://eggjs.org/zh-cn/intro/egg-and-koa.html" target="_blank" rel="noopener">egg 官方文档</a></li><li><a href="https://www.npmjs.com/package/common-bin" target="_blank" rel="noopener">npm common-bin</a></li><li><a href="child_process_options_stdio">node child_process</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 里不平凡的函数</title>
      <link href="/legacy/2018/12/27/js-special-function/"/>
      <url>/legacy/2018/12/27/js-special-function/</url>
      
        <content type="html"><![CDATA[<p>函数 function 作为 js 里的一等公民，这样一句话做前端的总多多少少听说过。其实更为准确应该描述为 <strong>First-class functions</strong>。</p><p>对于 first-class function 可以翻译成 <strong>头等函数</strong>、一等函数。</p><p>即使 js 没有像 java 一样有类的概念，但通过 function 各种风骚的操作，让我们在 <strong>面向函数编程</strong> 中更欢乐的使用 js。</p><h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>对于 <strong>函数模型</strong> 实现并不是所有程序语言都支持，或者放在头等重要的位置。就比如 <strong>高阶函数</strong>， java 直到 jdk8 有了 lambda 才能使用起来。如下贴个语言支持表：</p><img src="/legacy/2018/12/27/js-special-function/function-limit.png" class="" title="语言支持"><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>要成为高阶函数，要具备如下 2 个条件之一：</p><ul><li>能让函数作为参数作为输入</li><li>输出一个函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = a + b;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySum</span>(<span class="params">sum, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum(<span class="number">1</span>, <span class="number">2</span>) + c;</span><br><span class="line">&#125;</span><br><span class="line">mySum(sum, <span class="number">3</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数-Partial-Application"><a href="#偏函数-Partial-Application" class="headerlink" title="偏函数 Partial Application"></a>偏函数 Partial Application</h2><blockquote><p>In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given a function <strong>f:(X * Y * Z)-&gt; N</strong>, we might fix (or ‘bind’) the first argument, producing a function of type <strong>partial(f):(Y * Z)-&gt;N</strong>.</p></blockquote><p>简单理解就是写个 <strong>偏函数</strong> ，效果是实现某功能需要的参数发生了变化，参数变成更小/少的元（arity）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pSum</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, <span class="number">1</span>, c)(); <span class="comment">//1+2</span></span><br><span class="line">&#125;</span><br><span class="line">pSum(<span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="柯里函数-Currying"><a href="#柯里函数-Currying" class="headerlink" title="柯里函数 Currying"></a>柯里函数 Currying</h2><blockquote><p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currySum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>糊里糊涂说了几个概念，其实对于 <strong>面向函数编程</strong> 的 js 来说，了解这些会提升编程体验，和知道设计模式是一个道理。除了装 X，更多的可是使我们能容易理解优秀框架的代码，从而落实到工作中。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" target="_blank" rel="noopener">mdn-First-class_Function</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">wiki-头等函数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">wiki-高阶函数</a></li><li><a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="noopener">wiki-partial application</a></li><li><a href="https://www.datchley.name/currying-vs-partial-application/" target="_blank" rel="noopener">currying-vs-partial-application</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">mqyqingfeng-<br>JavaScript 专题之函数柯里化</a></li><li><a href="https://www.zhihu.com/question/19729316" target="_blank" rel="noopener">知乎-面向对象程序设计比传统的面向过程程序设计更有什么好处？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flow 静态代码检查工具</title>
      <link href="/legacy/2018/12/12/flow-quickstart/"/>
      <url>/legacy/2018/12/12/flow-quickstart/</url>
      
        <content type="html"><![CDATA[<p>和上一篇一样 <a href="https://eminoda.github.io/2018/12/11/rollup-quickstart/" target="_blank" rel="noopener">rollup 5 分钟入门</a>，这也是快速入门，目的就是为了看 Vue 代码。</p><p>当然如果你有 <strong>Typescript</strong> 的经验，很快就能知道是怎么一回事了。</p><h1 id="FLow"><a href="#FLow" class="headerlink" title="FLow"></a>FLow</h1><p><strong>Flow</strong> 是一个对 js 做静态类型检查的工具，可以让整个代码更稳定，正确。</p><blockquote><p>Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.</p></blockquote><h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install flow -D</span><br></pre></td></tr></table></figure></li><li><p>环境配置</p><p>package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;rollup -c .&#x2F;script&#x2F;rollup.config.js --environment TARGET:dev&quot;,</span><br><span class="line">    &quot;flow&quot;: &quot;flow check&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.flowconfig 可以通过 <strong>flow init</strong> 生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ignore]</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">.&#x2F;src&#x2F;.\*</span><br><span class="line"></span><br><span class="line">[libs]</span><br><span class="line"></span><br><span class="line">[lints]</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line"></span><br><span class="line">[strict]</span><br></pre></td></tr></table></figure></li><li><p>配合 rollup，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查代码，如果Error将会输出在控台</span><br><span class="line">npm run flow</span><br><span class="line">&#x2F;&#x2F; 执行rollup构建</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>rollup.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flow = <span class="built_in">require</span>(<span class="string">'rollup-plugin-flow-no-whitespace'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    file: <span class="string">'./packages/output.bundle.js'</span>,</span><br><span class="line">    format: <span class="string">'cjs'</span>,</span><br><span class="line">    name: <span class="string">'test'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [flow()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>output.bundle.js 输出文件（能看到类型检查的代码被 ignore 了）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'default string'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'test'</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Test;</span><br></pre></td></tr></table></figure></li></ol><h2 id="flowconfig"><a href="#flowconfig" class="headerlink" title=".flowconfig"></a><a href="https://flow.org/en/docs/config/" target="_blank" rel="noopener">.flowconfig</a></h2><p>.flowconfig 文件中的路径相对于该文件所处的位置</p><p>所有配置参考 <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp" target="_blank" rel="noopener">OCaml regular expressions</a></p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line"># 当前目录相对路径为：&#x2F;path&#x2F;to&#x2F;root&#x2F;</span><br><span class="line">..&#x2F;externalFile.js              # &#x2F;path&#x2F;to&#x2F;externalFile.js</span><br><span class="line">..&#x2F;externalDir&#x2F;                 # &#x2F;path&#x2F;to&#x2F;externalDir&#x2F;</span><br><span class="line">..&#x2F;otherProject&#x2F;*.js            # &#x2F;path&#x2F;to&#x2F;otherProject&#x2F;下，所有.js后缀的文件</span><br><span class="line">..&#x2F;otherProject&#x2F;**&#x2F;coolStuff&#x2F;   # &#x2F;path&#x2F;to&#x2F;otherProject下，已coolStuff&#x2F;开头的路径</span><br><span class="line"></span><br><span class="line">[ignore]</span><br><span class="line">.*&#x2F;__tests__&#x2F;.*                 # 忽略所有__tests__下的文件</span><br><span class="line">.*&#x2F;src&#x2F;\(foo\|bar\)&#x2F;.*          # 忽略 src&#x2F;foo or src&#x2F;bar</span><br><span class="line">.*\.ignore\.js                  # 忽略 指定.ignore.js文件</span><br></pre></td></tr></table></figure><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>贴出最常用的一些配置，详细还是要<a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener">参阅官网</a></p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a><a href="https://flow.org/en/docs/cli/" target="_blank" rel="noopener">CLI</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flow check</span><br><span class="line">flow init</span><br></pre></td></tr></table></figure><table><thead><tr><th>cli</th><th>说明</th></tr></thead><tbody><tr><td>check</td><td>开始审查 Does a full Flow check and prints the results</td></tr><tr><td>init</td><td>初始化配置文件</td></tr><tr><td>ast</td><td>Print the AST</td></tr><tr><td>autocomplete</td><td>Queries autocompletion information</td></tr><tr><td>server</td><td>Runs a Flow server in the foreground</td></tr><tr><td>start</td><td>Starts a Flow server</td></tr><tr><td>status</td><td>(default) Shows current Flow errors by asking the Flow server</td></tr><tr><td>stop</td><td>Stops a Flow server</td></tr><tr><td>version</td><td>Print version information</td></tr><tr><td>–help</td><td>This list of options</td></tr></tbody></table><h3 id="Type-Annotations-类型标注"><a href="#Type-Annotations-类型标注" class="headerlink" title="Type Annotations 类型标注"></a>Type Annotations 类型标注</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function concat(a: string, b: string) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">concat(&quot;A&quot;, &quot;B&quot;); &#x2F;&#x2F; Works!</span><br><span class="line">concat(1, 2); &#x2F;&#x2F; Error!</span><br></pre></td></tr></table></figure><h3 id="Primitive-Types-基本数据类型"><a href="#Primitive-Types-基本数据类型" class="headerlink" title="Primitive Types 基本数据类型"></a>Primitive Types 基本数据类型</h3><ul><li>Booleans - boolean</li><li>Strings - string</li><li>Numbers - number</li><li>null - null</li><li>undefined - void</li><li>Symbols （Flow 暂不支持）</li></ul><h3 id="Maybe-Types-可能的类型"><a href="#Maybe-Types-可能的类型" class="headerlink" title="Maybe Types 可能的类型"></a>Maybe Types 可能的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function acceptsMaybeString(value: ?string) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">acceptsMaybeString(&quot;bar&quot;);     &#x2F;&#x2F; Works!</span><br><span class="line">acceptsMaybeString(undefined); &#x2F;&#x2F; Works!</span><br><span class="line">acceptsMaybeString(null);      &#x2F;&#x2F; Works!</span><br></pre></td></tr></table></figure><h3 id="Optional-object-properties-对象参数可选"><a href="#Optional-object-properties-对象参数可选" class="headerlink" title="Optional object properties 对象参数可选"></a>Optional object properties 对象参数可选</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @flow</span><br><span class="line">function acceptsObject(value: &#123; foo?: string &#125;) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsObject(&#123; foo: &quot;bar&quot; &#125;);     &#x2F;&#x2F; Works!</span><br><span class="line">acceptsObject(&#123; foo: undefined &#125;); &#x2F;&#x2F; Works!</span><br><span class="line">acceptsObject(&#123; foo: null &#125;);      &#x2F;&#x2F; Error!</span><br><span class="line">acceptsObject(&#123;&#125;);                 &#x2F;&#x2F; Works!</span><br></pre></td></tr></table></figure><h3 id="Optional-function-parameters-参数列表参数可选"><a href="#Optional-function-parameters-参数列表参数可选" class="headerlink" title="Optional function parameters 参数列表参数可选"></a>Optional function parameters 参数列表参数可选</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @flow</span><br><span class="line">function acceptsOptionalString(value?: string) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsOptionalString(&quot;bar&quot;);     &#x2F;&#x2F; Works!</span><br><span class="line">acceptsOptionalString(undefined); &#x2F;&#x2F; Works!</span><br><span class="line">acceptsOptionalString(null);      &#x2F;&#x2F; Error!</span><br><span class="line">acceptsOptionalString();          &#x2F;&#x2F; Works!</span><br></pre></td></tr></table></figure><h3 id="Literal-Types-文字（常量）类型"><a href="#Literal-Types-文字（常量）类型" class="headerlink" title="Literal Types 文字（常量）类型"></a>Literal Types 文字（常量）类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @flow</span><br><span class="line">function acceptsTwo(value: 2) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsTwo(2);   &#x2F;&#x2F; Works!</span><br><span class="line">&#x2F;&#x2F; $ExpectError</span><br><span class="line">acceptsTwo(3);   &#x2F;&#x2F; Error!</span><br><span class="line">&#x2F;&#x2F; $ExpectError</span><br><span class="line">acceptsTwo(&quot;2&quot;); &#x2F;&#x2F; Error!</span><br></pre></td></tr></table></figure><p>多个可能值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @flow</span><br><span class="line">function getColor(name: &quot;success&quot; | &quot;warning&quot; | &quot;danger&quot;) &#123;</span><br><span class="line">  switch (name) &#123;</span><br><span class="line">    case &quot;success&quot; : return &quot;green&quot;;</span><br><span class="line">    case &quot;warning&quot; : return &quot;yellow&quot;;</span><br><span class="line">    case &quot;danger&quot;  : return &quot;red&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(&quot;success&quot;); &#x2F;&#x2F; Works!</span><br><span class="line">getColor(&quot;danger&quot;);  &#x2F;&#x2F; Works!</span><br><span class="line">&#x2F;&#x2F; $ExpectError</span><br><span class="line">getColor(&quot;error&quot;);   &#x2F;&#x2F; Error!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rollup 5 分钟入门</title>
      <link href="/legacy/2018/12/11/rollup-quickstart/"/>
      <url>/legacy/2018/12/11/rollup-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h1><p>不会耽搁太长时间，因为要看 vue 源码，其构建用的是 <strong>rollup</strong> ，而非 webpack。所以简单看了下。</p><p>如果要详细了解：<a href="https://rollupjs.org" target="_blank" rel="noopener">https://rollupjs.org</a></p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>和 webpack 一样，是一种“模块”构建工具，但和 webpack 有什么区别？这仁者见智了。起码我刚用 rollup 有以下几个体会：</p><ul><li><p>更容易上手。</p><p>可能有 webpack 经验，但简约的配置让一个新手能快速构建项目。</p></li><li><p>指定 lib 输出环境，更适合编译<strong>框架 js</strong></p><p>通过<strong>–format</strong>，可以指定输出 cmd，umd…等最终文件。</p></li><li><p>Tree-shaking</p><p>没有测试过，但上手 Demo 给的第一感觉就是构件速度稍快些。</p></li></ul><p>以上这些<strong>纯属个人感受</strong>。但不管怎么样，至少是被社区认可的（比如：Vue 就是用 Rollup）</p><h2 id="上手-Demo"><a href="#上手-Demo" class="headerlink" title="上手 Demo"></a>上手 Demo</h2><ol><li><p>安装 rollup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollup -g</span><br></pre></td></tr></table></figure></li><li><p>新建 rollup.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  input: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    file: <span class="string">'./packages/bundle.js'</span>,</span><br><span class="line">    format: <span class="string">'cjs'</span>,</span><br><span class="line">    name: <span class="string">'test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  package.json</span><br><span class="line">│  test.txt</span><br><span class="line">│</span><br><span class="line">├─packages</span><br><span class="line">│      bundle.js</span><br><span class="line">│</span><br><span class="line">├─script</span><br><span class="line">│      rollup.config.js</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">        foo.js</span><br><span class="line">        main.js</span><br></pre></td></tr></table></figure><p>foo.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;foo init&#39;);</span><br><span class="line">class Foo &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name &#x3D; &#39;foo&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    say() &#123;</span><br><span class="line">        console.log(&#39;say...&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Foo;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import Foo from &quot;.&#x2F;foo&quot;;</span><br><span class="line"></span><br><span class="line">export default function() &#123;</span><br><span class="line">    console.log(&#39;load&#39;);</span><br><span class="line">    console.log(new Foo().say());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c .&#x2F;script&#x2F;rollup.config.js --environment TARGET:dev</span><br></pre></td></tr></table></figure><p>bundle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo init'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'foo'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'say...'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'load'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> Foo().say());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = main;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="配置介绍"><a href="#配置介绍" class="headerlink" title="配置介绍"></a>配置介绍</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>-c,–config</td><td>定义配置文件</td></tr><tr><td>-o, –file</td><td>定义输出位置文件</td></tr><tr><td>-n, –name</td><td>在 umd 模式下，定义模块名称</td></tr><tr><td>–environment \<a href="xx:value\">xx:value\</a></td><td>设置环境变量，会同步到 <strong>process.env.xx 中</strong></td></tr></tbody></table><p><a href="更多详见:https://rollupjs.org/guide/en#command-line-flags">更多详见:https://rollupjs.org/guide/en#command-line-flags</a>，建议不要看中文版本，有些配置会省略。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rollup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 数据类型说明</title>
      <link href="/legacy/2018/12/03/redis-datatype/"/>
      <url>/legacy/2018/12/03/redis-datatype/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文参考：<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="noopener">redis 数据类型 https://redis.io/topics/data-types-intro</a></p></blockquote><p>redis 不是简单的键值对存储容器，它是一个具有数据结构的服务，支持不同数据类型：</p><ul><li>String 字符串</li><li>Lists 列表</li><li>Sets 唯一、无序的元素集合</li><li>Sorted sets 和 Sets 类似，但每个元素具有一个 Score 标识分数，通过分数的高低来排序整个集合</li><li>Hashes 具有 map 类型，存储 key-value</li><li>Bit arrays(bitmaps)</li><li>HyperLogLogs</li></ul><h2 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h2><p>最简单的数据类型，比如：用于缓存 html 模板或页面。</p><p>value 可以保存二进制文件，比如图片资源，但有最大限制（512 MB）</p><h3 id="简单-set-get-示例："><a href="#简单-set-get-示例：" class="headerlink" title="简单 set/get 示例："></a>简单 <strong>set/get</strong> 示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;set test:string abcd</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;get test:string</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure><h3 id="set-可以设置-optios，完成一些特殊需求"><a href="#set-可以设置-optios，完成一些特殊需求" class="headerlink" title="set 可以设置 optios，完成一些特殊需求"></a>set 可以设置 optios，完成一些特殊需求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value options</span><br></pre></td></tr></table></figure><ul><li>EX seconds – Set the specified expire time, in seconds.</li><li>PX milliseconds – Set the specified expire time, in milliseconds.</li><li>NX – Only set the key if it does not already exist.</li><li>XX – Only set the key if it already exist.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置失效时间3s，到期自动删除</span><br><span class="line">192.168.1.60:0&gt;set test:string abcd ex 3</span><br><span class="line">OK</span><br><span class="line"># key已存在，失败</span><br><span class="line">192.168.1.60:0&gt;set test:string abcd nx</span><br><span class="line">NULL</span><br><span class="line"></span><br><span class="line"># key不存在，失败</span><br><span class="line">192.168.1.60:0&gt;set test:string2 abcd xx</span><br><span class="line">NULL</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;set test:string abcd xx</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="incr-累加"><a href="#incr-累加" class="headerlink" title="incr 累加"></a>incr 累加</h3><blockquote><p>That even multiple clients issuing INCR against the same key will never enter into a race condition</p></blockquote><p>这类操作符具有原子性，多个客户端并发请求并不会造成同样的 result</p><p>除了 <strong>INCR</strong> 相同的操作还有：<strong>INCRBY、DECR、DECRBY</strong></p><p>备注：如果 key 为非数字，则会默认从 1 开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;set test:string 10</span><br><span class="line">OK</span><br><span class="line"># 每次+1</span><br><span class="line">192.168.1.60:0&gt;incr test:string</span><br><span class="line">11</span><br><span class="line"># 设置增量</span><br><span class="line">192.168.1.60:0&gt;incrby test:string 20</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="合并-merge-操作"><a href="#合并-merge-操作" class="headerlink" title="合并 merge 操作"></a>合并 merge 操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;mset test:string2 eee test:string3 fff</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;mget test:string2 test:string3</span><br><span class="line">1) eee</span><br><span class="line">2) fff</span><br></pre></td></tr></table></figure><h3 id="存在和删除"><a href="#存在和删除" class="headerlink" title="存在和删除"></a>存在和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;exists test:string3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;del test:string3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;del test:string3</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;exists test:string3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型 Type"></a>类型 Type</h3><p>查询 redis 的数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;type test:string</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h3 id="过期时间-Expires"><a href="#过期时间-Expires" class="headerlink" title="过期时间 Expires"></a>过期时间 Expires</h3><p>单位是秒，到期后删除 key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;expire test:string2 10</span><br><span class="line">1</span><br><span class="line">192.168.1.60:0&gt;get test:string2</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h2 id="Redis-Lists"><a href="#Redis-Lists" class="headerlink" title="Redis Lists"></a>Redis Lists</h2><p>redis lists 是链表数据结构，这意味着即使有个包含很多元素的 list，从表头 or 从表尾添加元素的耗时是一样的。</p><h3 id="rpush-amp-lpush"><a href="#rpush-amp-lpush" class="headerlink" title="rpush &amp; lpush"></a>rpush &amp; lpush</h3><ul><li>rpush 表尾添加元素</li><li>lpush 表头添加元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;rpush test:list a</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;rpush test:list b</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;lpush test:list c</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;lrange test:list 0 1</span><br><span class="line">1) c</span><br><span class="line">2) a</span><br></pre></td></tr></table></figure><h3 id="出栈-rpop-amp-lpop"><a href="#出栈-rpop-amp-lpop" class="headerlink" title="出栈 rpop &amp; lpop"></a>出栈 rpop &amp; lpop</h3><p>取元素，取完该 list 就为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;rpush test:list a b c</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;rpop test:list</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;lpop test:list</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;lpop test:list</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;lpop test:list</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><ul><li>用于社交圈中最新的信息</li><li>生产者和消费者</li></ul><h3 id="对-list-整体的操作"><a href="#对-list-整体的操作" class="headerlink" title="对 list 整体的操作"></a>对 list 整体的操作</h3><p><strong>ltrim</strong> 理解为裁剪列表，类似于 js slice</p><p><strong>llen</strong> 查询 list 长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;rpush test:list a b c d e</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"># test:list 最终为 b c</span><br><span class="line">192.168.1.60:0&gt;ltrim test:list 1 2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;llen test:list</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;exists test:list</span><br><span class="line">1</span><br><span class="line"># 删除 list</span><br><span class="line">192.168.1.60:0&gt;del test:list</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;exists test:list</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="Redis-Hashes"><a href="#Redis-Hashes" class="headerlink" title="Redis Hashes"></a>Redis Hashes</h2><p><strong>hmset</strong> 保存多个 key-value 键值对到对象中</p><p>区别 hset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;hmset user:1 name aaaa age 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;hget user:1 age</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"># 区别 hset</span><br><span class="line">192.168.1.60:0&gt;hset user:2 name bbbb age 20</span><br><span class="line">ERR wrong number of arguments for &#39;hset&#39; command</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;hset user:2 name bbbb</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;hget user:2 name</span><br><span class="line">bbbb</span><br></pre></td></tr></table></figure><h2 id="Redis-Sets"><a href="#Redis-Sets" class="headerlink" title="Redis Sets"></a>Redis Sets</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.60:0&gt;sadd test:set 1 2 3</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;smembers test:set</span><br><span class="line">1) 1</span><br><span class="line">2) 2</span><br><span class="line">3) 3</span><br><span class="line"># 元素不存在</span><br><span class="line">192.168.1.60:0&gt;sismember test:set 100</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;sismember test:set 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Redis-Sorted-sets"><a href="#Redis-Sorted-sets" class="headerlink" title="Redis Sorted sets"></a>Redis Sorted sets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置无序元素</span><br><span class="line">192.168.1.60:0&gt;zadd test:sset 20 a 30 b 2 c</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"># 从小到大，排序输出</span><br><span class="line">192.168.1.60:0&gt;zrange test:sset 0 -1</span><br><span class="line">1) c</span><br><span class="line">2) a</span><br><span class="line">3) b</span><br></pre></td></tr></table></figure><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>不是一种新的数据类型，归于 String type 中。但能创建 512mb 的空间，约 2^32 的 bits。<br>因为是二进制，value 只能设为 0、1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># setbit key space value</span><br><span class="line">192.168.1.60:0&gt;setbit test:space 20000 1</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;setbit test:space 20000 1</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;getbit test:space 20000</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">192.168.1.60:0&gt;getbit test:space 19999</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="HyperLogLogs"><a href="#HyperLogLogs" class="headerlink" title="HyperLogLogs"></a>HyperLogLogs</h2><blockquote><p>A HyperLogLog is a probabilistic data structure used in order to count unique things (technically this is referred to estimating the cardinality of a set). Usually counting unique items requires using an amount of memory proportional to the number of items you want to count, because you need to remember the elements you have already seen in the past in order to avoid counting them multiple times. However there is a set of algorithms that trade memory for precision: you end with an estimated measure with a standard error, which in the case of the Redis implementation is less than 1%. The magic of this algorithm is that you no longer need to use an amount of memory proportional to the number of items counted, and instead can use a constant amount of memory! 12k bytes in the worst case, or a lot less if your HyperLogLog (We’ll just call them HLL from now) has seen very few elements.</p></blockquote><p>HLLs 是一种统计学上的一种算法。通常储存元素和内存占用成正比，但通过 HLLs 可以最大 12k 来标识所要存储的所有数据。<strong>用精度换取内存空间</strong></p><p>可能不太会使用，暂不尝试</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-SSR 服务器渲染实践</title>
      <link href="/legacy/2018/11/25/vue-ssr-quickstart/"/>
      <url>/legacy/2018/11/25/vue-ssr-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="提前告知"><a href="#提前告知" class="headerlink" title="提前告知"></a>提前告知</h1><ul><li>参考 <a href="https://ssr.vuejs.org" target="_blank" rel="noopener"><strong>尤大的 SSR 指南</strong></a></li><li>本文 DEMO 已上传至 github，最好拉下来跑下效果，了解 SSR</li><li>因为 <strong>搞不定</strong> 对 SSR 还是心存疑虑，起码不会投入到实际运用</li></ul><h1 id="为什么要做-SSR——服务端渲染"><a href="#为什么要做-SSR——服务端渲染" class="headerlink" title="为什么要做 SSR——服务端渲染"></a>为什么要做 SSR——服务端渲染</h1><ul><li>为了 SEO，为了更好地给爬虫抓取页面信息。提升搜索引擎排名</li><li>优化页面渲染，节省资源损耗。尤其首屏展示</li><li>服务端控制必要的业务逻辑，解决信息屏蔽、安全等问题</li><li>生成静态网站…</li></ul><h1 id="怎么做——面临的问题"><a href="#怎么做——面临的问题" class="headerlink" title="怎么做——面临的问题"></a>怎么做——面临的问题</h1><ul><li>从前后端分离的技术变革又回到了后端渲染输出页面的模式</li><li>前端工作量增加，甚至变困难了</li><li>需要担心服务端的性能、健壮性问题</li><li>前后端怎么进行信息交互</li></ul><h1 id="一张图说明"><a href="#一张图说明" class="headerlink" title="一张图说明"></a>一张图说明</h1><img src="/legacy/2018/11/25/vue-ssr-quickstart/ssr.png" class="" title="来自官网，做了些标注"><p>这是 vue-ssr 的核心结构，从上图中我们能看到解决了上述考虑到的问题。</p><ul><li>不用担心工作量，配置 <strong>entry</strong> 定制前后端的差异，其他交给 <strong>webpack</strong> 打包输出</li><li>前后端的数据通过 <strong>vuex</strong> 的 store 进行管理，browser 解析 <strong>window.</strong>INITIAL_STATE<em>**</em> 拿到所需的一切</li><li>通过 <strong>vue-router</strong> 提前解析处理 <strong>async</strong> 的业务逻辑，render 页面准备输出到浏览器</li><li>如果觉得复杂有困难，除了看着 SSR 的上手文档，也能尝试官网推荐的 <a href="https://nuxtjs.org/" target="_blank" rel="noopener">https://nuxtjs.org/</a> 和 <a href="https://github.com/vuejs/vue-hackernews-2.0/" target="_blank" rel="noopener">https://github.com/vuejs/vue-hackernews-2.0/</a></li></ul><p>感谢尤大提供了健全的 SSR 方案，不过为了能更好的实现服务端渲染，还是建议从官方的 DEMO 开始。</p><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><p><a href="https://github.com/eminoda/vue-ssr" target="_blank" rel="noopener">https://github.com/eminoda/vue-ssr</a></p><ul><li>“抄”的 vue-ssr 的 demo，如果看文档有问题，可以参考下。</li><li>异步路由报错，没有解决。原因是 third build plugins 提供了 browser 的变量，不知道以后会不会修正。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 那些&quot;奇技淫巧&quot;</title>
      <link href="/legacy/2018/11/16/js-hack-skill/"/>
      <url>/legacy/2018/11/16/js-hack-skill/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些常用 JS 的操作，一方面弥补基础的不足，一方面提升使用技巧。</p></blockquote><h1 id="数组中取最大值"><a href="#数组中取最大值" class="headerlink" title="数组中取最大值"></a>数组中取最大值</h1><p>一个以逗号分隔的数据，预取数据中最大的数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; &quot;3,2,1,4,4,6&quot;;</span><br><span class="line">Math.max.apply(&#123;&#125;,data.split(&#39;,&#39;)); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><p>通常肯定会把类似数据转成 array，然后通过“那些算法”循环出最大值。<br>但此例设法通过现有 Math 库的 API 计算，然后很阴 B 的通过 apply 的 arg 的特征然 array 通过。</p><h1 id="保留小数位"><a href="#保留小数位" class="headerlink" title="保留小数位"></a>保留小数位</h1><p>Math 对象提供简单的数学计算，但对于保留小数做四舍五入等操作，却不行。我们可以通过如下方式，变相实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">round</span>(<span class="params">num, digit = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> unit = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> extend = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; digit; i++) &#123;</span><br><span class="line">    extend = extend * unit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(num * extend) / extend;</span><br><span class="line">&#125;</span><br><span class="line">round(<span class="number">1.12945</span>, <span class="number">2</span>); <span class="comment">//1.13</span></span><br></pre></td></tr></table></figure><p>相同 <strong>ceil，floor</strong> 也可以类似实现</p><h1 id="逗号操作符-Comma-Operator"><a href="#逗号操作符-Comma-Operator" class="headerlink" title="逗号操作符 Comma_Operator"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator" target="_blank" rel="noopener">逗号操作符 Comma_Operator</a></h1><p>再看 express-graphql 代码时，发现多次出现如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (0, _graphql.execute)(schema, documentAST, rootValue, context, variables, operationName);</span><br></pre></td></tr></table></figure><p>其实，平时我们多用这种形式，只是没有发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; 0,data2 &#x3D; 1; &#x2F;&#x2F; 当然这不是想说的重点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0, j &#x3D; 9; i &lt;&#x3D; 9; i++, j--)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面两例中只是说明平时的常用场景，但用途就一个 <strong>变量的赋值处理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myFunc () &#123;</span><br><span class="line">  var x &#x3D; 0;</span><br><span class="line">  return (x +&#x3D; 1, x); &#x2F;&#x2F; the same of return ++x;</span><br><span class="line">  &#x2F;&#x2F; 相当于</span><br><span class="line">  &#x2F;&#x2F; x &#x3D; x+1;</span><br><span class="line">  &#x2F;&#x2F; return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="void-0-和-undefined"><a href="#void-0-和-undefined" class="headerlink" title="void 0 和 undefined"></a>void 0 和 undefined</h1><p>一定会忽略的知识点，红宝书肯定有讲到。我问你，<strong>undefined 是 js 的保留关键字吗？</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Reserved_words" target="_blank" rel="noopener">有哪些 reserved—word?</a></p><p>所以在部分浏览器比如 IE，就会出现 undefined 被复写的可能，多人合作，鬼知道谁会有这样神奇的操作。</p><p>同样再抛个问题：<strong>void 是干什么的？</strong></p><blockquote><p>这个运算符能向期望一个表达式的值是 undefined 的地方插入会产生副作用的表达式。</p></blockquote><p>说白了就是用于定义 undefined，可以 void(0),void 0</p><p>这样一方面避免了使用 undefined，第二简化书写，代码变得更加语义好理解，提升了逼格</p><h1 id="对象属性的-merge，Object-assign"><a href="#对象属性的-merge，Object-assign" class="headerlink" title="对象属性的 merge，Object.assign()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">对象属性的 merge，Object.assign()</a></h1><blockquote><p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(target, ...sources)</span><br></pre></td></tr></table></figure><p>用于 copy 对象的 <strong>简单属性</strong>，如果已存在属性则会覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 =</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(obj, obj1);<span class="comment">// &#123; a: 2, b: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>注意：通常对于对象引用的 deep copy 不建议使用此方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">0</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1); <span class="comment">//merge 空对象&#123;&#125;和obj1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">obj1.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123; a: 1, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; a: 0, b: &#123; c: 0 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">obj1.b.c = <span class="number">3</span>; <span class="comment">//此处改变obj1引用，影响到obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123; a: 1, b: &#123; c: 3 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; a: 0, b: &#123; c: 3 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>其他</p><ul><li>原型链上的属性不会被 copy</li><li>非 enumerable 类型的属性不会被 copy</li><li>IE 需要注意兼容</li></ul><h1 id="除了-apply、call，bind-某些地方更适合"><a href="#除了-apply、call，bind-某些地方更适合" class="headerlink" title="除了 apply、call，bind 某些地方更适合"></a>除了 apply、call，bind 某些地方更适合</h1><blockquote><p>创建一个新的函数， 当这个新函数被调用时其 this 置为提供的值，其参数列表前几项置为创建时指定的参数序列。</p></blockquote><p>参考 <strong>koa-compose</strong> 一段核心代码，中间用到了 <strong>bind</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function compose (middleware) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return function (context, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; last called middleware #</span><br><span class="line">    let index &#x3D; -1</span><br><span class="line">    return dispatch(0)</span><br><span class="line">    function dispatch (i) &#123;</span><br><span class="line">      if (i &lt;&#x3D; index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))</span><br><span class="line">      index &#x3D; i</span><br><span class="line">      let fn &#x3D; middleware[i]</span><br><span class="line">      if (i &#x3D;&#x3D;&#x3D; middleware.length) fn &#x3D; next</span><br><span class="line">      if (!fn) return Promise.resolve()</span><br><span class="line">      try &#123;</span><br><span class="line">        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        return Promise.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其作用在看了几个示例便可明白。</p><ol><li>改变作用域<br>类似你可以用在 jquery 的事件、setTimeout 来“修正”作用域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;global&#39;;</span><br><span class="line">var User &#x3D; function() &#123;</span><br><span class="line">    this.name &#x3D; &#39;aaaa&#39;;</span><br><span class="line">    this.age &#x3D; 11;</span><br><span class="line">    this.getName &#x3D; function() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var user &#x3D; new User();</span><br><span class="line">console.log(user.getName()); &#x2F;&#x2F;aaaa</span><br><span class="line">&#x2F;&#x2F; 应该拿user这个对象引用来做后续的方法调用，而非把方法拿出来。</span><br><span class="line">var userGetName &#x3D; user.getName;</span><br><span class="line">console.log(userGetName()); &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">var userGetName2 &#x3D; userGetName.bind(user);</span><br><span class="line">console.log(userGetName2()); &#x2F;&#x2F;aaaa</span><br></pre></td></tr></table></figure><ol start="2"><li>偏函数<blockquote><p>使一个函数拥有预设的初始参数。这些参数（如果有的话）作为 bind()的第二个参数跟在 this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function argumentsChangeArray() &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过call，调用array的slice，进行copy</span><br><span class="line">    return Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(argumentsChangeArray(1, 2, 3)); &#x2F;&#x2F;[1,2,3]</span><br><span class="line"></span><br><span class="line">var createNewList &#x3D; argumentsChangeArray.bind(null, 1, 2, 3)</span><br><span class="line"></span><br><span class="line">console.log(createNewList(4, 5)); &#x2F;&#x2F;[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure><h1 id="巧用-reduce-做对象转化"><a href="#巧用-reduce-做对象转化" class="headerlink" title="巧用 reduce 做对象转化"></a>巧用 reduce 做对象转化</h1><p>看一端 <strong>egg-core</strong> 的源码，大致作用参考下注释（将 controller、service 等文件，通过文件读取全部读到内存，然后调用 load 将这些属性同步到 FileLoader 的属性上）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item &#123; properties: [ 'a', 'b', 'c'], exports &#125;</span></span><br><span class="line"><span class="comment">// =&gt; target.a.b.c = exports</span></span><br><span class="line">item.properties.reduce(<span class="function">(<span class="params">target, property, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj;</span><br><span class="line">  <span class="keyword">const</span> properties = item.properties.slice(<span class="number">0</span>, index + <span class="number">1</span>).join(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (index === item.properties.length - <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    obj = item.exports;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; !is.primitive(obj)) &#123;</span><br><span class="line">      obj[FULLPATH] = item.fullpath;</span><br><span class="line">      obj[EXPORTS] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj = target[property] || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  target[property] = obj;</span><br><span class="line">  debug(<span class="string">'loaded %s'</span>, properties);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;, target);</span><br></pre></td></tr></table></figure><p>简单看下语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure><p>callback</p><ul><li>accumulator: 累计器，return 上一次结果</li><li>currentValue：当前处理值</li><li>currentIndex：当前处理的索引</li><li>array：正在调用的数据</li></ul><p>initialValue：初始值，默认为 arr 的第一位元素</p><ol><li>简单使用，累加功能</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123;index&#125;</span>调用---`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`accumulator:<span class="subst">$&#123;accumulator&#125;</span>,currentValue:<span class="subst">$&#123;currentValue&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer)); <span class="comment">//10</span></span><br><span class="line"><span class="comment">// 第1调用---</span></span><br><span class="line"><span class="comment">// accumulator:1,currentValue:2</span></span><br><span class="line"><span class="comment">// 第2调用---</span></span><br><span class="line"><span class="comment">// accumulator:3,currentValue:3</span></span><br><span class="line"><span class="comment">// 第3调用---</span></span><br><span class="line"><span class="comment">// accumulator:6,currentValue:4</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数组去重</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];</span><br><span class="line">let result &#x3D; arr.sort().reduce((init, current) &#x3D;&gt; &#123;</span><br><span class="line">    if (init.length &#x3D;&#x3D;&#x3D; 0 || init[init.length - 1] !&#x3D;&#x3D; current) &#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); &#x2F;&#x2F;[1,2,3,4,5]</span><br></pre></td></tr></table></figure><ol start="3"><li>其他业务的使用（对象加工处理、二维转一维、Prmoise 加工、pipe…）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var global &#x3D; &#123;&#125;</span><br><span class="line">var properties &#x3D; [&#39;getName&#39;, &#39;getAge&#39;, &#39;getSex&#39;]</span><br><span class="line">var exports &#x3D; [() &#x3D;&gt; &#39;name&#39;, () &#x3D;&gt; &#39;age&#39;, () &#x3D;&gt; &#39;sex&#39;]</span><br><span class="line"></span><br><span class="line">properties.reduce((target, curr, index) &#x3D;&gt; &#123;</span><br><span class="line">    target[curr] &#x3D; exports[index];</span><br><span class="line">    return target;</span><br><span class="line">&#125;, global)</span><br><span class="line"></span><br><span class="line">console.log(global.getAge()); &#x2F;&#x2F;age</span><br></pre></td></tr></table></figure><h1 id="变量级别-cache-缓存策略"><a href="#变量级别-cache-缓存策略" class="headerlink" title="变量级别 cache 缓存策略"></a>变量级别 cache 缓存策略</h1><p>摘自 vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存策略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cached</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hit = cache[str];</span><br><span class="line">    <span class="keyword">if</span> (hit) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'got hit'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中是否命中，未缓存则根据 fn 创建缓存方法</span></span><br><span class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line"><span class="keyword">let</span> camelize = cached(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : <span class="string">''</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">camelize(<span class="string">'abc-abc'</span>); <span class="comment">//"abcAbc"</span></span><br><span class="line">camelize(<span class="string">'abc-abc'</span>); <span class="comment">// got hit "abcAbc"</span></span><br></pre></td></tr></table></figure><p>通过 <strong>高阶函数</strong> 封装 cached 缓存策略，后续只要向 cached 丢入需求方法，就能根据缓存的结果集中快速取得结果。</p><h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference" target="_blank" rel="noopener">mozilla</a></li><li><a href="https://www.jianshu.com/p/cd188bda72df" target="_blank" rel="noopener">逗号操作符 &amp; (0, function)()</a></li><li><a href="https://github.com/hanzichi/underscore-analysis/issues/1" target="_blank" rel="noopener">void 0 &amp; undefined</a></li><li><a href="http://web.jobbole.com/83642/" target="_blank" rel="noopener">apply call bind</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript 专题之偏函数</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初涉 nginx 高可用</title>
      <link href="/legacy/2018/11/16/nginx-high-availability/"/>
      <url>/legacy/2018/11/16/nginx-high-availability/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a><a href="https://zh.wikipedia.org/zh-hans/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" target="_blank" rel="noopener">什么是高可用</a></h1><blockquote><p>高可用性（英语：high availability，缩写为 HA），IT 术语，指系统无中断地执行其功能的能力，代表系统的可用性程度。是进行系统设计时的准则之一。高可用性系统与构成该系统的各个组件相比可以更长时间运行</p></blockquote><p>衡量指标：A（可用性）=MTBF/(MTBF+MTTR)</p><ul><li>MTBF(Mean Time Between Failure 平均故障间隔)</li><li>MTTR(Mean Time to Restoration 平均恢复时间)</li></ul><p><strong>最佳实践</strong></p><ul><li>消除单点故障，不会因为单点问题，导致整个系统链的故障</li><li>加强节点健壮性，同样避免单点故障问题</li><li>实时监测系统异常情况，有问题及时“处理”</li></ul><h1 id="nginx-keepalived-高可用"><a href="#nginx-keepalived-高可用" class="headerlink" title="nginx+keepalived 高可用"></a>nginx+keepalived 高可用</h1><h2 id="负载均衡-upstream"><a href="#负载均衡-upstream" class="headerlink" title="负载均衡 upstream"></a><a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">负载均衡 upstream</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream expressServer &#123;</span><br><span class="line">    server 127.0.0.1:6601;</span><br><span class="line">    server 127.0.0.1:6602;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen          66;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;expressServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：192.168.1.65:66，nginx 自动分配规则自动分配到对应服务地址（6601,6602）</p><p><strong>更多参数</strong><br>| 配置 | 作用 |<br>| — | — |<br>| weight=number | 权重 |<br>| max_conns=number | 最大连接数，默认 0 不限制 |<br>| max_fails=number | 监控链接健康状况，默认 1 |<br>| fail_timeout=time | 超时时间，默认 10sed，服务器 disconnect、超时都会造成不可用 |<br>| backup | “备胎“ |<br>| down | 取消 |</p><h2 id="健康检查-healthcheck"><a href="#健康检查-healthcheck" class="headerlink" title="健康检查 healthcheck"></a>健康检查 healthcheck</h2><p>nginx 提供健康检查模块 <strong>ngx_http_upstream_hc_module</strong>，但是看到下面那句话只能绕道了：</p><blockquote><p>This module is available as part of our commercial subscription.</p></blockquote><h2 id="keepalived"><a href="#keepalived" class="headerlink" title="keepalived"></a>keepalived</h2><p>市面上有很多可选方案，只是 keepalived 文档多，选择了解一番。以下配置停留在 helloworld 程度，更多功能参阅官网了解。</p><ol><li><p>环境配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br><span class="line">service keepalived start</span><br></pre></td></tr></table></figure><p>日志文件位置（默认）:/var/log/messages</p></li><li><p>配置文件</p><p>master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">    245978782@qq.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from 245978782@qq.com</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30</span><br><span class="line">router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER    # 注意配置</span><br><span class="line">    interface eth5  # 注意配置</span><br><span class="line">    mcast_src_ip 192.168.1.65   # 注意配置</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 101    # 注意配置</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.213</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">    245978782@qq.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from 245978782@qq.com</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30</span><br><span class="line">router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP    # 注意配置</span><br><span class="line">    interface eth1  # 注意配置</span><br><span class="line">    mcast_src_ip 192.168.1.74   # 注意配置</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100    # 注意配置</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">    192.168.1.213</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>场景测试</p><p><strong>手动关闭 master keepalived</strong></p><p>主服务 keepalived 关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service keepalived stop</span><br></pre></td></tr></table></figure><p>MASTER log：vip 实例被移除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nov 14 15:52:28 localhost Keepalived[56457]: Stopping Keepalived v1.2.13 (03&#x2F;19,2015)</span><br><span class="line">Nov 14 15:52:28 localhost Keepalived_vrrp[56459]: VRRP_Instance(VI_1) sending 0 priority</span><br><span class="line">Nov 14 15:52:28 localhost Keepalived_vrrp[56459]: VRRP_Instance(VI_1) removing protocol VIPs.</span><br></pre></td></tr></table></figure><p>BACKUP log：从服务被 vip 绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Nov 14 15:52:31 station74 Keepalived_vrrp[59094]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Nov 14 15:52:32 station74 Keepalived_vrrp[59094]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line">Nov 14 15:52:32 station74 Keepalived_vrrp[59094]: VRRP_Instance(VI_1) setting protocol VIPs.</span><br><span class="line">Nov 14 15:52:32 station74 Keepalived_vrrp[59094]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth1 for 192.168.1.213</span><br><span class="line">Nov 14 15:52:32 station74 Keepalived_healthcheckers[59093]: Netlink reflector reports IP 192.168.1.213 added</span><br><span class="line">Nov 14 15:52:37 station74 Keepalived_vrrp[59094]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth1 for 192.168.1.213</span><br></pre></td></tr></table></figure><p><strong>应用宕机（nginx、tomcat、node…），自动切换</strong></p><p>不同应用只是针对不同的 sh 脚本处理不同，原理类似。下面给出 nginx 判断（百度上基本都类似，再根据自己逻辑改吧改吧就行了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">status&#x3D;100 # 测试，为了让if条件能够命中</span><br><span class="line">count&#x3D;$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">if [ &quot;$count&quot; -lt &quot;$status&quot; ]</span><br><span class="line">then</span><br><span class="line">    sleep 2</span><br><span class="line">    service keepalived stop # 关闭keepalived</span><br><span class="line">else</span><br><span class="line">    echo &quot;nginx is started&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>keepalived.conf 主从都需要修改，监听脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;mydata&#x2F;FE_shell&#x2F;check.sh&quot;</span><br><span class="line">    interval 1       # check every second</span><br><span class="line">    weight -2        # default prio: -2 if connect fails</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 脚本追踪</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_http_port weight 2    # +2 if process is present</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：keepalive 轮询查询脚本，当服务“异常”，自动关闭 keepalived，ip 漂移到从服务。在脚本上可以继续加工复杂化，循环监听应用状态，再重启 keepalived。</p></li></ol><h2 id="最后（很重要）"><a href="#最后（很重要）" class="headerlink" title="最后（很重要）"></a>最后（很重要）</h2><p>阿里云<strong>ecs 不支持 Keepalived 的虚拟漂移 IP，除了 slb 还没有额外的服务来配置</strong></p><p>备注：2018-11-14 提的工单，不知道日后会不会有这项服务/功能</p><p>你上面看到的配置，若不是自己建服，用的阿里云估计要歇菜了。如果有什么其他方式能实现，欢迎留言讨论。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://aokunsang.iteye.com/blog/2053719" target="_blank" rel="noopener">web 应用的负载均衡、集群、高可用(HA)解决方案——了解基础知识</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7" target="_blank" rel="noopener">高可用-HA</a></li><li><a href="https://blog.csdn.net/e421083458/article/details/30092795" target="_blank" rel="noopener">keepalived+nginx 高可用</a></li><li><a href="http://www.keepalived.org/manpage.html" target="_blank" rel="noopener">http://www.keepalived.org/manpage.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache ab 工具如何发送 post 请求</title>
      <link href="/legacy/2018/11/16/ab-test-post/"/>
      <url>/legacy/2018/11/16/ab-test-post/</url>
      
        <content type="html"><![CDATA[<p>主要记录下 post 方式，ab 基础入门请点击查看如下文章的底部备注：</p><p><a href="https://eminoda.github.io/2018/11/08/pressure-test-node-java/" target="_blank" rel="noopener">https://eminoda.github.io/2018/11/08/pressure-test-node-java/</a></p><p><strong>起因</strong>：用 ab 压了网站页面，我们一致认为瓶颈是在 foo 后端服务，但他们又需要我们单压他们接口，ok 没问题（省去十万字解释），但他们的开发又不熟悉 ab 不能提供给运维，最后只能我们前端测下 foo 后端服务。</p><blockquote><p>没办法，目前虽然公司的前端处于食物链底部，但是每个前端都是具备全栈能力的，学习力太强大</p></blockquote><p>不扯皮，开始吧：</p><ol><li><p>某后端服务接口的特性</p><ul><li>request header ： application/json</li><li>request method ： post</li></ul></li><li><p>准备 node 服务</p><ul><li>用 <strong>koa-bodyparser</strong> 做请求 data 的解析</li><li>用 <strong>koa-router</strong> 做接口接入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.post(&#39;&#x2F;api&#x2F;test&#39;, async function(ctx, next) &#123;</span><br><span class="line">    console.log(ctx.request.body);</span><br><span class="line">    console.log(ctx.method);</span><br><span class="line">    console.log(ctx.headers);</span><br><span class="line">    ctx.body &#x3D; &#123;</span><br><span class="line">        param: ctx.request.body</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试 ab 脚本</p><p>这里只是简单测试 json 格式的 post 请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ab -n 1 -c 1  -T application&#x2F;json -p 1.json  &quot;http:&#x2F;&#x2F;127.0.0.1:3301&#x2F;anal&#x2F;api&#x2F;test&quot;</span><br></pre></td></tr></table></figure><p>要注意如下几点：</p><ul><li><strong>-p</strong> 定义 post 方法需要传输的 file</li><li>file 默认是寻找 <strong>/root</strong> 路径下目标文件，可以通过 tab 确认</li><li>file 可能需要注意换行符等问题（目前我这边没有问题）</li><li><strong>-T</strong> 是和-p 搭配使用，指定 header</li></ul><p>file（1.json）: 后缀任意，格式需要 json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;channelId&quot;:xx&#125;</span><br></pre></td></tr></table></figure><p>结果：node 成功接收到 ab 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- POST &#x2F;anal&#x2F;api&#x2F;test</span><br><span class="line">    &#123; channelId: xx &#125;</span><br><span class="line">    POST</span><br><span class="line">    &#123; &#39;content-length&#39;: &#39;18&#39;,</span><br><span class="line">        &#39;content-type&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">        host: &#39;127.0.0.1:3301&#39;,</span><br><span class="line">        &#39;user-agent&#39;: &#39;ApacheBench&#x2F;2.3&#39;,</span><br><span class="line">        accept: &#39;*&#x2F;*&#39; &#125;</span><br><span class="line">POST &#x2F;anal&#x2F;api&#x2F;test - 5ms</span><br><span class="line">--&gt; POST &#x2F;anal&#x2F;api&#x2F;test 200 10ms 27b</span><br></pre></td></tr></table></figure></li><li><p>切换到目标 foo 服务</p><p>失败，问题丢到 foo 团队处理，鬼知道他们服务有什么“鸟蛋设定”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ab -n 1 -c 1  -T application&#x2F;json -p 1.json  &quot;http:&#x2F;&#x2F;xxx&quot;</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class="line">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class="line"></span><br><span class="line">Benchmarking cms.niu100.com (be patient)...apr_poll: The timeout specified has expired (70007)</span><br></pre></td></tr></table></figure></li></ol><p>写在最后，虽然还是要和他们后端服务做对接，了解有什么深坑在里面。但站在一个前端开发角度，又离那个“顶峰”进了一步</p><p>参考：</p><ul><li><a href="https://www.tanglei.name/blog/Apache-benchmarking-usage.html" target="_blank" rel="noopener">https://www.tanglei.name/blog/Apache-benchmarking-usage.html</a></li><li><a href="https://www.jianshu.com/p/66ad2f9570f8" target="_blank" rel="noopener">https://www.jianshu.com/p/66ad2f9570f8</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> ab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 和 java 性能对比</title>
      <link href="/legacy/2018/11/08/pressure-test-node-java/"/>
      <url>/legacy/2018/11/08/pressure-test-node-java/</url>
      
        <content type="html"><![CDATA[<h1 id="背景引出"><a href="#背景引出" class="headerlink" title="背景引出"></a>背景引出</h1><p>线上网站遭受攻击，首页被强刷，导致服务器 node 性能过载，影响用户正常页面访问。</p><p>大致架构：客户端发起请求 –&gt; node（充当中间件，访问后端 API 渲染页面） –&gt; java（处理业务逻辑）–&gt; database</p><h1 id="现象-amp-问题"><a href="#现象-amp-问题" class="headerlink" title="现象&amp;问题"></a>现象&amp;问题</h1><table><thead><tr><th>现象</th><th>疑惑</th></tr></thead><tbody><tr><td>Nodejs cup 满负载</td><td>与 Nodejs 高性能不符？</td></tr><tr><td>后端 Java 的负载和 Node 相反</td><td>怎么性能优于 Nodejs？</td></tr></tbody></table><h1 id="node-和-java-来个简单测试（偏娱乐向）"><a href="#node-和-java-来个简单测试（偏娱乐向）" class="headerlink" title="node 和 java 来个简单测试（偏娱乐向）"></a>node 和 java 来个简单测试（偏娱乐向）</h1><h2 id="前期测试准备"><a href="#前期测试准备" class="headerlink" title="前期测试准备"></a>前期测试准备</h2><p>分别用以下方式模拟一个线上获取用户信息的接口：</p><ol><li>node 直连 mysql</li><li>node 调用 java 接口来获取数据。</li></ol><p>框架：koa+koa-router+sequelize+request+pm2</p><p>备注：由于不太清楚后端业务数据取值逻辑，尽可能还原 response data，会存在一定的数据包偏差。</p><p><strong>简要代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.all(<span class="string">'/api/java'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uid = ctx.cookies.get(<span class="string">'uid'</span>);</span><br><span class="line">  <span class="comment">// request代理给后端java API接口</span></span><br><span class="line">  ctx.body = <span class="keyword">await</span> <span class="keyword">new</span> Http(&#123; ctx &#125;).request(&#123;</span><br><span class="line">    url: <span class="string">'/user/getbalance'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.all(<span class="string">'/api/node'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uid = ctx.cookies.get(<span class="string">'uid'</span>);</span><br><span class="line">  <span class="comment">// 通过sequelize从mysql查询</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([user.balance(uid), user.integral(uid), user.coupon(uid), user.memberProp(uid)]);</span><br><span class="line">  ctx.body = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="分组测试-amp-结论"><a href="#分组测试-amp-结论" class="headerlink" title="分组测试&amp;结论"></a>分组测试&amp;结论</h2><p>在测试环境，直接局域网 ab 测试，避免网络 io 损耗。<br>测试不同并发条件（100-&gt;200-&gt;500-&gt;1k-&gt;2k），1w 请求总耗时；<strong>同时 node 增加核数（1 核-&gt;2 核-&gt;4 核-&gt;8 核）</strong></p><h3 id="Java-测试（node-代理给-java）"><a href="#Java-测试（node-代理给-java）" class="headerlink" title="Java 测试（node 代理给 java）"></a>Java 测试（node 代理给 java）</h3><p>再次备注：通过 node 访问 java 接口。（要模拟线上环境，会因为 node 的瓶颈造成 java 负载过低）。</p><img src="/legacy/2018/11/08/pressure-test-node-java/java.png" class="" title="图1（红 深蓝 浅蓝 橘色代表cpu核数）"><h3 id="Node-测试"><a href="#Node-测试" class="headerlink" title="Node 测试"></a>Node 测试</h3><p>node 直连数据库<br><img src="/legacy/2018/11/08/pressure-test-node-java/node.png" class="" title="图2（红 深蓝 浅蓝 橘色代表cpu核数）"></p><h3 id="Java-amp-node"><a href="#Java-amp-node" class="headerlink" title="Java&amp;node"></a>Java&amp;node</h3><p>直接访问 java 接口，硬碰硬<br><img src="/legacy/2018/11/08/pressure-test-node-java/java_node.png" class="" title="图3"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>node 的强项处理非阻塞异步 IO，但由于是单进程，虽然请求数量增加 ↑，实际到达 java 应用的请求被限制在一个峰值 max，解释了<strong>图 1 红柱：当 cpu1 核时，并发数增多，耗时不变</strong></li><li>知道了 node cpu 瓶颈的原因，通过<strong>pm2</strong>增加核数，让 java 得到更多的资源去处理。<strong>图 1 深蓝浅蓝：cpu 核数增加，耗时缩短</strong></li><li>当 cpu 升值 8 核（测试环境满核），node 基本不会 hold 住任何请求（top 小于 50%），直接丢到 java 端，到达 java 请求数倍增，但由于 java 语言特点（同步阻塞式）、外界因素（测试环境复杂），相反时间没有得到下降而是有上升趋势。<strong>图 1 橘色：有上升趋势</strong></li><li>依托于多核的性能，node 充分利用硬件资源，核数增加 ↑，执行能力正比例上升 ↑。<strong>图 2：耗时随 cpu 核数增加，而倍减</strong></li><li><strong>结合图 1，图 2：</strong>打开 cpu 限制后，不难发现 node 性能迅速上升，符合<strong>外界宣传</strong>，（注：使用了 Promise.all 更加快了异步处理速度）</li><li><strong>图 3：node 性能好于 java</strong>，但并发 2k 时，两者还是不分上下，还是要分不同场景对 2 者有个组合使用（注：因为数据库等原因，java 在处理业务时，会大批出现 jdbc 等问题）</li></ol><h1 id="apach-ab"><a href="#apach-ab" class="headerlink" title="apach ab"></a>apach ab</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><a href="https://httpd.apache.org/docs/2.4/programs/ab.html" target="_blank" rel="noopener">apache ab</a></p><p>运行脚本:ab + 请求数量 + 并发数量 + 测试地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost pressure_analysis]# ab -n 10000 -c 1000 http:&#x2F;&#x2F;127.0.0.1:3301&#x2F;anal&#x2F;api&#x2F;java</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>指标</th><th>数值</th><th>说明</th></tr></thead><tbody><tr><td>Concurrency Level</td><td>1000</td><td>并发数量</td></tr><tr><td>Complete requests</td><td>10000</td><td>全部完成的请求数量</td></tr><tr><td>Time taken for tests</td><td>7.907 seconds</td><td>运行测试脚本总用时</td></tr><tr><td>Total transferred</td><td>2880000 bytes</td><td>数据包大小</td></tr><tr><td>Requests per second</td><td>1264.76 <a href="mean">#/sec</a></td><td>平均每秒请求数量（Complete requests/Time taken for tests）</td></tr><tr><td>Time per request</td><td>790.661 <a href="mean">ms</a></td><td>单个请求平均耗时（Concurrency Level*Time taken for tests）</td></tr><tr><td>Transfer rate</td><td>355.71 [Kbytes/sec] received</td><td>数据包传输速率</td></tr></tbody></table><h2 id="ab-工具使用到的一些问题"><a href="#ab-工具使用到的一些问题" class="headerlink" title="ab 工具使用到的一些问题"></a>ab 工具使用到的一些问题</h2><h3 id="apr-socket-recv-Connection-reset-by-peer-104"><a href="#apr-socket-recv-Connection-reset-by-peer-104" class="headerlink" title="apr_socket_recv: Connection reset by peer (104)"></a>apr_socket_recv: Connection reset by peer (104)</h3><blockquote><p>sysctl 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录/proc/sys 中。它包含一些 TCP/ip 堆栈和虚拟内存系统的高级选项， 这可以让有经验的管理员提高引人注目的系统性能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost pressure_analysis]# vim &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 0</span><br><span class="line"></span><br><span class="line">[root@localhost pressure_analysis]# sysctl -p</span><br></pre></td></tr></table></figure><h3 id="socket-Too-many-open-files-24"><a href="#socket-Too-many-open-files-24" class="headerlink" title="socket: Too many open files (24)"></a>socket: Too many open files (24)</h3><blockquote><p>ulimit 用来限制系统用户对 shell 资源的访问</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 注意到open files限制1024</span><br><span class="line">[root@localhost pressure_analysis]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 257702</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 10240</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 257702</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line"># 修改配置</span><br><span class="line">[root@localhost pressure_analysis]# ulimit  -n 5000</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">linux 命令</a></li><li><a href="https://www.cnblogs.com/felixzh/p/8295471.html" target="_blank" rel="noopener">sysctl</a></li><li><a href="https://blog.csdn.net/hexuan1/article/details/45191549" target="_blank" rel="noopener">ulimit</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> ab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 中使用 sass-loader 如何正确加载 font 字体</title>
      <link href="/legacy/2018/10/29/webpack-require-font/"/>
      <url>/legacy/2018/10/29/webpack-require-font/</url>
      
        <content type="html"><![CDATA[<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>使用 webpack 通常会用到 sass-loader，当然这不是重点。问题是引用 font 字体文件时会出现如下错误：</p><img src="/legacy/2018/10/29/webpack-require-font/1.png" class=""><p>再看看目录结构和引用方式：</p><img src="/legacy/2018/10/29/webpack-require-font/2.png" class=""><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;font-family: <span class="string">"iconfont"</span>;</span><br><span class="line">    src: url(<span class="string">'../../assets/fonts/iconfont.eot?t=1540697325659'</span>); <span class="comment">/* IE9*/</span></span><br><span class="line">    src: url(<span class="string">'../../assets/fonts/iconfont.eot?t=1540697325659#iefix'</span>) format(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">    url(<span class="string">'../../assets/fonts/iconfont.woff?t=1540697325659'</span>) format(<span class="string">'woff'</span>),</span><br><span class="line">    url(<span class="string">'../../assets/fonts/iconfont.ttf?t=1540697325659'</span>) format(<span class="string">'truetype'</span>), <span class="comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+*/</span></span><br><span class="line">    url(<span class="string">'../../assets/fonts/iconfont.svg?t=1540697325659#iconfont'</span>) format(<span class="string">'svg'</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而然文件引用层级和目录的结构又是正确的，为什么加载字体文件的时候会出问题？</p><h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p><a href="https://github.com/webpack-contrib/sass-loader#problems-with-url" target="_blank" rel="noopener">https://github.com/webpack-contrib/sass-loader#problems-with-url</a></p><img src="/legacy/2018/10/29/webpack-require-font/3.png" class=""><p>简单讲就是 sass-loader 这个加载器没有提供 url 重写的功能，所以导致即使你文件路径是“正确的”，其实还是引用不到。<br>再画个重点：其实通过 background 之类用到 url，还是加载不到资源的，只是我们可能通常会把 font 文件通过抽取到公共目录下，导致 url rewriting 的问题会被暴露出来。</p><p>拿 background 举 2 个例子：</p><p>index.scss //没有报错。引用和资源路径对象，其实只是误打误撞而已</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;.&#x2F;common&#x2F;testSass.scss&quot;;</span><br><span class="line">.image&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border:1px solid green;</span><br><span class="line">    background: url(&#39;..&#x2F;assets&#x2F;images&#x2F;logo.png&#39;) 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>testSass.scss //报错。看似引用正确，其实和 font 的问题一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.image&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border:1px solid green;</span><br><span class="line">    background: url(&#39;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;logo.png&#39;) 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>理解上面问题出现的原因，给出“可以”解决问题的方法：<strong>把../../ 改成 ../</strong></p><p>testSass.scss // success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.image&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border:1px solid green;</span><br><span class="line">    background: url(&#39;..&#x2F;assets&#x2F;images&#x2F;logo.png&#39;) 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iconfont.scss // success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;font-family: &quot;iconfont&quot;;</span><br><span class="line">    src: url(&#39;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.eot?t&#x3D;1540697325659&#39;); &#x2F;* IE9*&#x2F;</span><br><span class="line">    src: url(&#39;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.eot?t&#x3D;1540697325659#iefix&#39;) format(&#39;embedded-opentype&#39;), &#x2F;* IE6-IE8 *&#x2F;</span><br><span class="line">    url(&#39;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.woff?t&#x3D;1540697325659&#39;) format(&#39;woff&#39;),</span><br><span class="line">    url(&#39;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.ttf?t&#x3D;1540697325659&#39;) format(&#39;truetype&#39;), &#x2F;* chrome, firefox, opera, Safari, Android, iOS 4.2+*&#x2F;</span><br><span class="line">    url(&#39;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.svg?t&#x3D;1540697325659#iconfont&#39;) format(&#39;svg&#39;); &#x2F;* iOS 4.1- *&#x2F;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为上面 出问题 的引用都是通过 css-loader ，所以根据上面的问题描述，得出：即使是子目录的文件还是根据入口文件来做引用(即 index.scss 的位置)。</p><p>官方其实给出了 2 个方案：</p><ul><li>Add the missing url rewriting using the resolve-url-loader. Place it before the sass-loader in the loader chain.</li><li>Library authors usually provide a variable to modify the asset path. bootstrap-sass for example has an \$icon-font-path. Check out this working bootstrap example.</li></ul><p>具体什么含义，可以参考 webpack 中文社区的解释。<a href="https://webpack.docschina.org/loaders/sass-loader/" target="_blank" rel="noopener">https://webpack.docschina.org/loaders/sass-loader/</a></p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>安装 <strong>relative-url-loader</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    fallback: &quot;style-loader&quot;,</span><br><span class="line">                    use: [&#39;css-loader&#39;, &#39;resolve-url-loader&#39;, &#39;sass-loader?sourceMap&#x3D;true&#39;]</span><br><span class="line">                    &#x2F;&#x2F; use: [&#39;css-loader&#39;, &#39;sass-loader&#39;]</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>sass 中的资源文件，按照“正确”的引用定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;font-family: &quot;iconfont&quot;;</span><br><span class="line">    src: url(&#39;..&#x2F;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.eot?t&#x3D;1540697325659&#39;); &#x2F;* IE9*&#x2F;</span><br><span class="line">    src: url(&#39;..&#x2F;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.eot?t&#x3D;1540697325659#iefix&#39;) format(&#39;embedded-opentype&#39;), &#x2F;* IE6-IE8 *&#x2F;</span><br><span class="line">    url(&#39;..&#x2F;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.woff?t&#x3D;1540697325659&#39;) format(&#39;woff&#39;),</span><br><span class="line">    url(&#39;..&#x2F;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.ttf?t&#x3D;1540697325659&#39;) format(&#39;truetype&#39;), &#x2F;* chrome, firefox, opera, Safari, Android, iOS 4.2+*&#x2F;</span><br><span class="line">    url(&#39;..&#x2F;..&#x2F;assets&#x2F;fonts&#x2F;iconfont.svg?t&#x3D;1540697325659#iconfont&#39;) format(&#39;svg&#39;); &#x2F;* iOS 4.1- *&#x2F;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.image&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border:1px solid green;</span><br><span class="line">    background: url(&#39;..&#x2F;..&#x2F;assets&#x2F;images&#x2F;logo.png&#39;) 100% 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这问题其实看到正确的文档内容，很快速能够解决，希望能帮到各位。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 nginx 防刷</title>
      <link href="/legacy/2018/10/29/nginx-ddos/"/>
      <url>/legacy/2018/10/29/nginx-ddos/</url>
      
        <content type="html"><![CDATA[<p>今天，没错就是今天，发生一个意料之中的线上问题：服务器被攻击，页面疯狂被刷，导致 node 服务 cpu 100%，页面渲染直接被崩掉。</p><p>这类问题对于互联网开发来说，见怪不怪。什么 <strong>Ddos、CC</strong> 等等吧，总之就是被人盯上了，想办法攻守转换吧。</p><p><strong>解决方式</strong><br><strong>云方案</strong><br>对于像我们一样小公司来说，为了减少运维成本，都用上了 xx 云。对于国内一些的云肯定提供了 <strong>解决方案</strong></p><ul><li>扩容，买机器硬杠</li><li>使用防 xx 攻击的付费服务</li><li>从访问日志中找出 ip，添加黑名单</li></ul><p>当然这些不是重点，类似方案专业的运维肯定能提供很多。主要引出 Nginx 方案</p><p><strong>Nginx 限流</strong><br>如果你还未使用过 nginx，不防看下这篇文章 <a href="https://eminoda.github.io/2018/10/19/nginx-product-practice/" target="_blank" rel="noopener">nginx 线上那些实用的最佳实践</a> ，可能会有架设一台 Nginx 的想法。</p><p><strong>解决思路</strong>：在后台服务，比如 node、java 之上，专门提供一台 nginx，负责各种请求的接入。因为覆盖了所有请求，我们可以对非法的请求通过 nginx 来做限流，或者我们业务上的一些代理转发等。</p><ol><li>链接数限制</li></ol><p><a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    limit_conn_zone     $binary_remote_addr     zone&#x3D;perip:10m;</span><br><span class="line">    server&#123;</span><br><span class="line">        location &#x3D; &#x2F; &#123;</span><br><span class="line">            # 限制链接数1个</span><br><span class="line">            limit_conn perip 1;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：并发发送 5 个 request</p><p>nginx.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">58.247.91.82 - - [29&#x2F;Oct&#x2F;2018:16:49:36 +0800] &quot;GET &#x2F;?r&#x3D;42.827815233418384 HTTP&#x2F;1.1&quot; 503 213 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br><span class="line">58.247.91.82 - - [29&#x2F;Oct&#x2F;2018:16:49:36 +0800] &quot;GET &#x2F;?r&#x3D;20.655923601902337 HTTP&#x2F;1.1&quot; 503 213 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br><span class="line">58.247.91.82 - - [29&#x2F;Oct&#x2F;2018:16:49:36 +0800] &quot;GET &#x2F;?r&#x3D;53.32509284109306 HTTP&#x2F;1.1&quot; 503 213 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br><span class="line">58.247.91.82 - - [29&#x2F;Oct&#x2F;2018:16:49:37 +0800] &quot;GET &#x2F;?r&#x3D;81.48015710993863 HTTP&#x2F;1.1&quot; 200 12715 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br><span class="line">58.247.91.82 - - [29&#x2F;Oct&#x2F;2018:16:49:37 +0800] &quot;GET &#x2F;?r&#x3D;26.774798805224908 HTTP&#x2F;1.1&quot; 200 12715 &quot;-&quot; &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>结果：只有 2 个请求状态 200，符合配置预期</p><ol start="2"><li>访问频率限制<br><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_limit_req_module.html</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    limit_req_zone      $binary_remote_addr     zone&#x3D;reqps:10m rate&#x3D;10r&#x2F;s;</span><br><span class="line">    server&#123;</span><br><span class="line">        location &#x3D; &#x2F; &#123;</span><br><span class="line">            limit_req zone&#x3D;reqps burst&#x3D;2;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：并发 5 个请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone      $binary_remote_addr     zone&#x3D;reqps:10m rate&#x3D;10r&#x2F;s;</span><br><span class="line">limit_req zone&#x3D;reqps;</span><br></pre></td></tr></table></figure><img src="/legacy/2018/10/29/nginx-ddos/1.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone      $binary_remote_addr     zone&#x3D;reqps:10m rate&#x3D;10r&#x2F;s;</span><br><span class="line">limit_req zone&#x3D;reqps burst&#x3D;3; #最多额外允许3个请求</span><br></pre></td></tr></table></figure><img src="/legacy/2018/10/29/nginx-ddos/2.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone      $binary_remote_addr     zone&#x3D;reqps:10m rate&#x3D;1r&#x2F;s; #每秒设置1个请求</span><br><span class="line">limit_req zone&#x3D;reqps burst&#x3D;3; #最多额外允许3个请求</span><br></pre></td></tr></table></figure><p><strong>注意：当 rate 为 1r/s 时，burst 的请求将延至执行</strong><br><img src="/legacy/2018/10/29/nginx-ddos/3.png" class=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone      $binary_remote_addr     zone&#x3D;reqps:10m rate&#x3D;1r&#x2F;s; #每秒设置1个请求</span><br><span class="line">limit_req zone&#x3D;reqps burst&#x3D;3 nodelay; #最多额外允许3个请求</span><br></pre></td></tr></table></figure><p><strong>设置 nodelay，取消延迟；</strong><br><img src="/legacy/2018/10/29/nginx-ddos/4.png" class=""></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 线上那些实用的最佳实践</title>
      <link href="/legacy/2018/10/19/nginx-product-practice/"/>
      <url>/legacy/2018/10/19/nginx-product-practice/</url>
      
        <content type="html"><![CDATA[<p>虽然公司小，但随着时间的推移各种需求，产线的复杂度逐渐增提升。原先一个线上项目只要解决跨域代理的问题，现在可能会解决各种问题。当没有运维或第三方的支持时，nginx 就由我们万能的前端来对接。何况前端本来就应该能 hold 它。</p><p>Nginx 基础，可以参考 <a href="http://eminoda.github.io/2018/08/10/nginx-basic-learn/" target="_blank" rel="noopener">http://eminoda.github.io/2018/08/10/nginx-basic-learn/</a></p><p>以下列出一些使用心得，如果有错误欢迎 issue</p><h2 id="API-接口统一代理"><a href="#API-接口统一代理" class="headerlink" title="API 接口统一代理"></a>API 接口统一代理</h2><p>比如有个 3000 端口的 node 云服务，为了更好的管理接口，前端统一以 <strong>/api</strong> 作为接口前缀。</p><p><a href="http://test.eminoda.com:81/api/getUsers" target="_blank" rel="noopener">http://test.eminoda.com:81/api/getUsers</a> =&gt; <a href="http://127.0.0.1:3000/getUsers" target="_blank" rel="noopener">http://127.0.0.1:3000/getUsers</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ^~ &#x2F;api&#x2F; &#123;</span><br><span class="line">  proxy_set_header host                $host;</span><br><span class="line">  proxy_set_header X-forwarded-for     $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-real-ip           $remote_addr;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后缀匹配，解决老业务.do、.action 等接口/页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~* &#x2F;*\.do$ &#123;</span><br><span class="line">  proxy_set_header host                $host;</span><br><span class="line">  proxy_set_header X-forwarded-for     $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-real-ip           $remote_addr;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定专有域名"><a href="#指定专有域名" class="headerlink" title="指定专有域名"></a>指定专有域名</h2><p>可以开设多个子域名，只要云上做了泛解析。</p><p>举例，完成接口统一接入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          80;</span><br><span class="line">  server_name     api.eminoda.com;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_set_header host                $host;</span><br><span class="line">    proxy_set_header X-forwarded-for $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-real-ip           $remote_addr;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动端 page</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          80;</span><br><span class="line">  server_name     h5.eminoda.com;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定默认域名"><a href="#指定默认域名" class="headerlink" title="指定默认域名"></a>指定默认域名</h2><p>通常会在 nginx 维护多个 server_name，当访问的 host 不存在，但服务器 ip 又被解析，nginx 根据它的机制给出默认的请求域名（可能根据配置文件的排序等）</p><p>使用 <strong>default_server</strong> 指定默认 server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          80 default_server;</span><br><span class="line">  server_name     www.niu100.com;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><p>安装 nginx 后，会有默认的配置结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有专门的数据分析，作为问题回溯，这样基本够用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">114.34.159.157 - - [18&#x2F;Oct&#x2F;2018:13:28:37 +0800] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 403 571 &quot;-&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.103 Safari&#x2F;537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>但是如果有些具体的数据打标，跟踪需求，可以参考如下配置：</p><p>业务 cookie 信息的获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set $userId &quot;-&quot;;</span><br><span class="line">  if ( $http_cookie ~* &quot;userId&#x3D;(\S+)(;.*|$)&quot; )&#123;</span><br><span class="line">    set $userId $1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>爬虫请求确认，如果你们有 seo 之类的统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set $spider &quot;-&quot;;</span><br><span class="line">if ($http_user_agent ~* &quot;Baiduspider|Googlebot|Sosospider&quot;)&#123;</span><br><span class="line">  set $spider &quot;1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 logger format，输出位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format  eminoda  &#39;$remote_addr $http_x_forwarded_for - [$time_local] &#39;</span><br><span class="line">                    &#39;$request $status $body_bytes_sent $request_time &#39;</span><br><span class="line">                    &#39;$userId $http_user_agent $spider&#39;;</span><br><span class="line"></span><br><span class="line">access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;my-access.log  eminoda;</span><br></pre></td></tr></table></figure><h2 id="整理-nginx-文件"><a href="#整理-nginx-文件" class="headerlink" title="整理 nginx 文件"></a>整理 nginx 文件</h2><p>nginx 是一个 http 服务，里面包含多个 server，当项目复杂起来，一定会造成杂乱的配置。这时需要一定的 <strong>整理</strong>，方便日后修改。根据个人习惯吧</p><p>不同 server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;server&#x2F;api.eminoda.conf;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;server&#x2F;static.emionda.conf;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;server&#x2F;eminoda.*.conf;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同配置抽取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80 default_server;</span><br><span class="line">    server_name     www.eminoda.com;</span><br><span class="line"></span><br><span class="line">    # ip拦截</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;ipLimit.conf;</span><br><span class="line">    # 业务信息打标</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;bussMark.conf;</span><br><span class="line">    # 接口代理代理</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;proxy_A.conf;</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf&#x2F;proxy_B.conf;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置-SSL——https"><a href="#配置-SSL——https" class="headerlink" title="配置 SSL——https"></a>配置 SSL——https</h2><p>市面上有很多免费的证书提供商，以下给出阿里云的默认配置</p><p><a href="https://www.eminoda.com" target="_blank" rel="noopener">https://www.eminoda.com</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.eminoda.com;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate   cert-eminoda&#x2F;123.pem;</span><br><span class="line">        ssl_certificate_key  cert-eminoda&#x2F;123.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动跳转-https-站点"><a href="#自动跳转-https-站点" class="headerlink" title="自动跳转 https 站点"></a>自动跳转 https 站点</h2><p>google 对 https 站的 seo 会更好，像安全性等好处这里不做展开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name  www.eminoda.com;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header host                $host;</span><br><span class="line">    proxy_set_header X-forwarded-for     $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-real-ip           $remote_addr;</span><br><span class="line">    rewrite ^&#x2F;(.*) https:&#x2F;&#x2F;www.eminoda.com&#x2F;$1 permanent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多端的适配"><a href="#多端的适配" class="headerlink" title="多端的适配"></a>多端的适配</h2><p>实现在移动端访问 PC 页面，重定向到手机页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~* &quot;(Mobile|Android|iPad|iPhone|iPod|BlackBerry|Windows Phone)&quot;) &#123;</span><br><span class="line">    rewrite ^&#x2F; http:&#x2F;&#x2F;h5.eminoda.com redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IP-限制"><a href="#IP-限制" class="headerlink" title="IP 限制"></a>IP 限制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( $http_x_forwarded_for ~ &quot;106.120.121.128$|106.120.121.129$|106.120.121.1[3-5][0-9]$&quot;) &#123;</span><br><span class="line">    rewrite ^&#x2F; http:&#x2F;&#x2F;limit.eminoda.com&#x2F;limit.html rewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>可能因为短信运营商的字符数量限制、业务需要，要尽可能缩短链接长度。</p><p><a href="http://l.em.com/123456789/987654321" target="_blank" rel="noopener">http://l.em.com/123456789/987654321</a> ==&gt; <a href="http://www.eminoda.com/aaa/bbb/123456789?id=987654321" target="_blank" rel="noopener">http://www.eminoda.com/aaa/bbb/123456789?id=987654321</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          80;</span><br><span class="line">  server_name     l.em.com;</span><br><span class="line">  rewrite ^&#x2F;(\d+)&#x2F;(\d+) http:&#x2F;&#x2F;www.eminoda.com&#x2F;aaa&#x2F;bbb&#x2F;$1?id&#x3D;$2  rewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常错误页面的指定"><a href="#异常错误页面的指定" class="headerlink" title="异常错误页面的指定"></a>异常错误页面的指定</h2><p>服务器宕机、发布，网页的超时等因素，默认 nginx 的错误页面可能令用户产生疑惑。需要指定 error page，提升体验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error_page 404 &#x3D; http:&#x2F;&#x2F;m.eminoda.com&#x2F;404;</span><br><span class="line">error_page 405 &#x3D; http:&#x2F;&#x2F;m.eminoda.com&#x2F;405;</span><br><span class="line">error_page 500 &#x3D; http:&#x2F;&#x2F;m.eminoda.com&#x2F;500;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 页面模板之 Nunjucks</title>
      <link href="/legacy/2018/09/06/node-template/"/>
      <url>/legacy/2018/09/06/node-template/</url>
      
        <content type="html"><![CDATA[<h1 id="看下常见的-Template"><a href="#看下常见的-Template" class="headerlink" title="看下常见的 Template"></a>看下常见的 Template</h1><p><strong>github 上一些对比</strong><br><img src="/legacy/2018/09/06/node-template/github.png" class=""></p><h1 id="为何选择-nunjuks？"><a href="#为何选择-nunjuks？" class="headerlink" title="为何选择 nunjuks？"></a>为何选择 nunjuks？</h1><ul><li>mozilla 项目</li><li>有完善的文档，简约设计，详细 API，还有 <strong>中文版本</strong></li><li>模板 html 风格。不像 jade 那么重视严谨的缩进</li><li>包含主流模板功能。继承、过滤器、逻辑判断、循环…</li><li>可支持到 IE8</li></ul><h1 id="nunjuck-常用-API"><a href="#nunjuck-常用-API" class="headerlink" title="nunjuck 常用 API"></a>nunjuck 常用 API</h1><p>如果你愿意，直接跳过以下内容，<a href="https://mozilla.github.io/nunjucks/templating.html" target="_blank" rel="noopener">点击看官网</a></p><h2 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;member.realName&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>若一个 undefined 的变量，获取其下的属性，模板是不会有输出的，当然不会 throw error</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;user.name&#125;&#125; &#x2F;&#x2F; user&#x3D;undefined</span><br></pre></td></tr></table></figure><h2 id="过滤器（filters）"><a href="#过滤器（filters）" class="headerlink" title="过滤器（filters）"></a>过滤器（filters）</h2><p><a href="https://mozilla.github.io/nunjucks/templating.html#builtin-filters" target="_blank" rel="noopener">常用内置过滤器</a></p><p><strong>自定义过滤器</strong></p><ol><li>create nunjucks env</li><li>env 下挂载过滤器方法</li></ol><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env.addFilter(&#39;money&#39;, (value, format) &#x3D;&gt; &#123;</span><br><span class="line">  return numeral(value).format(format);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>njk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;money|money(&#39;0.00&#39;)&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="模板继承（template-inheritance）"><a href="#模板继承（template-inheritance）" class="headerlink" title="模板继承（template inheritance）"></a>模板继承（template inheritance）</h2><p>parent.njk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;link href&#x3D;&quot;&#x2F;stylesheets&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &#123;% block content %&#125;</span><br><span class="line">        &#x2F;&#x2F; 如果你想保留此书的业务数据，可以在child使用&#123;&#123;super()&#125;&#125;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>child.njk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#39;.&#x2F;layout.nunjucks&#39; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &#123;&#123;money|money(&#39;0.00&#39;)&#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h2 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a><a href="https://mozilla.github.io/nunjucks/templating.html#tags" target="_blank" rel="noopener">标签 Tag</a></h2><ul><li>if</li><li>for</li><li>set</li><li>extends</li><li>block</li><li>include</li><li>filter</li><li>…</li></ul><h2 id="注释-Comments"><a href="#注释-Comments" class="headerlink" title="注释 Comments"></a>注释 Comments</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# Loop through all the users #&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式 Expressions"></a>表达式 Expressions</h2><ol><li>逻辑 Logic</li></ol><ul><li>and</li><li>or</li><li>not <strong>注意没有!foo 这样的判断</strong></li><li>组合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if users and showUsers %&#125;...&#123;% endif %&#125;</span><br><span class="line">&#123;% if i &#x3D;&#x3D; 0 and not hideFirst %&#125;...&#123;% endif %&#125;</span><br><span class="line">&#123;% if (x &lt; 5 or y &lt; 5) and foo %&#125;...&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Math 支持数学运算</li><li>比较能力 == === &gt;= != &gt;…</li><li>正则&amp;函数运行</li></ol><h1 id="如何在-Node-中使用"><a href="#如何在-Node-中使用" class="headerlink" title="如何在 Node 中使用"></a>如何在 Node 中使用</h1><h2 id="直接利用-njk-的-api（复杂）"><a href="#直接利用-njk-的-api（复杂）" class="headerlink" title="直接利用 njk 的 api（复杂）"></a>直接利用 njk 的 api（复杂）</h2><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建njk环境</span></span><br><span class="line"><span class="keyword">const</span> env = nunjucksService.createEnvironment(path.join(__dirname, <span class="string">'views'</span>), &#123;&#125;);</span><br><span class="line"><span class="comment">// 设置njk过滤器</span></span><br><span class="line">nunjucksService.setFilter(env);</span><br><span class="line"><span class="comment">// 设置njk中间件，以适应koa模式</span></span><br><span class="line">app.use(</span><br><span class="line">  nunjucksService.createMiddleware(&#123;</span><br><span class="line">    env: env,</span><br><span class="line">    ext: <span class="string">'.html'</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">'views'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>nunjucksService.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bluebird = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> nunjucks = <span class="built_in">require</span>(<span class="string">'nunjucks'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 创建环境</span></span><br><span class="line">  createEnvironment: <span class="function"><span class="keyword">function</span>(<span class="params">path, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> nunjucks.Environment(</span><br><span class="line">      <span class="comment">// 由于基于node，所以要建立一个文件系统体系</span></span><br><span class="line">      <span class="keyword">new</span> nunjucks.FileSystemLoader(path, options)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 模板渲染中间件</span></span><br><span class="line">  createMiddleware: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options.env.renderAsync = bluebird.promisify(options.env.render);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">      ctx.render = <span class="keyword">async</span> (view, data) =&gt; &#123;</span><br><span class="line">        view += options.ext || <span class="string">'.html'</span>;</span><br><span class="line">        <span class="comment">// 将ctx的data数据，交给njk render</span></span><br><span class="line">        <span class="keyword">return</span> options.env.renderAsync(path.resolve(options.path, view), data).then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">          ctx.type = <span class="string">'html'</span>;</span><br><span class="line">          ctx.body = html;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>xx.router.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;&#39;, async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">    await ctx.render(&#39;index&#39;, ctx.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="koa-views（推荐）"><a href="#koa-views（推荐）" class="headerlink" title="koa-views（推荐）"></a>koa-views（推荐）</h2><p>之前没有发现这个库，自己造了个轮子（崩溃）。</p><p>使用很简单，封装了市面上各种 template，也支持配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line">app.use(</span><br><span class="line">  views(__dirname + <span class="string">'/views'</span>, &#123;</span><br><span class="line">    <span class="comment">// 指定模板引擎，default 同extension</span></span><br><span class="line">    map: &#123;</span><br><span class="line">      suffix: <span class="string">'nunjucks'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extension: <span class="string">'nunjucks'</span>, <span class="comment">//模板后缀,default html</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      nunjucks: &#123;</span><br><span class="line">        configure: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'views'</span>),</span><br><span class="line">          &#123;</span><br><span class="line">            noCache: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nunjucks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue minuti 分页实现</title>
      <link href="/legacy/2018/09/04/vue-mintui-page/"/>
      <url>/legacy/2018/09/04/vue-mintui-page/</url>
      
        <content type="html"><![CDATA[<p>来谈下使用 <strong>vue+minuti</strong> 如何实现上拉，下拉分页数据加载操作。<br>分两块内容：</p><ul><li>minuti loadmore 使用示例</li><li>分页中可以积累的知识点</li></ul><h1 id="minuti-loadmore-组件"><a href="#minuti-loadmore-组件" class="headerlink" title="minuti loadmore 组件"></a>minuti loadmore 组件</h1><img src="/legacy/2018/09/04/vue-mintui-page/loadmore.gif" class="" title="实际效果"><p><a href="http://mint-ui.github.io/docs/#/zh-cn2/loadmore" target="_blank" rel="noopener">官方 API</a></p><p>template</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mt-loadmore</span> <span class="attr">:top-method</span>=<span class="string">"loadTop"</span> <span class="attr">:bottom-method</span>=<span class="string">"loadBottom"</span> <span class="attr">:bottom-all-loaded</span>=<span class="string">"allLoaded"</span> <span class="attr">ref</span>=<span class="string">"loadmore"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line-item"</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mt-loadmore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vue script</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 模拟接口数据</span></span><br><span class="line">  buildList: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nextPageList = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt;= <span class="number">15</span>; index++) &#123;</span><br><span class="line">      nextPageList.push(&#123; <span class="attr">id</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="built_in">Math</span>.random(<span class="number">1</span>) * <span class="number">10</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextPageList;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 下拉</span></span><br><span class="line">  loadTop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'loadTop'</span>);</span><br><span class="line">    <span class="keyword">this</span>.list = <span class="keyword">this</span>.buildList();</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 重置上拉开关</span></span><br><span class="line">    self.allLoaded = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 消除loading icon</span></span><br><span class="line">      self.$refs.loadmore.onTopLoaded();</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  loadBottom: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'loadBottom'</span>);</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 关闭上拉加载</span></span><br><span class="line">    self.allLoaded = <span class="literal">true</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 校验接口数据，判断是否继续打开上拉加载开关</span></span><br><span class="line">      self.allLoaded = <span class="literal">false</span>;</span><br><span class="line">      self.list = self.list.concat(self.buildList());</span><br><span class="line">      <span class="comment">// 消除loading icon</span></span><br><span class="line">      self.$refs.loadmore.onBottomLoaded();</span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前比较主流的前端框架都有非常好用的基础 UI 组件库，比如：vue 国内就有 mintui、elementui。只用非常简单，对照 API 说明即可完成功能实现。</p><h1 id="需要-get-的点"><a href="#需要-get-的点" class="headerlink" title="需要 get 的点"></a>需要 get 的点</h1><p>组件库的出现当然为了让开发更容易上手开发应用，提高开发效率。相反也有弊端，我们逐渐缺乏对功能实现的技巧，甚至为了完成某些效果，项目里融入了多个组件库。（所以定期看下比较好用的 npm 库，是提升自己，不被行业淘汰的方式之一）</p><p>如下给出一些可能平时忽略的技术点：</p><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>transform 设置 translate3d 的 Y 轴，实现类似 native 那种拉动效果。</p><img src="/legacy/2018/09/04/vue-mintui-page/transform.gif" class="" title="transform&#x3D;translate3d(0,?px, 0);"><p><a href="https://c.runoob.com/codedemo/3391" target="_blank" rel="noopener">其他一些例子</a></p><h2 id="computed-amp-methods-amp-watch-区别"><a href="#computed-amp-methods-amp-watch-区别" class="headerlink" title="computed &amp; methods &amp; watch 区别"></a>computed &amp; methods &amp; watch 区别</h2><ul><li>计算属性（computed）是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值</li><li>而 methods 则需要主动调用。</li><li>监听（watch）是在 Vue 实例化的时候调用，遍历 watch 对象的每一个属性。</li></ul><p>在 loadmore 组件中，最频繁的就是上拉下载操作，所以使用了 <strong>computed</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  transform() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.translate === <span class="number">0</span> ? <span class="literal">null</span> : <span class="string">'translate3d(0, '</span> + <span class="keyword">this</span>.translate + <span class="string">'px, 0)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一些延迟返回的 status 判断，使用了 <strong>watch</strong> 来监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">topStatus(val) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'top-status-change'</span>, val);</span><br><span class="line">  <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'pull'</span>:</span><br><span class="line">      <span class="keyword">this</span>.topText = <span class="keyword">this</span>.topPullText;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'drop'</span>:</span><br><span class="line">      <span class="keyword">this</span>.topText = <span class="keyword">this</span>.topDropText;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'loading'</span>:</span><br><span class="line">      <span class="keyword">this</span>.topText = <span class="keyword">this</span>.topLoadingText;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="\$ref"></a>\$ref</h2><blockquote><p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 \$refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.$refs.loadmore.onTopLoaded();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onTopLoaded() &#123;</span><br><span class="line">  <span class="keyword">this</span>.translate = <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.topStatus = <span class="string">'pull'</span>;</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意：<strong>因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！\$refs 也不是响应式的</strong></p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="\$nextTick"></a>\$nextTick</h2><blockquote><p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p></blockquote><p>用于 Dom 渲染完，某些数据的更新，则需要使用 nextTick 加入 callback，重新 push 到 vue 渲染机制中。</p><p><a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">当然没有那么简单，更多网站有大堆的针对 nextTick 的解读</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onBottomLoaded() &#123;</span><br><span class="line">  this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    this.translate &#x3D; 0;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">nodeType</a></h2><p>用来区分 Html 里 dom 节点类型</p><table><thead><tr><th>常量</th><th>value</th><th>说明</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td>1</td><td>元素节点</td></tr><tr><td>Node.TEXT_NODE</td><td>3</td><td>元素节点或者文字</td></tr><tr><td>Node.PROCESSING_INSTRUCTION_NODE</td><td>7</td><td>xml 顶部的声明</td></tr><tr><td>Node.COMMENT_NODE</td><td>8</td><td>注释</td></tr><tr><td>Node.DOCUMENT_NODE</td><td>9</td><td>document.nodeType</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td>10</td><td>document.doctype.nodeType</td></tr><tr><td>Node.DOCUMENT_FRAGMENT_NODE</td><td>11</td><td>虚拟节点 document.createDocumentFragment().nodeType</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getScrollEventTarget(element) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = element;</span><br><span class="line">  <span class="comment">// 判断是否全局滚动条</span></span><br><span class="line">  <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.tagName !== <span class="string">'HTML'</span> &amp;&amp;</span><br><span class="line">    currentNode.tagName !== <span class="string">'BODY'</span> &amp;&amp; currentNode.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> overflowY = <span class="built_in">document</span>.defaultView.getComputedStyle(currentNode).overflowY;</span><br><span class="line">    <span class="keyword">if</span> (overflowY === <span class="string">'scroll'</span> || overflowY === <span class="string">'auto'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode = currentNode.parentNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于滚动"><a href="#关于滚动" class="headerlink" title="关于滚动"></a>关于滚动</h2><p><strong>判断页面是否滚动到底部</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.scrollEventTarget === <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight &gt;= <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$el.getBoundingClientRect().bottom &lt;= <span class="keyword">this</span>.scrollEventTarget.getBoundingClientRect().bottom + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断页面是否超过可视屏幕</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.scrollEventTarget === <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.containerFilled = <span class="keyword">this</span>.$el.getBoundingClientRect().bottom &gt;= <span class="built_in">document</span>.documentElement.getBoundingClientRect().bottom;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.containerFilled = <span class="keyword">this</span>.$el.getBoundingClientRect().bottom &gt;= <span class="keyword">this</span>.scrollEventTarget.getBoundingClientRect().bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取滚动条距离顶部距离</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (element &#x3D;&#x3D;&#x3D; window) &#123;</span><br><span class="line">  return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return element.scrollTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000008065472" target="_blank" rel="noopener"><strong>浏览器兼容问题</strong></a></p><ul><li>chrome 只认识：document.body.scrollTop</li><li>ie678：document.documentElement.scrollTop</li><li>ie9 及以上：window.pageYOffset 或者 document.documentElement.scrollTop</li></ul><p>所以自己实现时，注意这些点，饿了吗这个框架貌似很久没有 merge 了</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mint-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL能代替Restful吗</title>
      <link href="/legacy/2018/08/24/graphQL-restful/"/>
      <url>/legacy/2018/08/24/graphQL-restful/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在微信看到一篇文章，<a href="https://mp.weixin.qq.com/s/F55uPAKLI1c78ccsK23ubw" target="_blank" rel="noopener">REST 将会过时，而 GraphQL 则会长存</a>。前段时间，我们的后端同学主推 restful 方式构建 api 服务，难道以后会被 graphQL 干掉？我也不知道，借这个话题介绍下 graphQL，权衡两者特点来推进更完善服务端设计。</p><h1 id="目前开发的困扰"><a href="#目前开发的困扰" class="headerlink" title="目前开发的困扰"></a>目前开发的困扰</h1><p>从 <strong>前后端分离</strong> 的结果来看，虽然后台同学 <strong>专职于</strong> 提供业务服务的数据接口，但还是不可避免造成前后端的各种 <strong>开发困扰</strong>：</p><ul><li>后端提供对象级，对象嵌套级别的数据，数据量过于庞大。更容易暴露数据库的结构，增加风险</li><li>后端接口随着业务的迭代变化，产生冗余的接口，不易维护</li><li>后端逐渐背离 Restful 设计规范，接口难以理解</li><li>职责分离，前端不熟悉业务逻辑，前端只关心数据展示，增加不必要的 Bug</li><li>一个页面，通常会调用数个接口来展示</li><li>接口数据不和预期，需要二次加工</li><li>前后端，产品…之前矛盾日益增加</li></ul><h1 id="GraphQL-和-Restful-那个好？"><a href="#GraphQL-和-Restful-那个好？" class="headerlink" title="GraphQL 和 Restful 那个好？"></a>GraphQL 和 Restful 那个好？</h1><p>GraphQL 基础介绍，可以参考我 Blog 里[GraphQL 入门]</p><p>我会从 2 个<strong>实际场景</strong>来展现 GraphQL 的特点，对比 Restful，尽可能展示出 GraphQL 的<strong>优势</strong></p><h2 id="场景一，数据聚合"><a href="#场景一，数据聚合" class="headerlink" title="场景一，数据聚合"></a>场景一，数据聚合</h2><p>一个简单的 用户主页 展示：<br><img src="/legacy/2018/08/24/graphQL-restful/graph-good1.png" class="" title="用户主页"><br>缺点：</p><ul><li>为了渲染“个人中心”页面，请求了 3 个接口（这里起码调用了 3 个基础接口）。</li><li>近百个字段，开发时寻找目标字段很困难</li><li>业务条件不同，数据不稳定。</li></ul><p>拿来看看 GraphQL 能带来什么效果：<br><img src="/legacy/2018/08/24/graphQL-restful/graph-example1.png" class="" title="维护一个页面的query对象，查询页面实际所需的字段"></p><p>好处:</p><ul><li>以页面为单位，前端可自定义数据结构，更好的适应页面渲染</li><li>数据体量急剧到最小化，相信开发，测试效率都大幅提升</li><li>graphQL 专门维护对象 type，与后台一一对应，明确数据格式，相当于 mock debugger</li></ul><h2 id="场景二，数据重构"><a href="#场景二，数据重构" class="headerlink" title="场景二，数据重构"></a>场景二，数据重构</h2><img src="/legacy/2018/08/24/graphQL-restful/graph-good2.png" class="" title="一个列表数据需要加工"><p>如上图，持仓列表的<strong>当前市值占比=A/B 算出</strong>，AB 字段又分别来自不同接口。</p><p>理想情况下：对于一个列表数据，前端肯定倾向于获取一个接口数据后遍历渲染即可，但<strong>事与愿违</strong>，产品的需求、业务问题、后端实现方式，总需要额外的接口请求，数据二次加工，才能达到预期。</p><p>那我们 GraphQL 可以怎么应对？<br><img src="/legacy/2018/08/24/graphQL-restful/graph-example2.png" class="" title="请求持仓接口直接包含业务数据"></p><p>好处：</p><ul><li>增加开发效率。前端一次请求，完成数据加工。后端多个接口也不用关心</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>结合 GraphQL 的提供的 API，还有很多解决目前前后端开发的问题。比如：对象的抽象化，数据的枚举…</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就上面 2 个具有特征性例子，不难发现 GraphQL 真的非常好用。这两个 API 设计思想其实没有对比上的好坏，具体要看使用场景。<br>有了这个，后端同可以专心制定符合 restful 设计模式的 API，作为端数据；<strong>前端</strong>如果有能力可以自己中间加一层 GraphQL，当然 GraphQL 也有其他语言的实现方式。可以说 <strong>一次编写，处处省心；多个需求，妥妥迭代</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> graphQL </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 最佳实践</title>
      <link href="/legacy/2018/08/24/restful-best-practise/"/>
      <url>/legacy/2018/08/24/restful-best-practise/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>restful（Representational State Transfer）近年来听到的次数逐渐增多，自打前后端分离开始流行，服务端越来越侧重提供 API 的质量和方式。<br>不谈 restful 巴拉巴拉的概念，但从实际落地的效果，看下几个常见的 best practice</p><h2 id="接口定义规范"><a href="#接口定义规范" class="headerlink" title="接口定义规范"></a>接口定义规范</h2><table><thead><tr><th>resource</th><th>get</th><th>post</th><th>put</th><th>delete</th></tr></thead><tbody><tr><td>/users</td><td>获取用户列表</td><td>新增用户</td><td>更新用户信息</td><td>删除用户</td></tr><tr><td>/users/:id</td><td>根据 id 获取用户</td><td>return 405</td><td>根据 id 更新用户</td><td>删除指定用户</td></tr></tbody></table><p>这是 rest 最明显的特点，通过 Http 请求方法来判断<strong>同一资源</strong>的不同操作方式的展现。</p><ul><li>同一资源在不同 http method 实现不同需求</li><li>接口最好用复数</li><li><strong>资源获取</strong>（users，products）以名词代替动词</li><li><strong>非资源</strong>（calc…）以动词定义</li><li>接口以资源定义，不要按照功能语义功能</li></ul><p>切记不要使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;getUsers</span><br><span class="line">&#x2F;addUsers</span><br><span class="line">&#x2F;user</span><br><span class="line">&#x2F;frozenUsers</span><br><span class="line">&#x2F;activeUser</span><br></pre></td></tr></table></figure><h2 id="请求参数定义"><a href="#请求参数定义" class="headerlink" title="请求参数定义"></a>请求参数定义</h2><p>比如维护 get api 或者添加 query params 方式来改变用户状态。应该使用 post、put 等来修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;users&#x2F;:id&#x2F;frozen</span><br><span class="line">&#x2F;users&#x2F;:id?frozen&#x3D;1</span><br></pre></td></tr></table></figure><h2 id="不同的错误处理"><a href="#不同的错误处理" class="headerlink" title="不同的错误处理"></a>不同的错误处理</h2><p>提供针对不同情况的 response code 和描述错误的信息</p><h2 id="返回状态码限制"><a href="#返回状态码限制" class="headerlink" title="返回状态码限制"></a>返回状态码限制</h2><p>同一接口在不同的 method 下，不同错误处理，返回的状态码不同。</p><ul><li>200 OK</li><li>400 Bad Request</li><li>401 Unauthorized</li><li>404 Not Found</li><li>403 Forbidden</li><li>500 Internal Server Error</li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;users</span><br></pre></td></tr></table></figure><h2 id="HATEOAS-驱动"><a href="#HATEOAS-驱动" class="headerlink" title="HATEOAS 驱动"></a>HATEOAS 驱动</h2><p>HATEOAS(hypermedia as the engine of application state)<br>整个 rest 构建的服务，以超文本作为应用状态来驱动。客户端对资源的获取渐进式的方式按需获取。<br><img src="/legacy/2018/08/24/restful-best-practise/HATEOAS.png" class="" title="HATEOAS"></p><ul><li>第一个层次（Level 0）的 Web 服务只是使用 HTTP 作为传输方式，实际上只是远程方法调用（RPC）的一种具体形式。SOAP 和 XML-RPC 都属于此类。</li><li>第二个层次（Level 1）的 Web 服务引入了资源的概念。每个资源有对应的标识符和表达。</li><li>第三个层次（Level 2）的 Web 服务使用不同的 HTTP 方法来进行不同的操作，并且使用 HTTP 状态码来表示不同的结果。如 HTTP GET 方法来获取资源，HTTP DELETE 方法来删除资源。</li><li>第四个层次（Level 3）的 Web 服务使用 HATEOAS。在资源的表达中包含了链接信息。客户端可以根据链接来发现可以执行的动作。</li></ul><p>定义了 4 个 level，不过我们大多停留在 0,1 级，说白了就是不规范的 rest</p><p>如：获取学校</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;api&#x2F;schools</span><br><span class="line">&#123;</span><br><span class="line">    students:&#123;</span><br><span class="line">        url:&#39;&#x2F;api&#x2F;students&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    teachers:&#123;</span><br><span class="line">        url:&#39;&#x2F;api&#x2F;teachers&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://github.com/waylau/rest-in-action" target="_blank" rel="noopener">rest action</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 GraphQL</title>
      <link href="/legacy/2018/08/22/graphQL-quickstart/"/>
      <url>/legacy/2018/08/22/graphQL-quickstart/</url>
      
        <content type="html"><![CDATA[<h1 id="graphQL"><a href="#graphQL" class="headerlink" title="graphQL"></a><a href="http://graphql.github.io/" target="_blank" rel="noopener">graphQL</a></h1><blockquote><p>A query language for your API<br>GraphQL 用于作为 API 查询的一种语言，针对 API 服务提供全面、易懂的数据描述，使得客户端能够能容易，能好的获取数据。一个强大的<strong>developer tools</strong></p></blockquote><p>当然我们只看<a href="http://graphql.github.io/graphql-js/" target="_blank" rel="noopener">graphQL.js</a></p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="Basic-Types-基础类型"><a href="#Basic-Types-基础类型" class="headerlink" title="Basic Types 基础类型"></a>Basic Types 基础类型</h2><ul><li>String</li><li>Int</li><li>Float</li><li>Boolean</li><li>ID</li></ul><p><strong>默认每个类型可以为空，可以定义！来特殊注明不能为空</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Query&#123;</span><br><span class="line">    hello:String</span><br><span class="line">    test:String!</span><br><span class="line">    number:Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 test 定义为 String，若没有数据将返回 null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;data&quot;:&#123;&quot;hello&quot;:&quot;Hello world!&quot;,&quot;test&quot;:null,&quot;num&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure><p>定义 String!，若无数据，将报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   &quot;errors&quot;:[&#123;</span><br><span class="line">        &quot;message&quot;:&quot;Cannot return null for non-nullable field Query.test.&quot;,&quot;locations&quot;:[&#123;&quot;line&quot;:1,&quot;column&quot;:9&#125;],&quot;path&quot;:[&quot;test&quot;]</span><br><span class="line">    &#125;],</span><br><span class="line">    &quot;data&quot;:null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Passing-Arguments-传递参数"><a href="#Passing-Arguments-传递参数" class="headerlink" title="Passing Arguments 传递参数"></a>Passing Arguments 传递参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var schema &#x3D; buildSchema(&#96;</span><br><span class="line">  type Query&#123;</span><br><span class="line">    hello:String</span><br><span class="line">    test:String!</span><br><span class="line">    num(numDice: Int!, numSides: Int):Int</span><br><span class="line">  &#125;</span><br><span class="line">&#96;)</span><br><span class="line">var root &#x3D; &#123;</span><br><span class="line">  hello: () &#x3D;&gt; &#123;</span><br><span class="line">    return &#39;Hello world!&#39;;</span><br><span class="line">  &#125;,</span><br><span class="line">  test: () &#x3D;&gt; &#123;</span><br><span class="line">    return &#39;test&#39;;</span><br><span class="line">  &#125;,</span><br><span class="line">  num: (args) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; &#123; numDice: 2, numSides: 3 &#125;</span><br><span class="line">    console.log(args);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">graphql(schema, &#39;&#123; hello test num(numDice:2,numSides:3)&#125;&#39;, root).then((response) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; &#123;&quot;data&quot;:&#123;&quot;hello&quot;:&quot;Hello world!&quot;,&quot;test&quot;:&quot;123&quot;,&quot;num&quot;:1&#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用-Express-构建-GraphQL-服务"><a href="#使用-Express-构建-GraphQL-服务" class="headerlink" title="使用 Express 构建 GraphQL 服务"></a>使用 Express 构建 GraphQL 服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express express-graphql graphql --save</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var gql1 &#x3D; require(&#39;.&#x2F;graph&#x2F;test1.js&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">app.use(&#39;&#x2F;gql&#39;, gql1);</span><br></pre></td></tr></table></figure><p>graph/test1.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var &#123;</span><br><span class="line">    buildSchema</span><br><span class="line">&#125; &#x3D; require(&#39;graphql&#39;);</span><br><span class="line">var graphqlHTTP &#x3D; require(&#39;express-graphql&#39;);</span><br><span class="line"></span><br><span class="line">let schema &#x3D; buildSchema(&#96;</span><br><span class="line">type Query&#123;</span><br><span class="line">  hello:String</span><br><span class="line">  test:String!</span><br><span class="line">  num(numDice: Int!, numSides: Int):Int</span><br><span class="line">&#125;</span><br><span class="line">&#96;)</span><br><span class="line">let root &#x3D; &#123;</span><br><span class="line">    hello: () &#x3D;&gt; &#123;</span><br><span class="line">        return &#39;Hello world!&#39;;</span><br><span class="line">    &#125;,</span><br><span class="line">    test: () &#x3D;&gt; &#123;</span><br><span class="line">        return &#39;test&#39;;</span><br><span class="line">    &#125;,</span><br><span class="line">    num: (args) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; &#123; numDice: 2, numSides: 3 &#125;</span><br><span class="line">        console.log(args);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports &#x3D; graphqlHTTP(&#123;</span><br><span class="line">    schema: schema,</span><br><span class="line">    rootValue: root,</span><br><span class="line">    graphiql: true,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>插件效果：<br><img src="/legacy/2018/08/22/graphQL-quickstart/graphQL-express.png" class=""><br><strong>express-graphql</strong>会自动解析 req.query 的参数。当然还可以集成其他中间件 Middleware(<a href="http://www.passportjs.org/" target="_blank" rel="noopener"><strong>Passport</strong></a>,<strong>express-jwt</strong>,<strong>express-session</strong>)来稳定、扩展这个微服务。</p><h2 id="Mutations-and-Input-Types-根据输入值改变行为"><a href="#Mutations-and-Input-Types-根据输入值改变行为" class="headerlink" title="Mutations and Input Types 根据输入值改变行为"></a>Mutations and Input Types 根据输入值改变行为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let schema &#x3D; buildSchema(&#96;</span><br><span class="line"># 定义传入对象类型</span><br><span class="line">input MessageInput&#123;</span><br><span class="line">    message:String</span><br><span class="line">&#125;</span><br><span class="line"># 定义Message对象，类似泛型</span><br><span class="line">type Message&#123;</span><br><span class="line">    message:String</span><br><span class="line">&#125;</span><br><span class="line"># 某种行为</span><br><span class="line">type Mutation &#123;</span><br><span class="line">    # 保存传入数据</span><br><span class="line">    setMessage(input: MessageInput): Message</span><br><span class="line">&#125;</span><br><span class="line"># Query必须定义</span><br><span class="line">type Query &#123;</span><br><span class="line">    getMessage: String</span><br><span class="line">&#125;</span><br><span class="line">&#96;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Message对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Message</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = input.message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟数据源</span></span><br><span class="line"><span class="keyword">var</span> fakeDatabase = &#123;</span><br><span class="line">  message: <span class="string">'data from DB'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">  <span class="comment">// 实现保存数据，返回新Message对象</span></span><br><span class="line">  setMessage: <span class="function"><span class="keyword">function</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &#123; input: &#123; message: 'abc' &#125; &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(input.input);</span><br><span class="line">  &#125;,</span><br><span class="line">  getMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fakeDatabase.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/legacy/2018/08/22/graphQL-quickstart/gql.png" class=""><p>如果没使用 express-graph 方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graphql(schema,</span><br><span class="line">    &#96;</span><br><span class="line">    mutation CreateMessage($input: MessageInput) &#123;</span><br><span class="line">        setMessage(input:$input)&#123;message&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#96;, root, &#123;&#125;, &#123;</span><br><span class="line">        input: &#123;</span><br><span class="line">            message: &quot;123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;CreateMessage&quot;</span><br><span class="line">).then((response) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Queries-and-Mutations-查询和转变"><a href="#Queries-and-Mutations-查询和转变" class="headerlink" title="Queries and Mutations 查询和转变"></a>Queries and Mutations 查询和转变</h1><h2 id="Fields-字段（像是定义一个对象）"><a href="#Fields-字段（像是定义一个对象）" class="headerlink" title="Fields 字段（像是定义一个对象）"></a>Fields 字段（像是定义一个对象）</h2><p>在 query 定义 fields，来告诉 GraphQL 该查询什么数据与之对应。<br>每个 fields 有自己的 name，和字符串的 type（对象中属性）</p><img src="/legacy/2018/08/22/graphQL-quickstart/fields.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let schema &#x3D; buildSchema(&#96;</span><br><span class="line">    type Query&#123;</span><br><span class="line">        hexo:Hexo</span><br><span class="line">    &#125;</span><br><span class="line">    type Hexo&#123;</span><br><span class="line">        name:String,</span><br><span class="line">        age:Int</span><br><span class="line">    &#125;</span><br><span class="line">&#96;)</span><br><span class="line">function Hexo(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">var root &#x3D; &#123;</span><br><span class="line">    hexo: () &#x3D;&gt; &#123;</span><br><span class="line">        return new Hexo(&#39;abc&#39;, 12);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>fields 中的属性可以按需定义，但是前提是 schema 要维护好。在这个前提下，query 可以任意增减属性，相当于数据过滤效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query&#123;</span><br><span class="line">  hexo&#123;</span><br><span class="line">    name</span><br><span class="line">    country</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;message&quot;: &quot;Cannot query field \&quot;country\&quot; on type \&quot;Hexo\&quot;.&quot;</span><br></pre></td></tr></table></figure><h2 id="Arguments-参数"><a href="#Arguments-参数" class="headerlink" title="Arguments 参数"></a>Arguments 参数</h2><p>在 query 定义参数列表，供 root 解析处理。</p><img src="/legacy/2018/08/22/graphQL-quickstart/arguments.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let schema &#x3D; buildSchema(&#96;</span><br><span class="line">    type Query&#123;</span><br><span class="line">        hexo(id:ID):Hexo</span><br><span class="line">    &#125;</span><br><span class="line">    type Hexo&#123;</span><br><span class="line">        id:ID,</span><br><span class="line">        name:String,</span><br><span class="line">        age:Int</span><br><span class="line">    &#125;</span><br><span class="line">&#96;)</span><br><span class="line">function Hexo(id, name, age) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">var root &#x3D; &#123;</span><br><span class="line">    hexo: (&#123;</span><br><span class="line">        id</span><br><span class="line">    &#125;) &#x3D;&gt; &#123;</span><br><span class="line">        return new Hexo(id, &#39;abc&#39;, 12);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>在 query 参数列表也要和 schema 定义一致；同时 root 中获取传入的参数需要通过<strong>解构</strong>来获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query&#123;</span><br><span class="line">    hexo(ids:ID):Hexo</span><br><span class="line">&#125;</span><br><span class="line">&quot;message&quot;: &quot;Unknown argument \&quot;id\&quot; on field \&quot;hexo\&quot; of type \&quot;Query\&quot;. Did you mean \&quot;ids\&quot;?&quot;</span><br></pre></td></tr></table></figure><h2 id="Aliases-别名"><a href="#Aliases-别名" class="headerlink" title="Aliases 别名"></a>Aliases 别名</h2><p>query 通过类似泛型的说明（不知是否恰当），自定义返回数据的对象字段。<br><img src="/legacy/2018/08/22/graphQL-quickstart/alias.png" class=""></p><p><strong>注意</strong><br>对象，字段属性都是可以起别名的</p><h2 id="Fragments-片段"><a href="#Fragments-片段" class="headerlink" title="Fragments 片段"></a>Fragments 片段</h2><p>类似上面那个需求，可能我们都很多复杂的字段，可以通过这种片段的方式简化 gql 代码。同时 fragments 又是依托于对象，理解 query 更为快速<br><img src="/legacy/2018/08/22/graphQL-quickstart/fragment.png" class=""></p><h2 id="Inline-Fragments"><a href="#Inline-Fragments" class="headerlink" title="Inline Fragments"></a>Inline Fragments</h2><p>query 中，行内片段。多用于 interface 的数据</p><h2 id="Operation-name-操作说明"><a href="#Operation-name-操作说明" class="headerlink" title="Operation name 操作说明"></a>Operation name 操作说明</h2><p>用于<strong>query, mutation, or subscription and describes</strong>，说明本次操作的意图。当然像 query，也可以省略 operation name（类似匿名查询）。<br>主要作用，更语义的说明 query 是干啥的，也在调试服务端时，分析 gql logger。<br><img src="/legacy/2018/08/22/graphQL-quickstart/operationName.png" class=""></p><h2 id="Variables-变量"><a href="#Variables-变量" class="headerlink" title="Variables 变量"></a>Variables 变量</h2><p>上些例子，都是在 query 的 fields 上配置参数，并且参数是写死的。通常在实际应用上，我们需要动态可变的参数。<br>可以看下图中\$input:<br><img src="/legacy/2018/08/22/graphQL-quickstart/variables.png" class=""></p><ul><li>在 query 中，使用<strong>\$variableName</strong>类似占位符一样，定义静态值</li><li>在 query 上，声明<strong>\$variableName</strong>。</li><li>维护请求字段 variableName，传入数据</li></ul><p><strong>注意</strong></p><ul><li>声明参数，<strong>需要用\$前缀说明</strong></li><li>\$episode: Episode = JEDI 方式定义输入参数默认值</li></ul><h2 id="Directives-指令"><a href="#Directives-指令" class="headerlink" title="Directives 指令"></a>Directives 指令</h2><p>可以制定 fields 中字段的显示，如果 field 中某个字段是对象，可以在指令后面继续和 field 定义字段方式一样，定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo(id:$input)&#123;</span><br><span class="line">  id</span><br><span class="line">  name</span><br><span class="line">friend @skip(if: $ignoreAge)&#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@include(if: Boolean) Only include this field in the result if the argument is true</li><li>@skip(if: Boolean) Skip this field if the argument is true.<img src="/legacy/2018/08/22/graphQL-quickstart/directives.png" class=""><strong>注意</strong><br>query 上的参数，需要指定<strong>!</strong></li></ul><h2 id="Mutations-行为改变"><a href="#Mutations-行为改变" class="headerlink" title="Mutations 行为改变"></a>Mutations 行为改变</h2><p>GrapQL 是查询语句，但是避免不了某些查询会持久化数据或者更改，像 crud 里面的 create，update，delete 等情况。为区别 query，可以使用 mutations，就是体现这种约定。<br><img src="/legacy/2018/08/22/graphQL-quickstart/mutations.png" class=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let schema &#x3D; buildSchema(&#96;</span><br><span class="line">    type Hexo&#123;</span><br><span class="line">        id:ID,</span><br><span class="line">        name:String,</span><br><span class="line">        age:Int,</span><br><span class="line">        friend:Hexo</span><br><span class="line">    &#125;</span><br><span class="line">    type Mutation&#123;</span><br><span class="line">        createHexo:Hexo</span><br><span class="line">    &#125;</span><br><span class="line">&#96;)</span><br><span class="line">var root &#x3D; &#123;</span><br><span class="line">    createHexo: () &#x3D;&gt; &#123;</span><br><span class="line">        return new Hexo(444, &#39;bbb&#39;, 44);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>搞清 mutation 和 query 区别，通常 mutation 也有自己的 mutation fields。<strong>mutation fields 是依次执行，而 query 的 fields 是并列</strong></p><h2 id="Meta-fields"><a href="#Meta-fields" class="headerlink" title="Meta fields"></a>Meta fields</h2><p>query 增加<strong>_typename</strong>，将返回 schema 的 type<br><img src="/legacy/2018/08/22/graphQL-quickstart/meta.png" class=""></p><h1 id="Schemas-and-Types"><a href="#Schemas-and-Types" class="headerlink" title="Schemas and Types"></a><a href="http://graphql.github.io/learn/schema/" target="_blank" rel="noopener">Schemas and Types</a></h1><h2 id="Type-system"><a href="#Type-system" class="headerlink" title="Type system"></a>Type system</h2><p>这是个简单的 query 语句，但能看到如下特点：</p><ul><li>定义一个根对象，如果你隐去 query 和 operation name</li><li>设置一个 hexo，当做 fields</li><li>根据查询的数据对象，将包含 id、name fields</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query queryHexo&#123;</span><br><span class="line">  hexo&#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-types-and-fields"><a href="#Object-types-and-fields" class="headerlink" title="Object types and fields"></a>Object types and fields</h2><p>在 schems 中,定义 Hexo 这样一个 type，在 Query 中会使用到这个 type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Hexo&#123;</span><br><span class="line">    id:ID,</span><br><span class="line">    name:String,</span><br><span class="line">    age:Int</span><br><span class="line">&#125;</span><br><span class="line">type Query&#123;</span><br><span class="line">    hexo(id:ID):Hexo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Hexo</strong> GraphQL Object Type</li><li>id,name,age 作为 fields，在 Type 里</li><li>每个 field 将对应有 scalar types</li></ul><h2 id="Scalar-types"><a href="#Scalar-types" class="headerlink" title="Scalar types"></a>Scalar types</h2><p>fields 在解析时，会有对应的类型作为区分。</p><ul><li>Int: A signed 32‐bit integer.</li><li>Float: A signed double-precision floating-point value.</li><li>String: A UTF‐8 character sequence.</li><li>Boolean: true or false.</li><li>ID: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an ID signifies that it is not intended to be human‐readable.</li></ul><h2 id="Enumeration-types"><a href="#Enumeration-types" class="headerlink" title="Enumeration types"></a>Enumeration types</h2><p>枚举类型，有个好处：对于已知的后台枚举数据，可以预先控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Action&#123;</span><br><span class="line">    superman,</span><br><span class="line">    people</span><br><span class="line">&#125;</span><br><span class="line">type Hexo&#123;</span><br><span class="line">    id:ID,</span><br><span class="line">    name:String,</span><br><span class="line">    age:Int,</span><br><span class="line">    action:Action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lists-and-Non-Null"><a href="#Lists-and-Non-Null" class="headerlink" title="Lists and Non-Null"></a>Lists and Non-Null</h2><p>定义数据列表、非空类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Hexo&#123;</span><br><span class="line">    name:String!,</span><br><span class="line">    friends:[Hexo]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p>了解面向对象，基本知道抽象，实现之类的概念。<br>这里 GraphQL 也有这样的思想，如下：<br>可以定义一个 Animal，然后 Hexo，People 分别对 Animal 实现，并且扩展，有什么好处？<br><strong>在不同查询结果中，可以维护不同的 type</strong>，来获取指定的对象数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Query&#123;</span><br><span class="line">    hexo(id:ID):People</span><br><span class="line">&#125;</span><br><span class="line">interface Animal&#123;</span><br><span class="line">    id:ID</span><br><span class="line">&#125;</span><br><span class="line">type Hexo implements Animal&#123;</span><br><span class="line">    id:ID,</span><br><span class="line">    name:String,</span><br><span class="line">    age:Int,</span><br><span class="line">    friends:[Hexo]!</span><br><span class="line">&#125;</span><br><span class="line">type People implements Animal&#123;</span><br><span class="line">    id:ID,</span><br><span class="line">    name:String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Union-types"><a href="#Union-types" class="headerlink" title="Union types"></a>Union types</h2>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> graphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex 弹性布局</title>
      <link href="/legacy/2018/08/20/css-flex/"/>
      <url>/legacy/2018/08/20/css-flex/</url>
      
        <content type="html"><![CDATA[<p>传统布局通过 position，float，display 来实现各种排版，但如果要更“简便”，“高效”的实现某些布局，可能 flex 是个好选择。<br>flex 弹性布局，我没怎么用过，也这是写这篇的文章的主要目的，重在熟悉它。虽然我们的 PC 端依旧在<strong>各种无脑数据</strong>暗示下还要兼容 IE8，但还是要对未来有信息。</p><h2 id="flex-简介"><a href="#flex-简介" class="headerlink" title="flex 简介"></a>flex 简介</h2><p>Flexbox Layout 是 W3C 前几年推出的一种布局方式，其意更高效的实现页面布局，在未知布局的高宽等因素下弹性的适应页面。</p><img src="/legacy/2018/08/20/css-flex/caniuse.png" class="" title="兼容性"><p><a href="https://caniuse.com/#feat=flexbox" target="_blank" rel="noopener">如上图，兼容性</a>在国内可能不太友好，你懂的。</p><p>flex 不是一个简单的属性参数，定义 flex 的元素相当于一个容器，可称为 flex container，内部子项称为 flex items。<br>一个标准有规则的布局通常有排列方向，通过 flex-flow direction 定义，下图主要介绍 flex 的主要核心：<br><img src="/legacy/2018/08/20/css-flex/flexbox.png" class=""></p><ul><li>main axis：主轴，串起 flexbox 内部 item 元素。当然不一定是水平，根据 flex-direction 改变。</li><li>main-start/end：flexbox 容器内 item 所在的位置</li><li>main size：flex item 的宽高的大小</li><li>cross axis：纵轴，相对于 main axis</li><li>cross-start/end：相对于 main-start/end</li><li>cross size：flex item 的宽高的大小</li></ul><h2 id="flex-container"><a href="#flex-container" class="headerlink" title="flex container"></a>flex container</h2><p>可在 flex 父容器定义的属性</p><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>当定义 flex 时，及时 block 元素也将按照弹性布局的那种 direction 来呈现。</p><img src="/legacy/2018/08/20/css-flex/display.png" class="" title="定义flex的区别"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex-container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>定义 items 在 main-axis 或者 cross-axis 的排列方向</p><img src="/legacy/2018/08/20/css-flex/flex-direction.png" class="" title="flex-direction"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><img src="/legacy/2018/08/20/css-flex/flex-direction2.png" class=""><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>当 items 的宽度超过 container 的宽度，将选择是否换行显示</p><img src="/legacy/2018/08/20/css-flex/flex-wrap.png" class="" title="flex-wrap"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure><p><strong>注意，如果定义 nowrap，即使 item 有 width，也会被 container 做自适应，也就是 item 定义的 width 无效</strong></p><img src="/legacy/2018/08/20/css-flex/flex-wrap2.png" class=""><h3 id="flex-flow-flex-direction-flex-wrap"><a href="#flex-flow-flex-direction-flex-wrap" class="headerlink" title="flex-flow(flex-direction+flex-wrap)"></a>flex-flow(flex-direction+flex-wrap)</h3><p>简写语法糖，就像 border，backgound 一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;</span><br><span class="line">flex-flow: row | row-reverse | column | column-reverse || nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>内容（水平）排版间隔<br><img src="/legacy/2018/08/20/css-flex/justify-content.png" class="" title="justify-content"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 默认，从左开始排版</li><li>flex-end: 默认，从右开始排版，注意和<strong>flex-direction: row-reverse</strong>的不同</li><li>center：居中</li><li>space-between：每个 item 左右距离平均分配，首末 item 紧贴边缘</li><li>space-around：每个 item 左右距离平均分配，首末 item 距离边缘是 items 之前距离的一半</li><li>space-evenly：main axis 的 main-start 到 item，item 到 end 中间的间距一致。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content" target="_blank" rel="noopener">兼容不太友好</a></li></ul><img src="/legacy/2018/08/20/css-flex/justify-content2.png" class=""><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>（纵向）对齐方式<br><img src="/legacy/2018/08/20/css-flex/align-items.png" class="" title="align-items"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><ul><li>flex-start：cross-start 开始排列</li><li>flex-end：cross-end 开始排列</li><li>center：垂直居中</li><li>baseline：按照基准线</li><li>stretch：垂直平铺</li></ul><img src="/legacy/2018/08/20/css-flex/align-items2.png" class=""><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>大致相对于 justify-content<br><img src="/legacy/2018/08/20/css-flex/align-content.png" class="" title="align-content"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><ul><li>flex-start: cross-start 开始排列</li><li>flex-end: cross-end 开始排列</li><li>center：上下内容均等，items 中间无缝隙</li><li>space-between：上下紧贴，中间 items 均分高度</li><li>space-around：每个 item 上下距离平均分配，首末 item 距离边缘是 items 之前距离的一半</li><li>stretch：高度平铺沾满<img src="/legacy/2018/08/20/css-flex/align-content2.png" class=""></li></ul><h2 id="flex-item"><a href="#flex-item" class="headerlink" title="flex item"></a>flex item</h2><p>针对 flex 子元素项</p><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>指定 item 的顺序自定义</p><img src="/legacy/2018/08/20/css-flex/order.png" class="" title="order"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order: &lt;integer&gt;; &#x2F;* default is 0 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>定义 item 和其他 item 的倍数关系</p><img src="/legacy/2018/08/20/css-flex/flex-grow.png" class="" title="flex-grow"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-grow: &lt;number&gt;; &#x2F;* default 0 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>flex-grow 的反义词，收缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-shrink: &lt;number&gt;; &#x2F;* default 1 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>特殊指定 item 的 size，可以（半分比、rem、px 等形式）。auto 将根据 main-size 分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-basis: &lt;length&gt; | auto; &#x2F;* default auto *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>语法糖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]&#x2F;&#x2F;Default is 0 1 auto</span><br></pre></td></tr></table></figure><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>和 align-items 相同，只是针对单个 item<br><img src="/legacy/2018/08/20/css-flex/align-self.png" class="" title="align-self"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h3><img src="/legacy/2018/08/20/css-flex/example1.png" class=""><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><img src="/legacy/2018/08/20/css-flex/example2.png" class=""><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><img src="/legacy/2018/08/20/css-flex/example3.png" class=""><h2 id="适配问题"><a href="#适配问题" class="headerlink" title="适配问题"></a>适配问题</h2><p>需要添加浏览器前缀，当然如果你使用预编译 css 工具，基本可以自动生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">display: -moz-box;</span><br><span class="line">display: -ms-flexbox;</span><br><span class="line">display: -webkit-flex;</span><br><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">-webkit-box-flex: $values;</span><br><span class="line">-moz-box-flex:  $values;</span><br><span class="line">-webkit-flex:  $values;</span><br><span class="line">-ms-flex:  $values;</span><br><span class="line">flex:  $values;</span><br><span class="line"></span><br><span class="line">-webkit-box-ordinal-group: $val;</span><br><span class="line">-moz-box-ordinal-group: $val;</span><br><span class="line">-ms-flex-order: $val;</span><br><span class="line">-webkit-order: $val;</span><br><span class="line">order: $val;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">Flex css tricks</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程–阮一峰</a>)<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noopener">Flex–mozilla</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 浮动[译]</title>
      <link href="/legacy/2018/08/19/css-float/"/>
      <url>/legacy/2018/08/19/css-float/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://css-tricks.com/all-about-floats/" target="_blank" rel="noopener">原文链接</a></p></blockquote><h2 id="什么是-Float"><a href="#什么是-Float" class="headerlink" title="什么是 Float"></a>什么是 Float</h2><p>Float 是 CSS 用于定位的属性。为了彻底明白它意图和来源，可以参考印刷设计。在印刷布局中，通常图片会有被包裹在文本里的需求。这通常称之为“图文混排（字体环绕）”，如下图：</p><img src="/legacy/2018/08/19/css-float/print-layout.png" class=""><p>在页面布局程序设定中，页面的框子可以控制文本是否遵循字体环绕。忽略字体环绕将使得单词在图片上方流过，就像它甚至不存在一样。这是图片是否是流动于页面一部分的区别。网页设计非常相似。</p><img src="/legacy/2018/08/19/css-float/web-text-wrap.png" class=""><p>在网页设计中，页面元素依托 css 的 float 属性，使得图片被排版在文字里。<strong>浮动的元素依旧是网页流式的一部分</strong>。和绝对定位是有区别的。绝对定位的元素脱离页面流式布局，如同排版布局中告诉程序页面去忽略文字。绝对定位的元素不会影响其他元素，无论是否紧挨着接触。</p><p>浮动代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#sidebar &#123;</span><br><span class="line">  float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常 float 有四个合法值，left、right 更别是元素方向定位。none(默认值)定义元素不适用 float，inherit 跟随父元素的浮动值。</p><h2 id="Float-使用场景？"><a href="#Float-使用场景？" class="headerlink" title="Float 使用场景？"></a>Float 使用场景？</h2><p>除了之前说的字体环绕图片，float 通常用于 web 页面的布局。</p><img src="/legacy/2018/08/19/css-float/web-layout.png" class=""><p>float 在小范围的布局也非常使用。拿页面一个小区域举例：如果我们需要浮动图像，当图片尺寸改变时该区域盒子内的文字将重新渲染自适应。</p><img src="/legacy/2018/08/19/css-float/reflow-example-1.png" class=""><p>当然同样的效果 relative 定位和 absolute 定位也可以实现，但是该区域内的文本不会重新渲染并自适应。</p><img src="/legacy/2018/08/19/css-float/reflow-example-2.png" class=""><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>float 的类似元素是 clear。设置了 clear 的元素不会随意移动到浮动元素周边，而是会排在浮动元素之下，图例将更好的说明：</p><img src="/legacy/2018/08/19/css-float/unclearedfooter.png" class=""><p>上例，侧边栏定义 right float 并且比内容局域短。页脚则会移动到浮动元素后的空缺位置。为了修复这个问题，定义 clear 使得页脚待到内容和侧边栏之下这个位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2018/08/19/css-float/clearedfooter.png" class=""><p>clear 也有四个值。both 是最为常用，可以清除任意方向的浮动。left,right 用于清除指定方向的浮动。none 默认值，无清除效果。inherit 在 IE 中支持不友好。</p><img src="/legacy/2018/08/19/css-float/directionalclearing.png" class=""><h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><p>使用 float 最容易疑惑的问题是怎么让包裹浮动元素的父元素有效。如果父元素不含其它元素但只有浮动元素，其高度将一定塌陷。如果没有明显的背景色等参照很难发现这个问题。</p><img src="/legacy/2018/08/19/css-float/collapse.png" class=""><p>塌陷现象有点反人类，如下例子可能更为糟糕：</p><img src="/legacy/2018/08/19/css-float/whywecollapse.png" class=""><p>block 元素如果已经自适应 float 元素，我们将遇到两个段落之间不自然的空隙，没有什么好方法修复。遇到这样的问题，我们的设计师将崩溃。</p><p>塌陷现象在浏览器布局问题中是极其常见的，需要在容器中的浮动元素之后和容器闭合之前来解决处理此类问题。</p><h2 id="清除浮动的技巧"><a href="#清除浮动的技巧" class="headerlink" title="清除浮动的技巧"></a>清除浮动的技巧</h2><p>如果你处理这类问题当提前知道随后元素是什么，你可以使用 clear:both 来解决问题。这样不需要特殊修改和额外的标签处理。当然万事不会那样顺利，我们需要更多的清除浮动的工具类。</p><h3 id="使用空的-Div-清空元素"><a href="#使用空的-Div-清空元素" class="headerlink" title="使用空的 Div 清空元素"></a>使用空的 Div 清空元素</h3><p>一个空的 div:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear: both;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>当然你可以使用其他标签如<br>，但是 div 是最为常见的，浏览器也没有针对它有特殊样式，指定功能，同时我们也不会对其做全局 css 处理。这个方法会被语义“信徒”认为是可笑的，在页面中无任何含义。虽然不能说他们错，但是我们这样做没有对页面造成影响。</p><h3 id="使用-Overflow"><a href="#使用-Overflow" class="headerlink" title="使用 Overflow"></a>使用 Overflow</h3><p>在父元素上定义 overflow 溢出属性。如果将其设置为 auto、hidden，包含浮动的父元素将立竿见影地清除浮动。堪称优雅的方式，不需要添加额外标签。而然如果你发现如果在原有页面基础上又添加一个 div 来运用此方法，将等同于非语义的 div 方式，并且效果不会很好。<strong>记住 overflow 不是专门用来清除浮动的，当心不要隐藏内容或者触发非预期的滚动条</strong>。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>添加一个 css 伪元素(pseudo selector)，如：:after。相比添加 overflow 在父元素上，你可以添加“.clearfix”来使用这个方法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'.'</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将用一个很小的真实存在的内容区域放在需要解决浮动问题的父元素中。当然这不是全部代码，如果你想兼容一些其他版本的浏览器。</p><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>不同场景需要不同的清除浮动的方法，如下（处理不同类型的网格块）：</p><img src="/legacy/2018/08/19/css-float/grid-blocks.png" class=""><p>为了更好的展示相同的块，我们想要每个颜色相同则重启一行。对于这个需求，当颜色改变时，我们可以使用 overflow、伪类方式。或者在每个颜色相同的组下使用 div 方式，当然不管添加三个充当父类的 div 或者额外添加的三个 div，你自己决定那个更好？</p><img src="/legacy/2018/08/19/css-float/grid-blocks-cleared.png" class=""><h2 id="float-问题（浏览器兼容）"><a href="#float-问题（浏览器兼容）" class="headerlink" title="float 问题（浏览器兼容）"></a>float 问题（浏览器兼容）</h2><p>float 总是会因为没考虑周全而显得解决地很鸡肋。这种脆弱性通常来自 ie6 和浮动相关的 bug。全世界都在放弃 ie6 的支持，可能你不关心，但对于关心的人来说会出现很多问题。</p><h3 id="顶掉其他元素"><a href="#顶掉其他元素" class="headerlink" title="顶掉其他元素"></a>顶掉其他元素</h3><p>发生在当一个元素在一个比他更窄的浮动元素内部（图片居多）。绝大多数浏览器将渲染这个图片到浮动元素外，但不会差得很多。ie 将扩展浮动元素包裹其中的图片，这就会影响布局。会把其他元素往下挤掉</p><img src="/legacy/2018/08/19/css-float/pushdown2.png" class=""><p>解决这个问题：你可以使用<strong>overflow:hidden</strong>来解除多余的部分。</p><h3 id="边距扩大"><a href="#边距扩大" class="headerlink" title="边距扩大"></a>边距扩大</h3><p>使用 ie6 另一件事是，如果在 float 同一方向上使用 margin，将使得双倍的 margin。<br>解决这个问题：设置<strong>display:inline</strong>在浮动元素上，它依旧保持 block 元素特性。</p><h3 id="3px-坑"><a href="#3px-坑" class="headerlink" title="3px 坑"></a>3px 坑</h3><p>当文字旁是浮动元素，其间的 3px 将被神奇的抹去。<br>解决这个问题：浮动元素上额外设置长宽。</p><h3 id="底部-margin-bug"><a href="#底部-margin-bug" class="headerlink" title="底部 margin bug"></a>底部 margin bug</h3><p>ie7 上，父浮动元素内包含子浮动元素，子元素的 bottom margin 将失效。<br>解决这个问题：更为换 padding。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>如果想实现图文混排，float 外没有第二选择。当然你可以查看<a href="http://blog.ideashower.com/post/15139639050/css-text-wrapper" target="_blank" rel="noopener">rather clever technique</a>，将文本包裹在非规则的形状内。对于页面局部当然还有其他方案，可查看<a href="https://alistapart.com/article/fauxabsolutepositioning" target="_blank" rel="noopener">Faux Absolute Positioning</a>，关于 css3 实现更好的布局方式<br><a href="https://www.w3.org/TR/2009/WD-css3-layout-20090402/" target="_blank" rel="noopener">Template Layout Module</a></p><p><a href="https://css-tricks.com/video-screencasts/42-all-about-floats-screencast/" target="_blank" rel="noopener">作者的视频截图</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 运营商劫持</title>
      <link href="/legacy/2018/08/17/http-hijack/"/>
      <url>/legacy/2018/08/17/http-hijack/</url>
      
        <content type="html"><![CDATA[<p>经常遇到这几个情况：</p><ol><li><p>好端端的一个 web 网站，代码、静态资源都是托管于公司云服务器，但是会遇到几次用户上报有什么红包浮窗（广告），结果我们并没有类似的功能代码</p><img src="/legacy/2018/08/17/http-hijack/hijack2.png" class="" title="拿360举个例子"></li><li><p>App 嵌套我们 H5 页面，但是会发生页面无法展示，或者跳转到某电商推广页<br>app 端日志显示跳转的地址变更为如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinaweibo:&#x2F;&#x2F;cardlist?containerid&#x3D;102803&amp;luicode&#x3D;10000404&amp;lfid&#x3D;yunyi_9999_005</span><br></pre></td></tr></table></figure><ol start="3"><li>在公共网络下（地铁 wifi 等），访问某些网站会被强制跳转下，虽然页面出现，但是 Url 后添加了写参数。甚至有些海外服务器会被屏蔽。</li></ol><blockquote><p>为何会出现这些现象，其实都是运营商做的，称之为 Http 劫持</p></blockquote><h2 id="Http-劫持"><a href="#Http-劫持" class="headerlink" title="Http 劫持"></a><a href="https://baike.baidu.com/item/http劫持/383091" target="_blank" rel="noopener">Http 劫持</a></h2><blockquote><p>HTTP 劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释“错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。</p></blockquote><img src="/legacy/2018/08/17/http-hijack/hijack.png" class="" title="简单说明http劫持（1，运营商缓存数据 2，运营商修改数据）"><h2 id="怎么避免、解决"><a href="#怎么避免、解决" class="headerlink" title="怎么避免、解决"></a>怎么避免、解决</h2><p>虽说这不是我们开发造成的问题，但是为了更好的促使公司业务不受影响，还是提出几个方案</p><h3 id="工信部投诉"><a href="#工信部投诉" class="headerlink" title="工信部投诉"></a>工信部投诉</h3><p>看了几篇 blog 都说是良性部门，不妨一试。不过你要知道投诉的目标是什么。和开发没啥关系。</p><h3 id="http-缓存-https"><a href="#http-缓存-https" class="headerlink" title="http 缓存 https"></a>http 缓存 https</h3><p>最快，最方便。市面上有很多提供 https 的服务商，阿里也有免费的服务。</p><h3 id="代码处理"><a href="#代码处理" class="headerlink" title="代码处理"></a>代码处理</h3><p>参考<a href="http://www.cnblogs.com/coco1s/p/5777260.html" target="_blank" rel="noopener">【前端安全】JavaScript 防 http 劫持与 XSS</a>已经给出了详细点的解决方案</p><p>目前大致发现 2 种方式的劫持</p><ul><li>iframe 嵌套。运营商会把我们网站嵌套于 iframe 下，在 iframe 外添加广告浮窗内容</li><li>body 注入广告代码。查看问题页面源码，会莫名多出非本站的 html 标签，或者引入了第三方 script</li></ul><p>解决流程（伪代码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断父子窗口的location</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.self != <span class="built_in">window</span>.top) &#123;</span><br><span class="line">  <span class="comment">// 非本站地址</span></span><br><span class="line">  <span class="keyword">if</span> (!whiteList) &#123;</span><br><span class="line">    <span class="comment">// 标记hijack flag</span></span><br><span class="line">    <span class="comment">// 重定向，正确地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断script标签</span></span><br><span class="line"><span class="keyword">let</span> sTag = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>);</span><br><span class="line"><span class="comment">// script标签不是白名单维护</span></span><br><span class="line"><span class="keyword">if</span> (sTag != whiteList) &#123;</span><br><span class="line">  <span class="comment">// 标记hijack flag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断body异常注入html</span></span><br><span class="line"><span class="comment">// 可以使用MutationObserver来判断</span></span><br><span class="line"><span class="keyword">var</span> targetNode = <span class="built_in">document</span>.getElementById(<span class="string">'bodyAll'</span>);</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutationsList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.type == <span class="string">'childList'</span>) &#123;</span><br><span class="line">      <span class="comment">// A child node has been added or removed.</span></span><br><span class="line">      <span class="comment">// mutation.addedNodes 获取添加的Node信息</span></span><br><span class="line">      <span class="built_in">console</span>.log(mutation.addedNodes[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 判断是否非法</span></span><br><span class="line">      <span class="comment">// 标记hijack flag</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.type == <span class="string">'attributes'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The '</span> + mutation.attributeName + <span class="string">' attribute was modified.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(targetNode, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span>,</span><br><span class="line">  childList: <span class="literal">true</span>,</span><br><span class="line">  subtree: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="日志上报"><a href="#日志上报" class="headerlink" title="日志上报"></a>日志上报</h3><p>代码处理方式中，上述多处记录了 hijack flag，可以专门写个上报的接口，用于记录那些非法链接等信息。用于对未来更好的处理劫持问题作参考。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/coco1s/p/5777260.html" target="_blank" rel="noopener">【前端安全】JavaScript 防 http 劫持与 XSS</a><br><a href="http://m635674608.iteye.com/blog/2342832" target="_blank" rel="noopener">关于 DNS、HTTP 劫持的一些事</a><br><a href="https://juejin.im/post/59ba146c6fb9a00a4636d8b6" target="_blank" rel="noopener">深入理解 Http 请求、DNS 劫持与解析</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node 版本升级还需谨慎</title>
      <link href="/legacy/2018/08/16/node-version-check/"/>
      <url>/legacy/2018/08/16/node-version-check/</url>
      
        <content type="html"><![CDATA[<p>给 2 年前的一台机子做 node 升级（4.4 to 8.11），结果报了如下错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23o1c307rZ ~]# node -v</span><br><span class="line">node: &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6: version &#96;GLIBCXX_3.4.10&#39; not found (required by node)</span><br><span class="line">node: &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6: version &#96;GLIBCXX_3.4.11&#39; not found (required by node)</span><br><span class="line">node: &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6: version &#96;CXXABI_1.3.3&#39; not found (required by node)</span><br><span class="line">node: &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6: version &#96;GLIBCXX_3.4.9&#39; not found (required by node)</span><br></pre></td></tr></table></figure><p>原因该 Node 缺少某些依赖库，然后这些库是系统自带（开发根本不涉足这些玩意儿，我不会升级安装这些 lib）</p><p>关键，问运维，也不造，呵呵哒。</p><blockquote><p>所以如果服务器需要更新 node 版本，请先确定可行性</p></blockquote><p>但不能止步不前，还是能吸收一些知识点</p><h2 id="libstdc"><a href="#libstdc" class="headerlink" title="libstdc++"></a><a href="https://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.what" target="_blank" rel="noopener">libstdc++</a></h2><p>注意到上例的错误，都提到了 libstdc++，那是什么呢？</p><h3 id="什么是-libstdc"><a href="#什么是-libstdc" class="headerlink" title="什么是 libstdc++"></a>什么是 libstdc++</h3><p>一个符合 GUN 规范标准的 C++库</p><h3 id="为何要用-libstdc"><a href="#为何要用-libstdc" class="headerlink" title="为何要用 libstdc++"></a>为何要用 libstdc++</h3><p>GUN(Gun compiler collection，也可叫做 gcc、g++)编译器，其被应用于 libstdc++。<br>很简单，Node 底层是 C 写的，当然需要这类库的支持</p><h3 id="出现如上错误，如何处理？"><a href="#出现如上错误，如何处理？" class="headerlink" title="出现如上错误，如何处理？"></a>出现如上错误，如何处理？</h3><p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.how_to_install" target="_blank" rel="noopener">可参考</a></p><ol><li><a href="https://gcc.gnu.org/mirrors.html" target="_blank" rel="noopener">下载 gcc source</a></li><li>make gcc</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get gcc sources</span><br><span class="line">extract into gccsrcdir</span><br><span class="line">mkdir gccbuilddir</span><br><span class="line">cd gccbuilddir</span><br><span class="line">gccsrcdir&#x2F;configure --prefix&#x3D;destdir --other-opts...</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="不同-Node-适合哪些-linux-的系统"><a href="#不同-Node-适合哪些-linux-的系统" class="headerlink" title="不同 Node 适合哪些 linux 的系统"></a>不同 Node 适合哪些 linux 的系统</h2><p>翻阅 Node doc，暂时没发现对系统有什么明显的说明，对于这个错误只是系统级别上缺少依赖包，说白了就是系统<strong>太老了</strong></p><p><a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">不过还可以参考</a><br><a href="https://github.com/nodesource/distributions" target="_blank" rel="noopener">不过还可以参考 nodesource distributions</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/haibosdu/article/details/77094833" target="_blank" rel="noopener">https://blog.csdn.net/haibosdu/article/details/77094833</a><br><a href="https://stackoverflow.com/questions/16605623/where-can-i-get-a-copy-of-the-file-libstdc-so-6-0-15" target="_blank" rel="noopener">`GLIBCXX_3.4.10’ not found</a><br><a href="https://askubuntu.com/questions/575505/glibcxx-3-4-20-not-found-how-to-fix-this-error" target="_blank" rel="noopener">https://askubuntu.com/questions/575505/glibcxx-3-4-20-not-found-how-to-fix-this-error</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo 用问题记录</title>
      <link href="/legacy/2018/08/14/mongo-problem/"/>
      <url>/legacy/2018/08/14/mongo-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="未维护数据库存放位置，mongod-未启动起来"><a href="#未维护数据库存放位置，mongod-未启动起来" class="headerlink" title="未维护数据库存放位置，mongod 未启动起来"></a>未维护数据库存放位置，mongod 未启动起来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf637zf5euwjrr6z5xdyz mydata]# mongod</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] MongoDB starting : pid&#x3D;18023 port&#x3D;27017 dbpath&#x3D;&#x2F;data&#x2F;db 64-bit host&#x3D;izuf637zf5euwjrr6z5xdyz</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] db version v3.4.10</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] git version: 078f28920cb24de0dd479b5ea6c66c644f6326e9</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] modules: none</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] build environment:</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class="line">2018-08-13T18:44:28.035+0800 I STORAGE  [initandlisten] exception in initAndListen: 29 Data directory &#x2F;data&#x2F;db not found., terminating</span><br><span class="line">2018-08-13T18:44:28.035+0800 I NETWORK  [initandlisten] shutdown: going to close listening sockets...</span><br><span class="line">2018-08-13T18:44:28.035+0800 I NETWORK  [initandlisten] shutdown: going to flush diaglog...</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2018-08-13T18:44:28.035+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure><h2 id="自定义匹配文件，启动失败"><a href="#自定义匹配文件，启动失败" class="headerlink" title="自定义匹配文件，启动失败"></a>自定义匹配文件，启动失败</h2><p>原因同上，可查看 mongo.log 解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf637zf5euwjrr6z5xdyz ~]# mongod -f  &#x2F;mydata&#x2F;mongo&#x2F;conf&#x2F;mongod.conf</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 18036</span><br><span class="line">ERROR: child process failed, exited with error number 100</span><br></pre></td></tr></table></figure><h2 id="添加-Role-失败"><a href="#添加-Role-失败" class="headerlink" title="添加 Role 失败"></a>添加 Role 失败</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createUser(&#123;</span><br><span class="line">... user:&quot;xxxxx&quot;,</span><br><span class="line">... pwd:&quot;xxxxx&quot;,</span><br><span class="line">... roles:[&#123;</span><br><span class="line">... role:&quot;readWriteAnyDatabase&quot;,</span><br><span class="line">... db:&quot;xxx&quot;</span><br><span class="line">... &#125;]&#125;)</span><br><span class="line">2018-08-14T11:37:55.993+0800 E QUERY    [thread1] Error: couldn&#39;t add user: No role named readWriteAnyDatabase@xxx :</span><br><span class="line">_getErrorWithCode@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:25:13</span><br><span class="line">DB.prototype.createUser@src&#x2F;mongo&#x2F;shell&#x2F;db.js:1292:15</span><br><span class="line">@(shell):1:1</span><br></pre></td></tr></table></figure><p>查看是否 role 定义错误，<a href="https://docs.mongodb.com/manual/reference/built-in-roles/#all-database-roles" target="_blank" rel="noopener">虽然官网定义如下 Role，<strong>但是用于 admin database</strong>，具体还要辨别：</a></p><ul><li>readAnyDatabase</li><li>readWriteAnyDatabase</li><li>userAdminAnyDatabase</li><li>dbAdminAnyDatabase</li></ul><p><a href="https://docs.mongodb.com/manual/reference/built-in-roles/#database-user-roles" target="_blank" rel="noopener">更多 Role</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo 数据库的备份迁移</title>
      <link href="/legacy/2018/08/14/mongo-backup/"/>
      <url>/legacy/2018/08/14/mongo-backup/</url>
      
        <content type="html"><![CDATA[<p>因为云服务器更换，所以牵扯到要备份数据库到新服务器。记录一笔</p><h2 id="备份并导出库——mongodump"><a href="#备份并导出库——mongodump" class="headerlink" title="备份并导出库——mongodump"></a>备份并导出库——<a href="https://docs.mongodb.com/manual/reference/program/mongodump/" target="_blank" rel="noopener">mongodump</a></h2><p>配置权限链接本地库，配置输出位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h 127.0.0.1:27017 --db 数据库名称 --out 备份输出位置 -u 用户名 -p 密码</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong><br><a href="https://docs.mongodb.com/manual/reference/program/mongodump/#options" target="_blank" rel="noopener">更多详见官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line"></span><br><span class="line">--verbose, -v</span><br><span class="line">    输出日志</span><br><span class="line"></span><br><span class="line">--quite</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line"></span><br><span class="line">--uri</span><br><span class="line">    eg:mongodb:&#x2F;&#x2F;[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][&#x2F;[database][?options]]</span><br><span class="line">    通过uri可以简化mongodump配置（合在--uri定义）[URI参数说明](https:&#x2F;&#x2F;docs.mongodb.com&#x2F;manual&#x2F;reference&#x2F;connection-string&#x2F;)</span><br><span class="line"></span><br><span class="line">--host &lt;hostname&gt;&lt;:port&gt;, -h &lt;hostname&gt;&lt;:port&gt;</span><br><span class="line">    Default: localhost:27017</span><br><span class="line"></span><br><span class="line">--port &lt;port&gt;</span><br><span class="line">    Default: 27017</span><br><span class="line"></span><br><span class="line">--username &lt;username&gt;, -u &lt;username&gt;</span><br><span class="line"></span><br><span class="line">--password &lt;password&gt;, -p &lt;password&gt;</span><br><span class="line"></span><br><span class="line">--authenticationDatabase &lt;dbname&gt;</span><br><span class="line"></span><br><span class="line">--db &lt;database&gt;, -d &lt;database&gt;</span><br><span class="line"></span><br><span class="line">--collection &lt;collection&gt;, -c &lt;collection&gt;</span><br><span class="line">    定义哪些指定collection输出</span><br><span class="line"></span><br><span class="line">--excludeCollection string</span><br><span class="line">    排除某些collection</span><br><span class="line"></span><br><span class="line">--gzip</span><br><span class="line">    压缩输出文件</span><br><span class="line"></span><br><span class="line">--out &lt;path&gt;, -o &lt;path</span><br><span class="line">    输出格式为 BSON files</span><br></pre></td></tr></table></figure><h2 id="导入备份数据库——mongorestore"><a href="#导入备份数据库——mongorestore" class="headerlink" title="导入备份数据库——mongorestore"></a>导入备份数据库——<a href="https://docs.mongodb.com/manual/reference/program/mongorestore/" target="_blank" rel="noopener">mongorestore</a></h2><p>之前需要把备份的数据库迁移到新服务器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore --db 数据库名称 &#x2F;mydata&#x2F;dump&#x2F;xxx</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line"></span><br><span class="line">--verbose, -v</span><br><span class="line"></span><br><span class="line">--quiet</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line"></span><br><span class="line">--uri &lt;connectionString&gt;</span><br><span class="line"></span><br><span class="line">--host &lt;hostname&gt;&lt;:port&gt;, -h &lt;hostname&gt;&lt;:port&gt;</span><br><span class="line"></span><br><span class="line">--port &lt;port&gt;</span><br><span class="line"></span><br><span class="line">--db &lt;database&gt;, -d &lt;database&gt;</span><br><span class="line"></span><br><span class="line">--collection &lt;collection&gt;, -c &lt;collection&gt;</span><br><span class="line"></span><br><span class="line">--drop</span><br><span class="line">    清除备份文件</span><br><span class="line"></span><br><span class="line">--gzip</span><br><span class="line"></span><br><span class="line">&lt;path&gt;</span><br><span class="line">    不能同时定义path和--dir</span><br><span class="line"></span><br><span class="line">--dir string</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 基础学习进阶</title>
      <link href="/legacy/2018/08/10/nginx-basic-learn/"/>
      <url>/legacy/2018/08/10/nginx-basic-learn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容摘自<a href="http://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">nginx 官方文档</a>，自己配合实例更细致的熟悉 nginx</p></blockquote><h1 id="命令启动，停止，重启-配置"><a href="#命令启动，停止，重启-配置" class="headerlink" title="命令启动，停止，重启 配置"></a>命令启动，停止，重启 配置</h1><p>一旦 nginx 运行起来，通过如下方式 invoking nginx 的控制变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop &#x2F;&#x2F; 停服</span><br><span class="line">nginx -s quit &#x2F;&#x2F; 优雅的停服</span><br><span class="line">nginx -s reload &#x2F;&#x2F; 重启配置文件</span><br><span class="line">nginx -s reopen &#x2F;&#x2F; 重新打开log文件</span><br></pre></td></tr></table></figure><h2 id="quit-和-stop-有何区别？"><a href="#quit-和-stop-有何区别？" class="headerlink" title="quit 和 stop 有何区别？"></a>quit 和 stop 有何区别？</h2><p>quit 会等最近一个 request 响应结束后退出进程（graceful shutdown）。<br>比如一个服务会 hold 起数秒，即使执行了 quit 命令，还是会等结果处理完毕后关闭 nginx。<br>stop 则马上停止。</p><h2 id="配置文件错误，reload-是否会影响线上？"><a href="#配置文件错误，reload-是否会影响线上？" class="headerlink" title="配置文件错误，reload 是否会影响线上？"></a>配置文件错误，reload 是否会影响线上？</h2><p>不会，如果 configure 错误，nginx 将 roll back 回老的配置文件，直到配置正确才会真正 reload 起效。</p><h2 id="除了-stop-等，怎么停止-nginx-服务？"><a href="#除了-stop-等，怎么停止-nginx-服务？" class="headerlink" title="除了 stop 等，怎么停止 nginx 服务？"></a>除了 stop 等，怎么停止 nginx 服务？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -ax | grep nginx</span><br><span class="line">26318 ?        Ss     0:00 nginx: master process nginx</span><br><span class="line">26351 ?        S      0:00 nginx: worker process</span><br><span class="line">26357 pts&#x2F;3    R+     0:00 grep --color&#x3D;auto nginx</span><br><span class="line"># 需要停止master进程</span><br><span class="line">kill -s QUIT 26318</span><br></pre></td></tr></table></figure><h2 id="了解更多-nginx-控制命令"><a href="#了解更多-nginx-控制命令" class="headerlink" title="了解更多 nginx 控制命令"></a><a href="http://nginx.org/en/docs/control.html" target="_blank" rel="noopener">了解更多 nginx 控制命令</a></h2><h1 id="nginx-配置文件的结构"><a href="#nginx-配置文件的结构" class="headerlink" title="nginx 配置文件的结构"></a>nginx 配置文件的结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//127.0.0.1:8080;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h1><p>静态文件管理也是 Nginx 最大的特色之一（托管图片资源，静态 HTML 文件）</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>比如如下是个存放静态资源的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;root&#x2F;mydata&#x2F;test&#x2F;www  # 存放html</span><br><span class="line">&#x2F;root&#x2F;mydata&#x2F;test&#x2F;images # 存放资源</span><br></pre></td></tr></table></figure><p><strong>访问静态页面</strong><br>location 指定以 <strong>/</strong> 为前缀（prefix），匹配请求地址的 URI，匹配到的 URI 将添加到 root 指令的地址后。<br>访问：<a href="http://test.eminoda.com:81/test.html" target="_blank" rel="noopener">http://test.eminoda.com:81/test.html</a><br>nginx 按照：/root/mydata/test/www/test.html 输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   &#x2F;root&#x2F;mydata&#x2F;test&#x2F;www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问图片等资源</strong><br>匹配以 <strong>/images/</strong> 开始的资源请求地址，<strong>注意，location / 也是可以匹配到的，但会根据实际路径有优先关系</strong><br>访问：<a href="http://test.eminoda.com:81/images/yuyu.jpg" target="_blank" rel="noopener">http://test.eminoda.com:81/images/yuyu.jpg</a><br>nginx 按照：/root/mydata/test/images/yuyu.jpg 输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">    root &#x2F;root&#x2F;mydata&#x2F;test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="root-和-alias-的区别？"><a href="#root-和-alias-的区别？" class="headerlink" title="root 和 alias 的区别？"></a>root 和 alias 的区别？</h2><table><thead><tr><th>指令</th><th>范围</th></tr></thead><tbody><tr><td>root</td><td>http, server, location, if in location</td></tr><tr><td>alias</td><td>location</td></tr></tbody></table><p>访问：<a href="http://test.eminoda.com:81/versionChange/yuyu.jpg" target="_blank" rel="noopener">http://test.eminoda.com:81/versionChange/yuyu.jpg</a><br>nginx 按照：/root/mydata/test/images/yuyu.jpg 输出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 模拟一种常见，因为某些需求，更改了资源路径，但不能影响原有资源的输出访问</span><br><span class="line">location &#x2F;versionChange&#x2F; &#123;</span><br><span class="line">    alias &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：斜杠问题</strong>，结合上例，比较有何不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;versionChange&#x2F; &#123;</span><br><span class="line">    alias &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images; #error &#x2F;root&#x2F;mydata&#x2F;test&#x2F;imagesyuyu.jpg</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;versionChange &#123;</span><br><span class="line">    alias &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images; #ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么权衡-root-和-alias-的使用？"><a href="#怎么权衡-root-和-alias-的使用？" class="headerlink" title="怎么权衡 root 和 alias 的使用？"></a>怎么权衡 root 和 alias 的使用？</h2><p>如果 location 匹配路径和指令的 value 最后部分相同时，建议使用 root。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">    alias &#x2F;data&#x2F;w3&#x2F;images&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line"># better</span><br><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">    root &#x2F;data&#x2F;w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alias-和-正则匹配问题？"><a href="#alias-和-正则匹配问题？" class="headerlink" title="alias 和 正则匹配问题？"></a>alias 和 正则匹配问题？</h2><p>如果 location 包含 regex expression，就会匹配正则捕获内容，在 alias 中替换<strong>（而非替换整个 location 路径）</strong>。<br>访问：<a href="http://test.eminoda.com:81/yuyu.jpg" target="_blank" rel="noopener">http://test.eminoda.com:81/yuyu.jpg</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^&#x2F;(.+\.(?:gif|jpg|png))$ &#123;</span><br><span class="line">    alias &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images&#x2F;$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<a href="http://test.eminoda.com:81/foo/yuyu.jpg" target="_blank" rel="noopener">http://test.eminoda.com:81/foo/yuyu.jpg</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^&#x2F;foo&#x2F;(.+\.(?:gif|jpg|png))$ &#123;</span><br><span class="line">    alias &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images&#x2F;$1; #error &#x2F;root&#x2F;mydata&#x2F;test&#x2F;images&#x2F;foo&#x2F;yuyu.jpg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置简单的代理-Proxy-服务"><a href="#设置简单的代理-Proxy-服务" class="headerlink" title="设置简单的代理 Proxy 服务"></a><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">设置简单的代理 Proxy 服务</a></h1><p>使用 nginx 代理，可能是解决我们日常开发，服务调用的最大原因</p><p>在了解 proxy 之前，先看下 location 路径匹配</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><table><thead><tr><th>指令</th><th>范围</th><th>语法</th></tr></thead><tbody><tr><td>location</td><td>server, location</td><td>location [ = &#124; ~ &#124; ~* &#124; ^~ ] uri { … }</td></tr></tbody></table><p>location 依赖 request 的 URI。按优先级排序。<br>=: 绝对匹配，exact match<br>~*：正则（忽略大小写），case-insensitive matching<br>~：正则，case-sensitive matching<br>^~：不能和 uri 定义的配置重复，prefix match<br>uri：路径 URI 匹配，uri match</p><p><strong>举个经典的范例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;documents&#x2F; &#123;</span><br><span class="line">    [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ &#x2F;images&#x2F; &#123;</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    [ configuration E ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先命中绝对匹配</li><li>如果有符合 regex 规则，则进入正则匹配。</li><li>剩下根据 uri 匹配</li></ul><p><strong>normalized URI 标准化 URI</strong></p><ul><li>decode 参数</li><li>解析相对路径</li><li>解析斜杠（merge_slashes）</li></ul><p><strong>merge_slashes</strong></p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Syntax</td><td>merge_slashes on &#124; off;</td></tr><tr><td>Default</td><td>merge_slashes on;</td></tr><tr><td>Context</td><td>http, server</td></tr></tbody></table><p>打开 merge_slashes 配置，将允许 //foo 之类多斜杠的路径匹配</p><h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><table><thead><tr><th>指令</th><th>范围</th></tr></thead><tbody><tr><td>proxy_pass</td><td>location, if in location, limit_except</td></tr></tbody></table><p><strong>proxy_pass 定义了 URI 的区别</strong></p><p><a href="http://127.0.0.1:9000/users" target="_blank" rel="noopener">http://127.0.0.1:9000/users</a> 提供服务</p><p><strong>specified without a URI</strong>（忽略 URI）<br>访问：<a href="http://test.eminoda.com:81/users" target="_blank" rel="noopener">http://test.eminoda.com:81/users</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;users &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>request URI 在 location 匹配后，原样传送给 server</p><p><strong>specified with a URI</strong> （指定 URI）<br>访问：<a href="http://test.eminoda.com:81/withinURI/users" target="_blank" rel="noopener">http://test.eminoda.com:81/withinURI/users</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;withinURI&#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:9000&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 proxy_pass is specified with a URI，当 request URI 在 location 命中，URI 将替换被 location 匹配中的 request URI 的 part（注意 location 需要后面维护个/）</p><blockquote><p>If the proxy_pass directive is specified with a URI, then when a request is passed to the server, the part of a normalized request URI matching the location is replaced by a URI specified in the directive</p></blockquote><p><strong>注意：location 需要后面维护个/</strong><br>访问：<a href="http://test.eminoda.com:81/withinURIusers" target="_blank" rel="noopener">http://test.eminoda.com:81/withinURIusers</a> 注意这里故意没有写 <strong>/</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;withinURI &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:9000&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改配置：注意 location 的/</strong><br>访问：<a href="http://test.eminoda.com:81/users" target="_blank" rel="noopener">http://test.eminoda.com:81/users</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;users&#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>浏览器 <a href="http://test.eminoda.com:81/users" target="_blank" rel="noopener">http://test.eminoda.com:81/users</a> 会自动变成 <a href="http://test.eminoda.com:81/users/。原以为浏览器会默认添加，但是错了。" target="_blank" rel="noopener">http://test.eminoda.com:81/users/。原以为浏览器会默认添加，但是错了。</a></p><p>浏览器分别输入/users，当 location /users，浏览器不会默认添加/，而 location /users/ 则会自动添加。感觉像是 location 告诉浏览器你给我变的样子<br>查阅 location 文档：<br>如果 location 规则尾部包含斜杠（location /users/），在响应时会发送 301 永久重定向，地址后面自动加上斜杠（这就是为何浏览器会有斜杠的原因）</p><blockquote><p>If a location is defined by a prefix string that ends with the slash character, and requests are processed by one of proxy_pass, fastcgi_pass, uwsgi_pass, scgi_pass, memcached_pass, or grpc_pass, then the special processing is performed. In response to a request with URI equal to this string, but without the trailing slash, a permanent redirect with the code 301 will be returned to the requested URI with the slash appended.</p></blockquote><h3 id="proxy-pass-有些其他规则，request-URI-不确定被替换更改"><a href="#proxy-pass-有些其他规则，request-URI-不确定被替换更改" class="headerlink" title="proxy_pass 有些其他规则，request URI 不确定被替换更改"></a>proxy_pass 有些其他规则，request URI 不确定被替换更改</h3><p><strong>location 定义正则，同时 proxy_pass 不能定义 URI</strong><br><strong>location 定义中有 rewrite break，后跟 proxy_pass</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;name&#x2F; &#123;</span><br><span class="line">    rewrite    &#x2F;name&#x2F;([^&#x2F;]+) &#x2F;users?name&#x3D;$1 break;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>proxy_pass 使用变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;name&#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><table><thead><tr><th>指令</th><th>范围</th></tr></thead><tbody><tr><td>rewrite</td><td>server, location, if</td></tr></tbody></table><p>rewrite regex replacement [flag];<br>如果正则匹配到 request URI，URI 则会和 replacement 替换</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><blockquote><p>stops processing the current set of ngx_http_rewrite_module directives and starts a search for a new location matching the changed URI;</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;rewrite&#x2F;test1 &#123;</span><br><span class="line">    rewrite ^&#x2F;rewrite &#x2F;last last; #跳出本location，到新的location查找&#x2F;last</span><br><span class="line">    return 404; #并不会输出</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F;last &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test1" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test1</a></strong>，location，rewrite 命中，发起/last 请求，在 location 中继续寻找</p><p><strong>修改配置：location 做如下修改</strong><br>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test1" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test1</a></strong>，location 不会命中，rewrite 则不会匹配到<br>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test1/" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test1/</a></strong>，可以命中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;rewrite&#x2F;test1&#x2F; &#123;</span><br><span class="line">    rewrite ^&#x2F;rewrite &#x2F;last last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和本例无关，只是平时书写 location，要增强路径/的判断。请求地址包含/，则在 location 的规则上写上/，不然就不要添加</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><blockquote><p>stops processing the current set of ngx_http_rewrite_module directives as with the break directive</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;rewrite&#x2F;test2 &#123;</span><br><span class="line">    rewrite ^&#x2F;rewrite&#x2F;test2&#x2F;foo &#x2F;break break;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">&#125;</span><br><span class="line"># 不会执行</span><br><span class="line">location &#x2F;break &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test2" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test2</a></strong>，location 命中，rewrite 未匹配，之后请求 proxy_pass<br>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test2/foo" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test2/foo</a></strong>，location 中 rewrite 命中，发起/break，由于之后是 proxy_pass，则实际访问 <strong><a href="http://127.0.0.1:3001/break" target="_blank" rel="noopener">http://127.0.0.1:3001/break</a></strong><br><strong>和 last 不同，rewrite 匹配后，不会重新寻找 location</strong></p><p>修改配置：结合上例，主要体现 <strong>ngx_http_rewrite_module 这个点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;rewrite&#x2F;test2 &#123;</span><br><span class="line">    rewrite ^&#x2F;rewrite&#x2F;test2&#x2F;foo &#x2F;break break;</span><br><span class="line">    return 500;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test2" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test2</a></strong>，location 匹配，rewrite 未匹配，直接访问 return 返回 500<br>访问 <strong><a href="http://test.eminoda.com:81/rewrite/test2/foo" target="_blank" rel="noopener">http://test.eminoda.com:81/rewrite/test2/foo</a></strong>，location 中 rewrite 命中，发起/break，注意<strong>break 会停止 ngx_http_rewrite_module 模块的指令</strong>，则不会像上例一样，或者 last 寻找新的 location。会在本地寻找 ooxx/break 资源，无则返回 404；</p><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^&#x2F;redirect1 &#x2F; redirect ;</span><br><span class="line">rewrite ^&#x2F;redirect2 http:&#x2F;&#x2F;test.eminoda.com:81 redirect ;</span><br></pre></td></tr></table></figure><p>返回 302 code，如果不以协议“http://”, “https://”, or “\$scheme”开头的匹配，则替换</p><h3 id="permanent"><a href="#permanent" class="headerlink" title="permanent"></a>permanent</h3><blockquote><p>returns a permanent redirect with the 301 code.</p></blockquote><h3 id="ngx-http-rewrite-module"><a href="#ngx-http-rewrite-module" class="headerlink" title="ngx_http_rewrite_module"></a>ngx_http_rewrite_module</h3><ul><li>break</li><li>if</li><li>return</li><li>rewrite</li><li>rewrite_log</li><li>set</li><li>uninitialized_variable_warn</li></ul><p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">了解更多</a></p><h1 id="ngx-http-rewrite-module-1"><a href="#ngx-http-rewrite-module-1" class="headerlink" title="ngx_http_rewrite_module"></a>ngx_http_rewrite_module</h1><p>有如下指令：</p><ul><li>break</li><li>if</li><li>return</li><li>rewrite</li><li>set</li><li><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">…</a></li></ul><p>再次强调</p><ul><li>location 根据 request URI 来匹配</li><li>以上这些 directives 在 location 中将顺序执行</li><li>如果请求被 rewrite 多次，次数至多 10 次</li></ul><h2 id="break-1"><a href="#break-1" class="headerlink" title="break"></a>break</h2><p>停止 <strong>ngx_http_rewrite_module</strong> 语句</p><p>如果在 location 中，则会继续执行之后语句。上面 rewrite 的 break 已经说明过。</p><h2 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if" target="_blank" rel="noopener">if 条件判断</a></h2><p>比较变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ($test &#x3D; 1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if ($test !&#x3D;1 )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则匹配</p><ul><li>~ 匹配大小写；~* 忽略大小写</li><li>!~，!~*：否定判断</li><li>如果正则包含 <strong>} ;</strong> 等结尾符号，需要用引号包裹</li><li>文件判断（file existence）：-f !-f</li><li>目录判断（directory existence）：-d !-d</li><li>文件、目录、超链（file, directory, or symbolic link existence）：-e !-e</li><li>可执行文件（executable file）：-x !-x</li></ul><p><a href="http://test.eminoda.com:82/user" target="_blank" rel="noopener">http://test.eminoda.com:82/user</a><br><a href="http://test.eminoda.com:82/userrr" target="_blank" rel="noopener">http://test.eminoda.com:82/userrr</a><br><a href="http://test.eminoda.com:82/id/123" target="_blank" rel="noopener">http://test.eminoda.com:82/id/123</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set $test 0;</span><br><span class="line">if ( $request_uri !~ \&#x2F;admin)&#123;</span><br><span class="line">    set $test 1;</span><br><span class="line">&#125;</span><br><span class="line">if ( $request_uri ~ &#39;(\&#x2F;use)r&#123;2,3&#125;$&#39;)&#123;</span><br><span class="line">    set $test 2;</span><br><span class="line">&#125;</span><br><span class="line">if ( $request_uri ~* \&#x2F;id\&#x2F;[1-9]+)&#123;</span><br><span class="line">    set $test 3;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:9000&#x2F;$test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;1 404 4.039 ms - 1215</span><br><span class="line">GET &#x2F;2 404 4.609 ms - 1215</span><br><span class="line">GET &#x2F;3 404 4.540 ms - 1215</span><br></pre></td></tr></table></figure><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><ul><li>return http_status</li><li>return http_status URL</li><li>return URL</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prmoise 返回遇到个问题</title>
      <link href="/legacy/2018/08/03/js-promise-return/"/>
      <url>/legacy/2018/08/03/js-promise-return/</url>
      
        <content type="html"><![CDATA[<h2 id="new-Promise-如何-return-Promise"><a href="#new-Promise-如何-return-Promise" class="headerlink" title="new Promise 如何 return Promise"></a>new Promise 如何 return Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'book&gt;&gt;saveBook'</span>, () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> spiderService.getBookBasicInfo().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).not.toBeNull();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在用 Jest 时候，发现无论怎么设置 timeout 总是超时，然后发现如下代码是有问题的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getBookBasicInfo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// create new Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        spider</span><br><span class="line">            .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                    <span class="comment">// some code</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// return Promise,这段有问题</span></span><br><span class="line">                    <span class="keyword">return</span> bookService.saveBook(books);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实应该把 <strong>bookService.saveBook(books)</strong> 获取到 promise 的 resolve 和 reject,给新的 Promise 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">getBookBasicInfo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        spider</span><br><span class="line">            .end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                    <span class="comment">// some code</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// here is right</span></span><br><span class="line">                    bookService.saveBook(books).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                        resolve(data);</span><br><span class="line">                    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(err);</span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 发布公共包</title>
      <link href="/legacy/2018/08/03/npm-publish/"/>
      <url>/legacy/2018/08/03/npm-publish/</url>
      
        <content type="html"><![CDATA[<p>用了那么多 npm 包，那怎么自己上传一个 package 呢？随便一 Baidu 其实都有解决方法，此文只作为个人笔记记录。</p><p><a href="https://docs.npmjs.com/getting-started/publishing-npm-packages" target="_blank" rel="noopener">省去千言万语，你自己点进去看吧</a></p><h1 id="先看看怎么-unpublish"><a href="#先看看怎么-unpublish" class="headerlink" title="先看看怎么 unpublish"></a><a href="https://docs.npmjs.com/cli/unpublish" target="_blank" rel="noopener">先看看怎么 unpublish</a></h1><blockquote><p>It is generally considered bad behavior to remove versions of a library that others are depending on!</p></blockquote><p>我们使用 npm，都是云上的东西，如果你写的玩意正好被他人用着，哪天<strong>种子下不到了</strong>，的确会造成很多人的麻烦。<br>如果真的迫不得已，还是使用 deprecate，<a href="https://www.npmjs.com/policies/unpublish" target="_blank" rel="noopener">了解更多卸载政策？</a>。</p><p>这里只是做个卸载发布的测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除不了</span></span><br><span class="line">E:\my_work\github\myBlog&gt;npm unpublish niu-util@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">npm ERR! code E400</span><br><span class="line">npm ERR! You can no longer unpublish <span class="keyword">this</span> version. Please deprecate it instead</span><br><span class="line">npm ERR! npm deprecate -f <span class="string">'niu-util@*'</span> <span class="string">"this package has been deprecated"</span> : <span class="number">1</span><span class="number">-77</span>fa60bb9a3929ac7ce6b933673ba6bf</span><br><span class="line"><span class="comment">// 使其失效</span></span><br><span class="line">E:\my_work\github\myBlog&gt;npm deprecate niu-util <span class="string">"this is demo"</span></span><br><span class="line"><span class="comment">// 从个人账户删除这个pkg</span></span><br><span class="line">E:\my_work\github\myBlog&gt;npm owner rm eminoda niu-util</span><br><span class="line">- eminoda (niu-util)</span><br></pre></td></tr></table></figure><h1 id="回归正题，怎么上传自己的-pkg"><a href="#回归正题，怎么上传自己的-pkg" class="headerlink" title="回归正题，怎么上传自己的 pkg"></a>回归正题，怎么上传自己的 pkg</h1><ol><li><p>创建一个 npm account<br>自己去网上注册个号，没什么说的</p></li><li><p>登录账号</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\my_work\github\myBlog&gt;npm adduser</span><br><span class="line">Username: eminoda</span><br><span class="line">Password:</span><br><span class="line">Email: (<span class="keyword">this</span> IS public) <span class="number">123456789</span>@qq.com</span><br><span class="line">Logged <span class="keyword">in</span> <span class="keyword">as</span> eminoda on https:<span class="comment">//registry.npmjs.org/.</span></span><br></pre></td></tr></table></figure><ol start="3"><li><a href="https://docs.npmjs.com/getting-started/publishing-npm-packages" target="_blank" rel="noopener">创建&amp;编写 package.json，发布</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"@eminoda/jest-cli"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"simple jest command"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><ol start="4"><li><a href="https://docs.npmjs.com/getting-started/scoped-packages" target="_blank" rel="noopener">当然你也可以自定义 scope</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义scope</span></span><br><span class="line">E:\jest&gt;npm init --scope=eminoda</span><br><span class="line"><span class="comment">// 设置scope</span></span><br><span class="line">E:\jest&gt;npm config <span class="keyword">set</span> scope eminoda</span><br><span class="line">// 如果没有公开，将无法提交</span><br><span class="line">E:\jest&gt;npm publish</span><br><span class="line">npm ERR! publish Failed PUT 402</span><br><span class="line">npm ERR! code E402</span><br><span class="line">npm ERR! You must sign up for private packages : @eminoda/jest-cli</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2018-08-03T15_21_14_351Z-debug.log</span><br><span class="line"></span><br><span class="line">E:\jest&gt;npm publish --access=public</span><br><span class="line">+ @eminoda/jest-cli@0.0.1</span><br></pre></td></tr></table></figure><h1 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h1><p>本来如前言说的，半年前上传过一个 module，那时 Baidu 一贴基本包就上去了。但如果落地到知识的总结还是有很多需要学习的。，现在会考虑更多东西，对应的扩展面也大了。<br>比如：包上传上去，总要考虑如何 delete、update。总看到别人@username 命名的库名…都得到了解答。这 20 分钟收获简单，但意义不小。<br>如果你也看到这里了，<a href="https://www.npmjs.com/package/hexo-jwt" target="_blank" rel="noopener">不妨下载个小包？hexo-jwt</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue 框架学习--基础 js 知识点</title>
      <link href="/legacy/2018/07/11/vue-basic-learn/"/>
      <url>/legacy/2018/07/11/vue-basic-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="前言，目标："><a href="#前言，目标：" class="headerlink" title="前言，目标："></a>前言，目标：</h1><ul><li>加强 js 知识点巩固</li><li>学习 js 技巧</li><li>帮助更好的学习 vue 思想</li></ul><h1 id="关于对象-Object"><a href="#关于对象-Object" class="headerlink" title="关于对象 Object"></a>关于对象 Object</h1><h2 id="创建不可修改对象"><a href="#创建不可修改对象" class="headerlink" title="创建不可修改对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">创建不可修改对象</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var emptyObject &#x3D; Object.freeze(&#123;&#125;);</span><br></pre></td></tr></table></figure><p>Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const object1 &#x3D; &#123;</span><br><span class="line">  property1: 42</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 &#x3D; Object.freeze(object1);</span><br><span class="line"></span><br><span class="line">object2.property1 &#x3D; 33;</span><br><span class="line">&#x2F;&#x2F; Throws an error in strict mode</span><br><span class="line"></span><br><span class="line">console.log(object2.property1);</span><br><span class="line">&#x2F;&#x2F; expected output: 42</span><br></pre></td></tr></table></figure><h2 id="创建一个原型为-null-的空对象"><a href="#创建一个原型为-null-的空对象" class="headerlink" title="创建一个原型为 null 的空对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">创建一个原型为 null 的空对象</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var map &#x3D; Object.create(null);</span><br></pre></td></tr></table></figure><p>和用{}创建一个字面量对象有什么不同？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; 以字面量方式创建的空对象就相当于:</span><br><span class="line">o &#x3D; Object.create(Object.prototype);</span><br></pre></td></tr></table></figure><p>创建了一个<strong>空</strong>对象，没有原型链，没有继承 Object 的一些原型方法，例如 toString()等。你也可以复写一些有争议的 Object 方法，不用担心影响到。<br><a href="https://juejin.im/post/5acd8ced6fb9a028d444ee4e" target="_blank" rel="noopener">可以看看这篇</a></p><h2 id="修改对象特征"><a href="#修改对象特征" class="headerlink" title="修改对象特征"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">修改对象特征</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>descriptor：属性描述符。分为：</p><ul><li>数据描述符：是一个具有值的属性，该值可能是可写的，也可能不是可写的。<ul><li>configurable(false)：表示对象的属性是否可以被删除，<strong>以及除 writable 特性外的其他特性</strong>是否可以被修改。</li><li>enumerable(false)</li><li>value(undefined)</li><li>writable(false)</li></ul></li><li>存取描述符：是由 getter-setter 函数对描述的属性。<ul><li>get(false)</li><li>set(false)</li><li>configurable(false)</li><li>enumerable(false)</li></ul></li></ul><p><strong>描述符必须是这两种形式之一；不能同时是两者。</strong></p><p>数据和存取特征属性的一些例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中添加一个属性与数据描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1，if writable false,修改无效 还为37</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: a</span></span><br><span class="line"><span class="comment">// if configurable false,无法再修改属性</span></span><br><span class="line"><span class="comment">// Object.defineProperty(o, "a", &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="keyword">var</span> bValue;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'b'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">    <span class="keyword">return</span> bValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">    bValue = newValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.b = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);</span><br><span class="line"><span class="comment">// get</span></span><br></pre></td></tr></table></figure><p>考虑特性被赋予的默认特性值非常重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">o.a &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 等同于 :</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value : 1,</span><br><span class="line">  writable : true,</span><br><span class="line">  configurable : true,</span><br><span class="line">  enumerable : true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 另一方面，</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123; value : 1 &#125;);</span><br><span class="line">&#x2F;&#x2F; 等同于 :</span><br><span class="line">Object.defineProperty(o, &quot;a&quot;, &#123;</span><br><span class="line">  value : 1,</span><br><span class="line">  writable : false,</span><br><span class="line">  configurable : false,</span><br><span class="line">  enumerable : false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>ie8，对此方法不友好。也是 vue 至少 ie9 起步的原因之一。</p><h1 id="技巧方法"><a href="#技巧方法" class="headerlink" title="技巧方法"></a>技巧方法</h1><h2 id="如何定义一个-map"><a href="#如何定义一个-map" class="headerlink" title="如何定义一个 map"></a>如何定义一个 map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">str, expectsLowerCase</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> list = str.split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每个key，复制true</span></span><br><span class="line">    map[list[i]] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个closure</span></span><br><span class="line">  <span class="keyword">return</span> expectsLowerCase</span><br><span class="line">    ? <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map[val.toLowerCase()];</span><br><span class="line">      &#125;</span><br><span class="line">    : <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map[val];</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="定义一个-Set"><a href="#定义一个-Set" class="headerlink" title="定义一个 Set"></a>定义一个 Set</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_Set = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Set</span>.prototype.has = <span class="function"><span class="keyword">function</span> <span class="title">has</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.set[key] === <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Set</span>.prototype.add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set[key] = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Set</span>.prototype.clear = <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Set</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="方法缓存处理"><a href="#方法缓存处理" class="headerlink" title="方法缓存处理"></a>方法缓存处理</h2><p>如果 testFn 是一个非逻辑等操作，可存入缓存。缓存中首次创建新对象，key 标记 testFn 参数，用于缓存命中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cached</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'obj created'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cache);</span><br><span class="line">    <span class="keyword">var</span> hit = cache[str];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hit:'</span> + hit);</span><br><span class="line">    <span class="keyword">return</span> hit || (cache[str] = fn(str));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testFn = cached(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'receive data:'</span> + data);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line">testFn(<span class="string">'foo1'</span>);</span><br><span class="line"><span class="comment">// obj created</span></span><br><span class="line"><span class="comment">// Object &#123;&#125;</span></span><br><span class="line"><span class="comment">// hit:undefined</span></span><br><span class="line"><span class="comment">// receive data:foo1</span></span><br><span class="line">testFn(<span class="string">'foo1'</span>);</span><br><span class="line"><span class="comment">// Object &#123;foo1: "foo1"&#125;</span></span><br><span class="line"><span class="comment">// hit:foo1</span></span><br></pre></td></tr></table></figure><h2 id="浏览器的识别"><a href="#浏览器的识别" class="headerlink" title="浏览器的识别"></a>浏览器的识别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inBrowser = <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>;</span><br><span class="line"><span class="keyword">var</span> inWeex = <span class="keyword">typeof</span> WXEnvironment !== <span class="string">'undefined'</span> &amp;&amp; !!WXEnvironment.platform;</span><br><span class="line"><span class="keyword">var</span> weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();</span><br><span class="line"><span class="keyword">var</span> UA = inBrowser &amp;&amp; <span class="built_in">window</span>.navigator.userAgent.toLowerCase();</span><br><span class="line"><span class="keyword">var</span> isIE = UA &amp;&amp; <span class="regexp">/msie|trident/</span>.test(UA);</span><br><span class="line"><span class="keyword">var</span> isIE9 = UA &amp;&amp; UA.indexOf(<span class="string">'msie 9.0'</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> isEdge = UA &amp;&amp; UA.indexOf(<span class="string">'edge/'</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> isAndroid = (UA &amp;&amp; UA.indexOf(<span class="string">'android'</span>) &gt; <span class="number">0</span>) || weexPlatform === <span class="string">'android'</span>;</span><br><span class="line"><span class="keyword">var</span> isIOS = (UA &amp;&amp; <span class="regexp">/iphone|ipad|ipod|ios/</span>.test(UA)) || weexPlatform === <span class="string">'ios'</span>;</span><br><span class="line"><span class="keyword">var</span> isChrome = UA &amp;&amp; <span class="regexp">/chrome\/\d+/</span>.test(UA) &amp;&amp; !isEdge;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 开机自启动服务</title>
      <link href="/legacy/2018/07/11/linux-restart-process/"/>
      <url>/legacy/2018/07/11/linux-restart-process/</url>
      
        <content type="html"><![CDATA[<p>测试环境会因为运维某些需求（更改硬件配置，分配服务器资源…）使得会停服。<br>即使在工作时间之外维护，但也会导致次日上班时某些开发单独维护的服务没有及时启动，导致工作进度受影响。<br>那怎么友好的避免？编写服务器重启脚本。</p><p>那怎么做呢？</p><h2 id="准备服务启动-shell"><a href="#准备服务启动-shell" class="headerlink" title="准备服务启动 shell"></a>准备服务启动 shell</h2><p>拿运维写的 tomcat，和 node 做个例子（以备今后使用）<br>由于我们项目都是专门归类在同一目录之下，所以采用简单的循环启动服务即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">serverDir=/mydata/tomcats</span><br><span class="line"></span><br><span class="line">for dir in `ls $serverDir/`</span><br><span class="line">do</span><br><span class="line">        if [ -f "$serverDir/$dir/bin/startup.sh" ]; then</span><br><span class="line">        $serverDir/$dir/bin/startup.sh &amp;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 345 88 08</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Forever <span class="keyword">for</span> Node.js</span></span><br><span class="line">serverDir=/mydata/nodeProject</span><br><span class="line">export PATH=$PATH:/mydata/node-v8.9.0-linux-x64/bin</span><br><span class="line">cd $serverDir</span><br><span class="line">for dir in `ls $serverDir/`</span><br><span class="line">do</span><br><span class="line">        if [ -f "$serverDir/$dir/bin/www.js" ]; then</span><br><span class="line">            cd $dir</span><br><span class="line">            forever start -s ./bin/www.js</span><br><span class="line">            cd ../</span><br><span class="line">            sleep 2</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="编写-linux-重启-shell"><a href="#编写-linux-重启-shell" class="headerlink" title="编写 linux 重启 shell"></a>编写 linux 重启 shell</h2><p><a href="https://blog.csdn.net/acs713/article/details/7322082" target="_blank" rel="noopener">先了解一下/etc/rc.d/init.d</a><br>/etc/rc.d/init.d<br>存放了各种系统服务启动的信息</p><p>/etc/rc.d/rc[0-6].d<br>是指服务运行的级别</p><ul><li>0：表示关机</li><li>1：单用户模式</li><li>2：无网络连接的多用户命令行模式</li><li>3：有网络连接的多用户命令行模式</li><li>4：不可用</li><li>5：带图形界面的多用户模式</li><li>6：重新启动</li></ul><p>也可使用<strong>chkconfig</strong>来维护修改。<a href="https://blog.csdn.net/lanyang123456/article/details/54695567" target="_blank" rel="noopener">查看更多</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询</span></span><br><span class="line">[root@localhost etc]# chkconfig --list</span><br><span class="line">NetworkManager 0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">abrt-ccpp      0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">abrtd          0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">acpid          0:off1:off2:off3:off4:off5:off6:off</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>正题：编写/etc/rc.d/rc.local</strong><br>把上面的各种服务 sh 维护到此文件中，当重启后，系统自动执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script will be executed *after* all the other init scripts.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">'t</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> want to <span class="keyword">do</span> the full Sys V style init stuff.</span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line"><span class="meta">#</span><span class="bash">Start Tomcats</span></span><br><span class="line">/mydata/bashShells/startTomcats.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">Start Nginx</span></span><br><span class="line">/usr/sbin/nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">Start Node Projects</span></span><br><span class="line">/mydata/bashShells/startNodeProjs.sh</span><br><span class="line">mount -o username=Administrator,password=Cn654321Ty //192.168.1.90/yunwei /mnt/yunwei</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 cordova 接触混合开发大门</title>
      <link href="/legacy/2018/07/01/cordova-helloworld/"/>
      <url>/legacy/2018/07/01/cordova-helloworld/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/07/01/cordova-helloworld/cordova.png" class=""><h1 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a><a href="http://cordova.apache.org/" target="_blank" rel="noopener">Cordova</a></h1><p>早已听过 Cordova 这个名词，但是 3 年多一直没有机会玩下。<br>通过 Cordova，可以把我们前端的 js、html、css 打包成 app 应用，使用原生 app 的功能。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>跨平台重用代码<br>支持多个平台，android、ios…</li><li>支持离线场景应用<br>暂时不知道干什么用，可能类似 PWA 这些功能，ws 之类。</li><li>访问设备原生 API<br>不多说，肯定能调用原生 App 的 SDK。不然还要转个安卓环境干嘛，只是支持到什么程度。</li></ul><h2 id="还有哪些可以做混合开发"><a href="#还有哪些可以做混合开发" class="headerlink" title="还有哪些可以做混合开发"></a>还有哪些可以做混合开发</h2><ul><li>phoneGap<br>更古老的技术，网上说被收购了，然后其核心就是 Cordova。</li><li>ReactNative<br>不太喜欢非人类的 JSX，看了 React 一个 Demo 就没什么兴趣了</li><li>Weex<br>阿里大厂的 KPI 作品，也是造轮子，不过应该尝试下。</li></ul><h1 id="如何开始一个-HelloWorld"><a href="#如何开始一个-HelloWorld" class="headerlink" title="如何开始一个 HelloWorld"></a>如何开始一个 HelloWorld</h1><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><pre><code>不多说，网上一大堆</code></pre><h2 id="下载-SDK、配置-SDK-环境变量"><a href="#下载-SDK、配置-SDK-环境变量" class="headerlink" title="下载 SDK、配置 SDK 环境变量"></a>下载 SDK、配置 SDK 环境变量</h2><pre><code>[中文社区就有](http://tools.android-studio.org/index.php/sdk)环境变量需要配置：platform-tools和tools目录</code></pre><h2 id="安装-Andriod-Studio（我只有-win-系统，所以-ios-暂时玩不了）"><a href="#安装-Andriod-Studio（我只有-win-系统，所以-ios-暂时玩不了）" class="headerlink" title="安装 Andriod Studio（我只有 win 系统，所以 ios 暂时玩不了）"></a>安装 Andriod Studio（我只有 win 系统，所以 ios 暂时玩不了）</h2><ol><li><p><a href="https://developer.android.google.cn/studio/" target="_blank" rel="noopener">下载 android studio</a></p><img src="/legacy/2018/07/01/cordova-helloworld/download.png" class=""></li><li><p>安装（无脑下一步）</p><img src="/legacy/2018/07/01/cordova-helloworld/install.png" class=""></li><li><p>建个项目</p></li></ol><ul><li>了解默认模板常见的 project 的结构<img src="/legacy/2018/07/01/cordova-helloworld/project.png" class=""></li><li>配置 AVD，后续 Cordova 会用到（当然可以使用 Cordova-cli，可惜第一次接触嫌麻烦，暂时没看）<img src="/legacy/2018/07/01/cordova-helloworld/version.png" class="">注意版本，如果过高可能使用 Cordova 会出现一些错误。<img src="/legacy/2018/07/01/cordova-helloworld/error.png" class=""></li></ul><h2 id="Cordova-1"><a href="#Cordova-1" class="headerlink" title="Cordova"></a><a href="http://cordova.apache.org/docs/en/latest/guide/cli/index.html" target="_blank" rel="noopener">Cordova</a></h2><p>按照官网撸一边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">npm install cordova -g &#x2F;&#x2F;最好别cnpm，可能cordova安装会有问题</span><br><span class="line"></span><br><span class="line">cordova create hello com.example.hello HelloWorld &#x2F;&#x2F;创建项目（文件夹+java pkg格式+app name，大概这意思）</span><br><span class="line"></span><br><span class="line">cordova platform add android &#x2F;&#x2F;构建安卓平台，创建一个标准的安卓project目录</span><br><span class="line"></span><br><span class="line">cordova platform ls &#x2F;&#x2F;核对平台环境信息</span><br><span class="line">    Installed platforms:</span><br><span class="line">        android 7.0.0</span><br><span class="line">    Available platforms:</span><br><span class="line">        browser ~5.0.1</span><br><span class="line">        ios ~4.5.4</span><br><span class="line">        osx ~4.0.1</span><br><span class="line">        windows ~5.0.0</span><br><span class="line">        www ^3.12.0</span><br><span class="line"></span><br><span class="line">cordova build android &#x2F;&#x2F;构架一个apk包</span><br><span class="line">    xxx\hello\platforms\android\app\build\outputs\apk\debug\app-debug.apk</span><br><span class="line"></span><br><span class="line">cordova emulate android &#x2F;&#x2F;启动一个模拟器</span><br><span class="line"></span><br><span class="line">cordova run android &#x2F;&#x2F;将js代码构建成app方式，刷新模拟器</span><br></pre></td></tr></table></figure><p>目录结构<br><img src="/legacy/2018/07/01/cordova-helloworld/dir.png" class="" title="其实我们前端只关心下面www"></p><img src="/legacy/2018/07/01/cordova-helloworld/adv.png" class="" title="顺利的话，出现这个View">]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我要跳槽了</title>
      <link href="/legacy/2018/06/24/note-i-will-job-hopping/"/>
      <url>/legacy/2018/06/24/note-i-will-job-hopping/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
          <category> 记事本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 隐藏敏感文件</title>
      <link href="/legacy/2018/06/19/git-remove-sensitive-file/"/>
      <url>/legacy/2018/06/19/git-remove-sensitive-file/</url>
      
        <content type="html"><![CDATA[<p>最近在 github 托管一个小 Demo，发现一个问题：<br>写了个 mongo 的配置文件，里面包含账号密码，年轻的我写了个 ignore 忽略文件。</p><p>但是万一有人拉 log，还是可以通过你的提交记录，看到敏感信息，这时候怎么做？</p><h1 id="git-filter-branch"><a href="#git-filter-branch" class="headerlink" title="git-filter-branch"></a><a href="https://git-scm.com/docs/git-filter-branch" target="_blank" rel="noopener">git-filter-branch</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch [--setup &lt;command&gt;] [--subdirectory-filter &lt;directory&gt;]</span><br><span class="line">[--env-filter &lt;command&gt;] [--tree-filter &lt;command&gt;]</span><br><span class="line">[--index-filter &lt;command&gt;] [--parent-filter &lt;command&gt;]</span><br><span class="line">[--msg-filter &lt;command&gt;] [--commit-filter &lt;command&gt;]</span><br><span class="line">[--tag-name-filter &lt;command&gt;] [--prune-empty]</span><br><span class="line">[--original &lt;namespace&gt;] [-d &lt;directory&gt;] [-f | --force]</span><br><span class="line">[--state-branch &lt;branch&gt;] [--] [&lt;rev-list options&gt;…​]</span><br></pre></td></tr></table></figure><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 复写敏感文件记录</span><br><span class="line">shixinghao@Lenovo-PC MINGW64 &#x2F;e&#x2F;NextInnovation (master)</span><br><span class="line">$ git filter-branch --force --index-filter \</span><br><span class="line">&gt; &#39;git rm --cached --ignore-unmatch server&#x2F;conf&#x2F;mongo.conf.js&#39; \</span><br><span class="line">&gt; --prune-empty -- --all</span><br><span class="line">Rewrite 865e20cc140d596dc23b7d65467b53dea1b7f62d (13&#x2F;17)rm &#39;server&#x2F;conf&#x2F;mongo.conf.js&#39;</span><br><span class="line">Rewrite 0f7676b5fe1db28534de85b5b038b1643087adfe (17&#x2F;17)</span><br><span class="line">Ref &#39;refs&#x2F;heads&#x2F;master&#39; was rewritten</span><br><span class="line">Ref &#39;refs&#x2F;remotes&#x2F;origin&#x2F;master&#39; was rewritten</span><br><span class="line">WARNING: Ref &#39;refs&#x2F;remotes&#x2F;origin&#x2F;master&#39; is unchanged</span><br><span class="line"></span><br><span class="line"># 提交到远程仓库</span><br><span class="line">shixinghao@Lenovo-PC MINGW64 &#x2F;e&#x2F;NextInnovation (master)</span><br><span class="line">$ git push origin --force --all</span><br><span class="line">Counting objects: 191, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (104&#x2F;104), done.</span><br><span class="line">Writing objects: 100% (191&#x2F;191), 626.68 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 191 (delta 51), reused 172 (delta 47)</span><br><span class="line">remote: Resolving deltas: 100% (51&#x2F;51), done.</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;eminoda&#x2F;NextInnovation</span><br><span class="line"> + 0f7676b...b65e33d master -&gt; master (forced update)</span><br></pre></td></tr></table></figure><h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><ol><li><p><a href="https://git-scm.com/docs/git-filter-branch#git-filter-branch---index-filterltcommandgt" target="_blank" rel="noopener">filter-branch –index-filter<command> –prune-empty – –all</a><br>用来重写 git 的版本历史记录。<br>index-filter 和 tree-filter 类似，但由于不走 git tree 等内容，直接走索引速度更快。<br>prune-empty 重写后如果产生 empty 的 commit，这个选项将移除到这些 commit。</p></li><li><p><a href="https://git-scm.com/docs/git-rm" target="_blank" rel="noopener">git rm –cached –ignore-unmatch</a><br>使用 cached，使文件在版本管理中去除，但本地硬盘中保留。<br>如果没有匹配到对应 file，ignore-unmatch 则会忽略警告错误。</p></li></ol><h1 id="当然还有其他方式——BFG"><a href="#当然还有其他方式——BFG" class="headerlink" title="当然还有其他方式——BFG"></a>当然还有其他方式——BFG</h1><p>暂未尝试，<a href="https://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">如果有兴趣，请点击</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://git-scm.com/book/zh/v2/Git-内部原理-维护与数据恢复" target="_blank" rel="noopener">git-filter-branch 使用场景说明</a></li><li><a href="https://blog.csdn.net/lwfcgz/article/details/49453375" target="_blank" rel="noopener">git filter branch</a></li><li><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="noopener">github 处理敏感文件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 设置配置</title>
      <link href="/legacy/2018/05/24/vscode-setting/"/>
      <url>/legacy/2018/05/24/vscode-setting/</url>
      
        <content type="html"><![CDATA[<h1 id="在哪里对-vscode-进行设置"><a href="#在哪里对-vscode-进行设置" class="headerlink" title="在哪里对 vscode 进行设置"></a>在哪里对 vscode 进行设置</h1><img src="/legacy/2018/05/24/vscode-setting/where.png" class=""><img src="/legacy/2018/05/24/vscode-setting/where2.png" class=""><h1 id="一些个人配置，供参考"><a href="#一些个人配置，供参考" class="headerlink" title="一些个人配置，供参考"></a>一些个人配置，供参考</h1><p>主要配置，在系统默认的配置中描述很详细（都有中文介绍）<br><a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">官网-设置介绍</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"git.path"</span>: <span class="string">"D:\\git\\Git\\cmd\\git.exe"</span>, <span class="comment">//git地址，然后可以在控制台使用git shell</span></span><br><span class="line">  <span class="attr">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\WINDOWS\\Sysnative\\cmd.exe"</span>, <span class="comment">//选择终端模式，cmd or prower shell</span></span><br><span class="line">  <span class="attr">"window.zoomLevel"</span>: <span class="number">0</span>, <span class="comment">// 窗口大小</span></span><br><span class="line">  <span class="attr">"editor.detectIndentation"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>, <span class="comment">//保存后自动格式化</span></span><br><span class="line">  <span class="attr">"eslint.autoFixOnSave"</span>: <span class="literal">true</span>, <span class="comment">//格式化后 自动修复</span></span><br><span class="line">  <span class="attr">"extensions.ignoreRecommendations"</span>: <span class="literal">false</span>, <span class="comment">//忽略插件推荐</span></span><br><span class="line">  <span class="attr">"fileheader.Author"</span>: <span class="string">"shixinghao"</span>, <span class="comment">// 插件vscode-fileheader，具体设置</span></span><br><span class="line">  <span class="attr">"fileheader.LastModifiedBy"</span>: <span class="string">"shixinghao"</span>, <span class="comment">// 插件vscode-fileheader，具体设置</span></span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.js"</span>: <span class="string">"vscode-typescript"</span>, <span class="comment">//插件vetur，默认格式化风格</span></span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>, <span class="comment">//插件vetur，默认格式化风格</span></span><br><span class="line">  <span class="attr">"javascript.format.insertSpaceBeforeFunctionParenthesis"</span>: <span class="literal">true</span>, <span class="comment">// 针对eslint规则，对js特殊配置</span></span><br><span class="line">  <span class="attr">"typescript.format.insertSpaceBeforeFunctionParenthesis"</span>: <span class="literal">true</span>, <span class="comment">// 针对eslint规则，对js特殊配置</span></span><br><span class="line">  <span class="attr">"workbench.colorTheme"</span>: <span class="string">"Visual Studio Dark"</span> <span class="comment">//ide style</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升接口 API 的安全等级</title>
      <link href="/legacy/2018/05/16/sercet-http-api/"/>
      <url>/legacy/2018/05/16/sercet-http-api/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/16/sercet-http-api/http.jpg" class=""><p>近期，公司老板发起一个关于 api 设计、安全签名的探讨…，然后就有一项课后作业：</p><blockquote><p>有什么方式能提升 api 的安全</p></blockquote><h2 id="看看别人家怎么做的？"><a href="#看看别人家怎么做的？" class="headerlink" title="看看别人家怎么做的？"></a>看看别人家怎么做的？</h2><p>自身经验不多，来简单看下<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信的 access_token 机制来思考下</a>，我们有哪些可以学习。</p><img src="/legacy/2018/05/16/sercet-http-api/wx.png" class="" title="简易的用户授权过程"><ol><li>用户除了主动授权，没有暴露过其他敏感信息–Oauth2</li><li>授权获取的 code 具有<strong>唯一性</strong>和<strong>过期性</strong></li><li>授权过程中的 redirect_uri，微信会对授权链接做正则强匹配校验（server 要是使坏，就把你 close 掉）</li><li>server 事先有后续获取 access_token 提供请求参数 sercetKey（必须只保存在服务器，不允许传给客户端）</li><li>微信信任的 access_token，调用有<strong>次数限制</strong>，和<strong>有效期</strong></li></ol><h2 id="具体到我们，能做什么"><a href="#具体到我们，能做什么" class="headerlink" title="具体到我们，能做什么"></a>具体到我们，能做什么</h2><h3 id="使用-https-代替-http-方式"><a href="#使用-https-代替-http-方式" class="headerlink" title="使用 https 代替 http 方式"></a>使用 https 代替 http 方式</h3><h3 id="提供权限控制"><a href="#提供权限控制" class="headerlink" title="提供权限控制"></a>提供权限控制</h3><p>对于公用的服务，你必须是某某权限才能访问这些 api，可能你没有登录什么都干不了。<br>比如，只有服务端才能获取微信的 token，因为服务端才有 secretKey 等条件</p><h3 id="使用-JWT"><a href="#使用-JWT" class="headerlink" title="使用 JWT"></a><a href="https://github.com/auth0/node-jsonwebtoken" target="_blank" rel="noopener">使用 JWT</a></h3><ol><li>规范化 security tokens 机制</li><li>服务端可以配置 sercetKey（salt），增加破解难度</li><li>具有过期性质的配置，可能你不需要在弄个缓存服务来做超时这事<br>备注，需要服务端产生 JWT 给 client。避免客户端自己生成</li></ol><h3 id="特殊-API-给予特殊控制"><a href="#特殊-API-给予特殊控制" class="headerlink" title="特殊 API 给予特殊控制"></a>特殊 API 给予特殊控制</h3><p>防止一些敏感接口重复调用，高频调用等情况发生</p><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>不要相信前端提交的表单，或者接口携带的参数不会出什么问题。<br>保不齐传个负数，丢个 0 给你处理。甚至于留个超大的文件塞爆你的库</p><h3 id="注意敏感信息的请求方式"><a href="#注意敏感信息的请求方式" class="headerlink" title="注意敏感信息的请求方式"></a>注意敏感信息的请求方式</h3><p>账号密码等名该应该放置于 request body 里，或 header 中</p><h3 id="注意请求头的-Content-Type"><a href="#注意请求头的-Content-Type" class="headerlink" title="注意请求头的 Content-Type"></a>注意请求头的 Content-Type</h3><p>比如：上传图片，必须是 image/jpeg，你 gif、png 不行，其他更不行。<br>Access-Control-Allow-Origin，允许哪些跨域网站可以访问我们支援。</p><h3 id="使用-REST-来规范你的接口"><a href="#使用-REST-来规范你的接口" class="headerlink" title="使用 REST 来规范你的接口"></a>使用 REST 来规范你的接口</h3><ol><li>限制 Http 方法<br>根据 Restful 接口的规范，万物皆资源，获取的方法需要特定的方式。<br>GET 用来获取资源，<br>POST 用来新建资源（也可以用于更新资源），<br>PUT 用来更新资源，<br>DELETE 用来删除资源…</li><li>提供更丰富的 Http status code</li><li>提供<em>友好的</em>错误提示<br>不要提示详细，具体的错误细节给到 client。那只存在日志或其他地方</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/REST_Security_Cheat_Sheet</a> &gt; <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">RESTful API Authentication Basics</a> &gt; <a href="https://stormpath.com/blog/secure-your-rest-api-right-way" target="_blank" rel="noopener">How to Secure Your REST API using Proven Best Practices</a> &gt; <a href="https://www.cnblogs.com/doseoer/p/5676297.html" target="_blank" rel="noopener">header 的安全配置指南</a> &gt; <a href="https://www.zhihu.com/question/27785028" target="_blank" rel="noopener">REST 架构该怎么生动地理解？</a> &gt; <a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">REST 的许多文献</a> &gt; <a href="http://tool.oschina.net/commons/" target="_blank" rel="noopener">http://tool.oschina.net/commons/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 重复代码块检查</title>
      <link href="/legacy/2018/05/15/js-project-copy/"/>
      <url>/legacy/2018/05/15/js-project-copy/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/15/js-project-copy/dry.jpg" class=""><p>项目复杂了，人员沟通不通畅，开发进度赶时间，不可避免的会造成代码的重复。为了实现一个相似功能，可能会<strong>ctrl+c，ctrl+v</strong>然后修改个参数，草草交差。给后期增加更大的维护成本。</p><p>其实这违反了<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener"><strong>DRY</strong>原则（Don’t repeat yourself）</a>，说起来好像很高大上，其实它就是软件设计中一种最佳实践的开发模式。通过抽象、消除重复数据，避免数据冗余。</p><p>那我们怎么检测平时工程项目中的重复代码呢？下面介绍几个工具：</p><h2 id="jsinspect"><a href="#jsinspect" class="headerlink" title="jsinspect"></a><a href="https://github.com/danielstjules/jsinspect" target="_blank" rel="noopener">jsinspect</a></h2><p>Detect copy-pasted and structurally similar code<br>值得注意的，只支持 js 和 jsx</p><blockquote><p>The tool accepts a list of paths to parse and prints any found matches. Any directories among the paths are walked recursively, and only .js and .jsx files are analyzed</p></blockquote><p>快速使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jsinspect</span><br><span class="line">jsinspect -t 50 .&#x2F;server&#x2F;src&#x2F;js</span><br></pre></td></tr></table></figure><p>效果：<br><img src="/legacy/2018/05/15/js-project-copy/example-1.png" class="" title="检测出类似代码块"></p><p>当然你还可以在 project root 下新建.jsinspectrc，配置更多参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;threshold&quot;:     30,&#x2F;&#x2F; 指定规则命中的节点数量</span><br><span class="line">  &quot;identifiers&quot;:   true,&#x2F;&#x2F; variables, methods, properties, etc</span><br><span class="line">  &quot;literals&quot;:      true,&#x2F;&#x2F; strings, numbers, etc.</span><br><span class="line">  &quot;color&quot;:         true,</span><br><span class="line">  &quot;minInstances&quot;:  2,&#x2F;&#x2F; 最小匹配数量</span><br><span class="line">  &quot;ignore&quot;:        &quot;test|spec|node_modules&quot;,</span><br><span class="line">  &quot;reporter&quot;:      &quot;default&quot;,&#x2F;&#x2F; 报告格式，还有pmd、json</span><br><span class="line">  &quot;truncate&quot;:      10&#x2F;&#x2F; 截取行数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jscpd"><a href="#jscpd" class="headerlink" title="jscpd"></a><a href="https://github.com/kucherenko/jscpd" target="_blank" rel="noopener">jscpd</a></h2><p>Copy/paste detector for programming source code.</p><p>和 jsinspect 不同：</p><ol><li>它支持多种 extension 的语言</li><li>具有 report 导出功能</li></ol><table><thead><tr><th><em>Supported languages</em></th><th></th><th></th></tr></thead><tbody><tr><td>JavaScript</td><td>Java</td><td>YAML</td></tr><tr><td>CoffeeScript</td><td>C++</td><td>Haxe</td></tr><tr><td>PHP</td><td>C#</td><td>TypeScript</td></tr><tr><td>Go</td><td>Python</td><td>Mixed HTML</td></tr><tr><td>Ruby</td><td>C</td><td>SCSS</td></tr><tr><td>Less</td><td>CSS</td><td>erlang</td></tr><tr><td>Swift</td><td>xml/xslt</td><td>Objective-C</td></tr><tr><td>Puppet</td><td>Twig</td><td>Vue.js</td></tr><tr><td>Scala</td><td>Lua</td><td>Perl</td></tr></tbody></table><p>快速使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install jscpd -g</span><br><span class="line">jscpd --languages vue --path .&#x2F;src</span><br></pre></td></tr></table></figure><p>同样，也可以定义配置文件<strong>.cpd.yaml</strong>，简化命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">path: &quot;.&#x2F;src&quot; &#x2F;&#x2F;校验路径</span><br><span class="line">output: &quot;..&#x2F;jscpd-report.xml&quot; &#x2F;&#x2F;report文件</span><br><span class="line">languages:</span><br><span class="line">  - vue</span><br><span class="line">blame: false &#x2F;&#x2F;是否显示详细信息，会列出git等信息</span><br><span class="line">verbose: false &#x2F;&#x2F;是否输出具体信息</span><br><span class="line">files:</span><br><span class="line">  - &quot;.&#x2F;**&#x2F;*.vue&quot; &#x2F;&#x2F;需要加载的文件</span><br><span class="line">exclude:</span><br><span class="line">  - &quot;.&#x2F;pages&#x2F;Test.vue&quot; &#x2F;&#x2F;ignore路径</span><br><span class="line">reporter: xml</span><br><span class="line">languages-exts:</span><br><span class="line">  javascript:</span><br><span class="line">    - es</span><br><span class="line">    - es5</span><br><span class="line">    - es6</span><br><span class="line">    - es7</span><br></pre></td></tr></table></figure><p>效果：<br><img src="/legacy/2018/05/15/js-project-copy/example-2.png" class="" title="检测出类似代码块，这里关掉了verbose"></p><h2 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a><a href="https://pmd.github.io/pmd-6.3.0/index.html" target="_blank" rel="noopener">PMD</a></h2><blockquote><p>an extensible cross-language static code analyzer. It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation, and so forth. Additionally it includes CPD, the copy-paste-detector. CPD finds duplicated code.</p></blockquote><p>感觉很高大上，不过感觉很不友好</p><ol><li>需要安装 java 环境，命令行方式不易上手（可能我玩不来，cmd 没有跑出来）。</li><li>npm 不支持，无法匹配前端脚手架。</li><li>不支持 vue 等语言（可能是我玩不来）</li><li>上面两个插件基本可以解决目前遇到的问题</li></ol><p>效果：<br><img src="/legacy/2018/05/15/js-project-copy/example-3.png" class="" title="下载解压pmd，点击图上bat"><br><img src="/legacy/2018/05/15/js-project-copy/example-4.png" class="" title="图形化界面"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quality </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码 QA 检查和单元测试</title>
      <link href="/legacy/2018/05/10/eslint-and-test/"/>
      <url>/legacy/2018/05/10/eslint-and-test/</url>
      
        <content type="html"><![CDATA[<h2 id="质量检查和测试都需要吗？"><a href="#质量检查和测试都需要吗？" class="headerlink" title="质量检查和测试都需要吗？"></a>质量检查和测试都需要吗？</h2><p>答案是：两个都要兼得。</p><p>项目都是以团队为单位开发，每个人编写的风格不同，技能掌握程度不一致，代码质量更是千差万别。不可避免会造成项目管理上的不可控。<br>所以必须要引入代码质量规则来监督。</p><p>同时需求迭代一多，功能一复杂，敏捷开发没完没了，谁能断言自己的代码没有 bug。<br>另外，如果高层不看重测试，还是进行<strong>人肉测试</strong>，那又能发现多少潜在问题？</p><p>关于<a href="/2018/05/09/js-project-check/">如何进行质量检查，请参阅</a>，使用工具集成到项目中，不用在担心手滑，粗心造成的 bug。<br>同样在前端，不是因为难以测试而不去集成考虑单元测试，甚至 e2e 方面的测试。这方面的好处，java 等后端语言提现的淋漓尽致。</p><h2 id="这里举个例子"><a href="#这里举个例子" class="headerlink" title="这里举个例子"></a>这里举个例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var should &#x3D; require(&#39;should&#39;)</span><br><span class="line">var needTest &#x3D; function (status) &#123;</span><br><span class="line">    var defaultValue;</span><br><span class="line">    if (status) &#123;</span><br><span class="line">        defaultValue &#x3D; &#39;something happen&#39;</span><br><span class="line">        return defaultValue</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 有个bug</span><br><span class="line">    return defaultValue.indexOf(1)</span><br><span class="line">&#125;</span><br><span class="line">describe(&#39;needTest&#39;, function () &#123;</span><br><span class="line">    describe(&#39;status&#x3D;true&#39;, function () &#123;</span><br><span class="line">        it(&#39;should return something happen&#39;, function () &#123;</span><br><span class="line">            should.equal(needTest(true), &#39;something happen&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    describe(&#39;status&#x3D;false&#39;, function () &#123;</span><br><span class="line">        it(&#39;should return -1&#39;, function () &#123;</span><br><span class="line">            should.equal(needTest(false), &#39;-1&#39;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们编写了一个 needTest 方法，tdd 嘛，测试驱动开发，所以针对条件写了 2 个用例。<br>符合预期，检查出了一个 bug，由于 defaultValue 么有定义。<br><img src="/legacy/2018/05/10/eslint-and-test/demo.png" class=""></p><p>但如果我们使用了 eslint，在我们编写 needTest 的时候就会提示代码错误，就可以提前预防这个 error 的发生。<br><img src="/legacy/2018/05/10/eslint-and-test/eslint.png" class=""></p><p>这个例子主要为了说明，这两者在一起不是增加的开发人员的劳动力和负担。<br>相反，QA 可以从侧面减少测试编写的压力；测试可以补充 QA 没有发现的问题。<br>为了让今后的代码更<strong>健康</strong>，我们更无忧无虑，那就赶紧上吧。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 工程化之代码 QA 校验</title>
      <link href="/legacy/2018/05/09/js-project-check/"/>
      <url>/legacy/2018/05/09/js-project-check/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/09/js-project-check/eslint.png" class=""><p>eslint，和 jslint 等一样，都是 js 方向的检验工具。目标就是提前有规则的规范项目代码，提供 error、warn 提示，避免人为疏忽造成的错误，提升代码健壮性，稳定性。<br>eslint 对比其他工具，具有更强大的功能，社区有非常多的 plugins，对不同脚手架的前端工具都能使用，vscode 等 ide 也有支持插件。<br>官方也给出了 best practice，任何人都能简单的享受那种<strong>安全感</strong></p><h2 id="代码校验好处"><a href="#代码校验好处" class="headerlink" title="代码校验好处"></a>代码校验好处</h2><ol><li>规范代码格式，统一团队 format 风格</li><li>提前发现代码错误<br>比如：<ul><li>没有 var 声明变量，但会被全局化到 window 中，影响逻辑功能。</li><li>没有用对 es6 里的 let、const</li><li><a href="#那些不容易察觉的问题代码">下面举例说明</a></li></ul></li><li>检查代码复杂度</li><li>帮助 CI 集成</li></ol><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a><a href="https://eslint.org/docs/user-guide/getting-started#local-installation-and-usage" target="_blank" rel="noopener">环境配置</a></h2><ol><li>安装 eslint</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">配置文件</a><br>eslint 默认会读项目路径下的配置文件，根据 ide 的插件，就能马上投入使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your project root dir</span><br><span class="line">mkdir .eslintrc(.js|.json|.yaml)</span><br></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><h3 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a><a href="https://eslint.org/docs/rules/#best-practices" target="_blank" rel="noopener">Rule</a></h3><h3 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h3><p>避免外部资源等原因，某些变量没有专门 declare 报的错。需要全局定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globals: &#123;</span><br><span class="line">    PC_URL: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有条件的跳过-eslint-检验"><a href="#有条件的跳过-eslint-检验" class="headerlink" title="有条件的跳过 eslint 检验"></a>有条件的跳过 eslint 检验</h3><p>如果使用 vscode，通过以下插件可以方便更改<br><img src="/legacy/2018/05/09/js-project-check/vscode.png" class="" title="vscode插件"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 特殊注解</span><br><span class="line">&#x2F;* eslint-disable no-console *&#x2F;</span><br><span class="line">console.log();</span><br><span class="line">&#x2F;* eslint-enable no-console *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="忽略指定路径-eslint-的校验"><a href="#忽略指定路径-eslint-的校验" class="headerlink" title="忽略指定路径 eslint 的校验"></a>忽略指定路径 eslint 的校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir .eslintignore</span><br><span class="line"></span><br><span class="line">&#x2F;src&#x2F;*.js</span><br></pre></td></tr></table></figure><h3 id="扩展配置文件"><a href="#扩展配置文件" class="headerlink" title="扩展配置文件"></a><a href="https://eslint.org/docs/user-guide/configuring#extending-configuration-files" target="_blank" rel="noopener">扩展配置文件</a></h3><p>参考社区最佳实践，引用需要的插件，完善 eslint 规则检查</p><ol><li>extends 规则逻辑<ul><li>添加额外规则</li><li>继承 rule 规则</li><li>覆盖 rule 重复规则</li></ul></li></ol><p>2) 如何使用内置规则<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends:&quot;eslint:recommended&quot;</span><br></pre></td></tr></table></figure><br>3) 使用其他 eslint package 配置的规则</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-config-xxx</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends: standard</span><br></pre></td></tr></table></figure><p>4) 使用第三方 plugins 提供的规则</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugin-xxx</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot;</span><br><span class="line">],</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">    &quot;eslint:recommended&quot;,</span><br><span class="line">    &quot;plugin:react&#x2F;recommended&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h2 id="配置-vue-project"><a href="#配置-vue-project" class="headerlink" title="配置 vue project"></a>配置 vue project</h2><ol><li>安装插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugin-vue -D</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/vuejs/eslint-plugin-vue#what-is-the-use-the-latest-vue-eslint-parser-error" target="_blank" rel="noopener">未能解析 vue</a></p><img src="/legacy/2018/05/09/js-project-check/vue-1.png" class=""><p>eslint-plugin-vue require vue-eslint-parser</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm vue-eslint-parser -D</span><br></pre></td></tr></table></figure><p>.eslintrc.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;parser&quot;: &quot;vue-eslint-parser&quot;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    extends: [</span><br><span class="line">        &#39;plugin:vue&#x2F;essential&#39;,</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        &#39;vue&#39;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/legacy/2018/05/09/js-project-check/vue-2.png" class="" title="eslint-plugin-vue内置规则"></li><li><p>error Resolve error: unable to load resolver “node” import/no-duplicates<br>需要安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-import-resolver-node -D</span><br></pre></td></tr></table></figure></li></ol><h2 id="那些不容易察觉的问题代码"><a href="#那些不容易察觉的问题代码" class="headerlink" title="那些不容易察觉的问题代码"></a>那些不容易察觉的问题代码</h2><h3 id="会引起麻烦的-error（必须修改）"><a href="#会引起麻烦的-error（必须修改）" class="headerlink" title="会引起麻烦的 error（必须修改）"></a>会引起麻烦的 error（必须修改）</h3><ol><li><p>[eslint] Unexpected trailing comma. (comma-dangle)</p><img src="/legacy/2018/05/09/js-project-check/error-1.png" class="" title="不允许逗号结尾"><p>代码不和规范，压缩代码可能会出错。</p></li><li><p>[eslint] Unexpected trailing comma. (comma-dangle)</p><img src="/legacy/2018/05/09/js-project-check/error-2.png" class="" title="&#x3D;&#x3D;&#x3D;&amp;&#x3D;&#x3D;"><p>由于 js 太过灵活，弱类型的判断通过可能会引致执行逻辑错误。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; &#39;1&#39;;</span><br><span class="line">if(test&gt;0)&#123;</span><br><span class="line">    test &#x3D; test.toFixed(2); &#x2F;&#x2F;TypeError: &quot;1&quot;.toFixed is not a function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>[eslint] Expected { after ‘if’ condition. (curly)</p><img src="/legacy/2018/05/09/js-project-check/error-4.png" class="" title="if后跟代码块"><p>代码不和规范，压缩代码可能会出错。</p></li><li><p>[eslint] Duplicate key ‘strToArr’. (no-dupe-keys)</p><img src="/legacy/2018/05/09/js-project-check/error-5.png" class="" title="重复定义"><p>处理冲突、代码复制粘贴、项目重构后造成的疏漏</p></li><li><p>[eslint] ‘PC_URL’ is not defined. (no-undef)</p><img src="/legacy/2018/05/09/js-project-check/error-6.png" class="" title="变量没有定义"><img src="/legacy/2018/05/09/js-project-check/error-9.png" class="" title="变量没有定义"><img src="/legacy/2018/05/09/js-project-check/error-11.png" class="" title="变量没有定义"></li><li><p>[eslint] ‘API’ is defined but never used. (no-unused-vars)<br>变量没有使用，一定程度会导致打包额外不需要的文件</p></li><li><p>[eslint] Return statement should not contain assignment. (no-return-assign)</p><img src="/legacy/2018/05/09/js-project-check/error-7.png" class="" title="return中不要执行逻辑"></li><li><p>[eslint] Import in body of module; reorder to top. (import/first)</p><img src="/legacy/2018/05/09/js-project-check/error-8.png" class="" title="import置于顶部"><p>方便维护查找引用</p></li><li><p>error Type of the default value for ‘list’ prop must be a function vue/require-valid-default-prop<br>vue prop 需要明确返回类型，array object 都是引用类型，需要指定清晰</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  propA: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  propB: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: []</span><br><span class="line">  &#125;,</span><br><span class="line">  propC: &#123;</span><br><span class="line">    type: Object,</span><br><span class="line">    default: []</span><br><span class="line">  &#125;,</span><br><span class="line">  propD: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: []</span><br><span class="line">  &#125;,</span><br><span class="line">  propE: &#123;</span><br><span class="line">    type: Object,</span><br><span class="line">    default: &#123; message: &#39;hello&#39; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不容忽视的警告（不影响功能，但会造成其他麻烦）"><a href="#不容忽视的警告（不影响功能，但会造成其他麻烦）" class="headerlink" title="不容忽视的警告（不影响功能，但会造成其他麻烦）"></a>不容忽视的警告（不影响功能，但会造成其他麻烦）</h3><ol><li><p>[eslint] Missing space before value for key ‘updatePzType’. (key-spacing)</p><img src="/legacy/2018/05/09/js-project-check/warn-1.png" class="" title="缺少空格"><p>减少因代码格式化风格不同，导致代码冲突，不易查看别人代码情况</p></li><li><p>[eslint] Trailing spaces not allowed. (no-trailing-spaces)</p><img src="/legacy/2018/05/09/js-project-check/warn-2.png" class="" title="缺少空格"></li><li><p>error Missing space after =&gt; arrow-spacing</p><img src="/legacy/2018/05/09/js-project-check/warn-4.png" class="" title="多余空格"></li><li><p>[eslint] Expected the Promise rejection reason to be an Error. (prefer-promise-reject-errors)</p><img src="/legacy/2018/05/09/js-project-check/error-3.png" class="" title="需要reject error对象"><p>reject 要符合语义</p></li><li><p>[eslint] Redundant use of <code>await</code> on a return value. (no-return-await)</p><img src="/legacy/2018/05/09/js-project-check/warn-3.png" class="" title="不能返回await"><p>虽然逻辑没问题，但指出了 es6 等语法理解不深刻，使用不当的问题</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来测试通过的代码，在 eslint 的帮助下，暴露了更多的安全隐患，和测试人员没有发现的问题。<br>js 本来就灵活多变，稍不留神就会给自己埋下大坑，如果没有提前检测机制，根本就是防不胜防。<br>如果你还没用，赶紧使用起来…</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 模块别乱下载，说不好就出事了</title>
      <link href="/legacy/2018/05/08/npm-unsafe/"/>
      <url>/legacy/2018/05/08/npm-unsafe/</url>
      
        <content type="html"><![CDATA[<p>如果你和我们一样，npm install xxx 用的很舒服，可能你的项目会遇到重大的危险。<br>先来看看一篇别人家的文章——<a href="https://mp.weixin.qq.com/s/4JGuRDR54OnJyAqlSns53Q" target="_blank" rel="noopener">细思极恐：后门代码被隐藏在 npm 模块中，差点就得逞</a></p><p>为了节省时间，<a href="https://news.ycombinator.com/item?id=16975025" target="_blank" rel="noopener">点击问题讨论地址，直接看看别人怎么说的</a><br><img src="/legacy/2018/05/08/npm-unsafe/blog.png" class=""></p><img src="/legacy/2018/05/08/npm-unsafe/emoji.png" class=""><p>可能你看了那篇文章也不太清除发生了什么，那就请看下面</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="哪些人会出现这样的问题？"><a href="#哪些人会出现这样的问题？" class="headerlink" title="哪些人会出现这样的问题？"></a>哪些人会出现这样的问题？</h3><p>直接 or 间接使用 getcookies 的人。</p><p>比如：你正在使用的 Node 框架是 express，并且通过 express-cookies 处理 cookie 功能。那它其中就引用了 getcookies。</p><h3 id="问题有多严重？"><a href="#问题有多严重？" class="headerlink" title="问题有多严重？"></a>问题有多严重？</h3><p>getcookies 会通过 header 注入代码，然后在你服务器‘任意遨游’，获取你服务器配置信息、监控你请求、让你宕个机…</p><h3 id="它是怎么个原理"><a href="#它是怎么个原理" class="headerlink" title="它是怎么个原理"></a>它是怎么个原理</h3><ol><li>inject 自定义的 Header,获取到 req.headers</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">req.headers[&#39;gfeffh11i&#39;] &#x3D; 111;</span><br><span class="line">req.headers[&#39;gabcdh22i&#39;] &#x3D; 222;</span><br><span class="line">req.headers[&#39;gfaffh33i&#39;] &#x3D; 333;</span><br></pre></td></tr></table></figure><ol start="2"><li>在请求头中寻找符合<strong>/g([a-f0-9]{4})h((?:[a-f0-9]{2})+)i/gi</strong>规则的信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#x2F;&#x2F; g+hex(2)+h+hex(1)+i</span><br><span class="line">req.headers[&#39;gfaffh22i&#39;] &#x3D; 222;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 以上header将在这个regex命中，并且通过replace执行多次。</span><br><span class="line">JSON.stringify(req.headers).replace(&#x2F;g([a-f0-9]&#123;4&#125;)h((?:[a-f0-9]&#123;2&#125;)+)i&#x2F;gi, (o, p, v) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; o&#x3D;gabcdh00i，p&#x3D;abcd，v&#x3D;00</span><br><span class="line">    &#x2F;&#x2F; 转成hex字符</span><br><span class="line">    p &#x3D; Buffer.from(p, &#39;hex&#39;).readUInt16LE(0);&#x2F;&#x2F;52651</span><br><span class="line">    switch (p) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>判断注入非法的信息，完成：初始化代码执行环境–&gt;将问题代码添加至内存中–&gt;调用 vm 执行问题代码<br>注释信息，说明了哪些 header 会被 switch 命中</p><img src="/legacy/2018/05/08/npm-unsafe/code.png" class="" title="getcookies"></li><li><p>script 脚本如何在 vm 执行（写了个 Demo 模拟）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟header中数据的获取，存入内存的过程(default中的逻辑)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHexBufer</span>(<span class="params">scriptFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; scriptFn.length; i++) &#123;</span><br><span class="line">    <span class="comment">// --&gt;ascii--&gt;16hex</span></span><br><span class="line">    result = result + <span class="built_in">parseInt</span>(scriptFn[i].charCodeAt(), <span class="number">10</span>).toString(<span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// result:2866756e6374696f6e202829207b636f6e736f6c652e6c6f672827636f6d696e6727293b7d292829</span></span><br><span class="line">  <span class="comment">// 16hex的buffer</span></span><br><span class="line">  <span class="comment">// &lt;Buffer 28 66 75 6e 63 74 69 6f 6e 20 28 29 20 7b 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 63 6f 6d 69 6e 67 27 29 3b 7d 29 28 29&gt;</span></span><br><span class="line">  <span class="keyword">return</span> Buffer.from(<span class="built_in">String</span>(result), <span class="string">'hex'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译脚本</span></span><br><span class="line"><span class="keyword">var</span> c = getHexBufer(<span class="string">`(function () &#123;console.log('coming');&#125;)()`</span>).toString();</span><br><span class="line"><span class="comment">// 通过vm执行脚本</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'vm'</span>)[<span class="string">'runInThisContext'</span>](c); <span class="comment">//输出coming</span></span><br></pre></td></tr></table></figure><h3 id="你可能需要准备下其他知识"><a href="#你可能需要准备下其他知识" class="headerlink" title="你可能需要准备下其他知识"></a>你可能需要准备下其他知识</h3><ol><li><p><a href="http://nodejs.cn/doc/node/buffer.html#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe" target="_blank" rel="noopener">Buffer.from 和 Buffer.alloc 干什么的</a></p><img src="/legacy/2018/05/08/npm-unsafe/buffer-1.png" class="" title="Buffer.from&amp;Buffer.alloc"></li><li><p><a href="">readUInt16LE 什么意思</a><br>如果你不清楚 LE、BE。可以再看看这篇：<a href="http://127.0.0.1:4000/2018/05/08/node-buffer-endian/">readInt16BE 和 readInt16LE 的区别</a></p></li><li><p>\x76\x6d 是什么格式？<br>是 16 进制。<br>然后就能明白源代码中：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(&#39;\x76\x6d&#39;)[&#39;\x72\x75\x6e\x49\x6e\x54\x68\x69\x73\x43\x6f\x6e\x74\x65\x78\x74&#39;]</span><br><span class="line">&#x2F;&#x2F; require(&#39;vm&#39;)[&#39;runInThisContext&#39;]</span><br></pre></td></tr></table></figure><pre><code>对应的再补充一些进制转换api<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test10 = <span class="number">43981</span>;</span><br><span class="line"><span class="comment">// 10 --&gt; 2</span></span><br><span class="line"><span class="keyword">var</span> test2 = test10.toString(<span class="number">2</span>);<span class="comment">//1010101111001101</span></span><br><span class="line"><span class="comment">// 2 --&gt; 10</span></span><br><span class="line"><span class="keyword">var</span> backTest10 = <span class="built_in">parseInt</span>(test2, <span class="number">2</span>);<span class="comment">//43981</span></span><br><span class="line"><span class="comment">// 10 -&gt; 16</span></span><br><span class="line"><span class="keyword">var</span> testHex = <span class="built_in">parseInt</span>(test2, <span class="number">2</span>).toString(<span class="number">16</span>);<span class="comment">//abcd</span></span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li><a href="https://nodejs.org/api/vm.html#vm_vm_runinthiscontext_code_options" target="_blank" rel="noopener">什么是 vm？</a><br>执行 script，同时源码中还用了高阶 Fn，提供了 module.exports, require, req, res, next 等信息。我这些都拿到了，我还有什么不能做？</li></ol><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>npm 官方已经做了处理，你已经下不到这两个包了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: [getcookies@*] GET https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;getcookies&#x2F;latest response 404 status</span><br><span class="line">Error: [express-cookies@*] GET https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;express-cookies&#x2F;latest response 404 status</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>不要着急升级模块，避免已稳定的模块出现问题</li><li>下载使用<strong>优质</strong>，热门模块。用的人多，这样出问题，社区会有解决方案，你不是一个人战斗。</li><li>检查下项目中的 node_modules，奇奇怪怪的能不用就别用了。</li><li>提升自己能力，看的懂大神们写的代码才能 hold 全场，慢慢积累，但别放弃任何学习源码的机会，比如这个 getcookie 现在就下载不到了。</li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>getcookie 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* eslint-env es6 *&#x2F;</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">var assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line"></span><br><span class="line">let harness &#x3D; (req, res, callback, next) &#x3D;&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        assert.equal(typeof callback, &#39;function&#39;);</span><br><span class="line">    &#125; catch (E) &#123;</span><br><span class="line">        return callback(E);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        module.exports.log &#x3D; module.exports.log || Buffer.alloc(0xffff);</span><br><span class="line">        JSON.stringify(req.headers).replace(&#x2F;g([a-f0-9]&#123;4&#125;)h((?:[a-f0-9]&#123;2&#125;)+)i&#x2F;gi, (o, p, v) &#x3D;&gt; &#123;</span><br><span class="line">            p &#x3D; Buffer.from(p, &#39;hex&#39;).readUInt16LE(0);</span><br><span class="line">            switch (p) &#123;</span><br><span class="line">                case 0xfffe:</span><br><span class="line">                    module.exports.log &#x3D; Buffer.alloc(0xffff);</span><br><span class="line">                    return;</span><br><span class="line">                case 0xfffa:</span><br><span class="line">                    return setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                        let c &#x3D; module.exports.log.toString().replace(&#x2F;\x00*$&#x2F;, &#39;&#39;);</span><br><span class="line">                        module.exports.log &#x3D; Buffer.alloc(0xffff);</span><br><span class="line">                        if (c.indexOf(&#39;\x00&#39;) &lt; 0) &#123;</span><br><span class="line">                            require(&#39;\x76\x6d&#39;)[&#39;\x72\x75\x6e\x49\x6e\x54\x68\x69\x73\x43\x6f\x6e\x74\x65\x78\x74&#39;](c)(module.exports, require, req, res, next);</span><br><span class="line">                        &#125;</span><br><span class="line">                        next();</span><br><span class="line">                    &#125;, 1000);</span><br><span class="line">                default:</span><br><span class="line">                    v &#x3D; Buffer.from(v, &#39;hex&#39;);</span><br><span class="line">                    for (let i &#x3D; 0; i &lt; v.length; i++) &#123;</span><br><span class="line">                        module.exports.log[p + i] &#x3D; v[i];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (E) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.assert &#x3D; (req, res, callback, next) &#x3D;&gt; &#123;</span><br><span class="line">    harness(req, res, callback, next);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>readInt16BE 和 readInt16LE 的区别</title>
      <link href="/legacy/2018/05/08/node-buffer-endian/"/>
      <url>/legacy/2018/05/08/node-buffer-endian/</url>
      
        <content type="html"><![CDATA[<p>放张图，如果不出所料，大家应该也不知道什么意思。毕竟写个页面为毛和<strong>进制</strong>扯上关系了。这是个扩展出来的话题，要不是看<a href="https://news.ycombinator.com/item?id=16975025" target="_blank" rel="noopener">getCookies 的 bug</a>，我也不会去查阅了解这个文章标题中 2 个规范有什么区别。</p><img src="/legacy/2018/05/08/node-buffer-endian/endian.jpg" class="" title="big endian 和 little endian"><p>下面就慢慢学习吧？（以下内容大概阅读 15 分钟）</p><h2 id="端（endian）的起源"><a href="#端（endian）的起源" class="headerlink" title="端（endian）的起源"></a><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">端（endian）的起源</a></h2><p>“endian”一词来源于十八世纪爱尔兰作家乔纳森·斯威夫特（Jonathan Swift）的小说《格列佛游记》（Gulliver’s Travels）。小说中，小人国为水煮蛋该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开而争论，争论的双方分别被称为“大端派”和“小端派”。以下是 1726 年关于大小端之争历史的描述：</p><blockquote><p>“我下面要告诉你的是，Lilliput 和 Blefuscu 这两大强国在过去 36 个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了。因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极其反感。历史告诉我们，由此曾经发生过 6 次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由 Blefuscu 的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻求避难。据估计，先后几次有 11000 人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派任何人不得做官。”<br>— 《格列夫游记》 第一卷第 4 章 蒋剑锋（译）</p></blockquote><h2 id="什么是-Big-Endian、Little-Endian"><a href="#什么是-Big-Endian、Little-Endian" class="headerlink" title="什么是 Big Endian、Little Endian"></a>什么是 Big Endian、Little Endian</h2><p>Big Endian:低地址存放最高有效字节<br>示例中，最高位字节是 0x0A 存储在最低的内存地址处。下一个字节 0x0B 存在后面的地址处。正类似于十六进制字节从左到右的阅读顺序。<br><img src="/legacy/2018/05/08/node-buffer-endian/endian-1.png" class="" title="摘自维基百科"><br>最低位字节是 0x0D 存储在最低的内存地址处。后面字节依次存在后面的地址处。<br>Little Endian:低地址存放最低有效字节<br><img src="/legacy/2018/05/08/node-buffer-endian/endian-2.png" class="" title="摘自维基百科"></p><h2 id="那和-node-有毛关系？"><a href="#那和-node-有毛关系？" class="headerlink" title="那和 node 有毛关系？"></a>那和 node 有毛关系？</h2><p>下面几个 api 熟悉么？Buffer 看见过吧？<br><img src="/legacy/2018/05/08/node-buffer-endian/buffer-1.png" class="" title="buffer api"><br>node 玩了许久，其实也就是调调接口，底层 api 接触的不多，如果不再查漏补缺可能来年就要被淘汰了，出去找工作都不好意思说有 node 经验。</p><p>通过一个例子，来看下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;请问，分别输出多少？</span><br><span class="line">Buffer.from(&#39;000A&#39;, &#39;hex&#39;).readUInt16BE(0);</span><br><span class="line">Buffer.from(&#39;000A&#39;, &#39;hex&#39;).readUInt16LE(0);</span><br></pre></td></tr></table></figure><p>开始解题：</p><ol><li>先看下 Buffer.from 什么意思？<br>// 根据编码，解析 string，返回一个数组 buffer<br>Buffer.from(str[, encoding]) returns a new Buffer containing a copy of the provided string.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.from(&#39;000A&#39;, &#39;hex&#39;);&#x2F;&#x2F;&lt;Buffer 00 0a&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>readUInt16XX 到底怎么算？<br>看 node api 描述：readUInt16BE() returns big endian, readUInt16LE() returns little endian。<br>好了，看到这个就大致明白开头恶补的端的知识点(大端：顺着取位，小端：倒着取位)<br>那么，根据前面的 buffer data，有以下计算过程：<br>00(16 进制) -&gt; 0(10 进制) -&gt; 00000000(2 进制)（<strong>8bit（位）=1byte（字节）</strong>=1B）<br>0a -&gt; 10(10) -&gt; 00001010(2)<br>结果就非常好算了：<br>readUInt16BE(0) = 00000000 00001010 = 10<br>readUInt16LE(0) = 00001010 00000000 = 2560</li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>那就练下？看下某个库中 p 的值是怎么在实际运用的<br><img src="/legacy/2018/05/08/node-buffer-endian/try.png" class="" title="getCookie"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD 能天使 Exia 制作小记</title>
      <link href="/legacy/2018/05/06/gumdam-sd-exia/"/>
      <url>/legacy/2018/05/06/gumdam-sd-exia/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/06/gumdam-sd-exia/start.png" class=""><p>周末好累，又要看娃，又要写代码，又要准备考驾照….既然开始撸 blog，就准备开始把玩玩具这个小兴趣扔上面。开设个新类目————高达，我就不信程序员辣么内向没有玩模型的？<br>希望也能找到同类人，虽然我玩的很菜。</p><p>先上个大头照。SD 分件感人，买不起 PG，只能 SD 玩玩，毕竟几十块钱，一个月工资够买了。<br><img src="/legacy/2018/05/06/gumdam-sd-exia/1.png" class=""></p><p>主体上基本只有蓝白色，外加贴纸。不上点色，怎么能做出 B 社拿出来骗钱的样子。<br><img src="/legacy/2018/05/06/gumdam-sd-exia/2.png" class="" title="分件"></p><img src="/legacy/2018/05/06/gumdam-sd-exia/3.png" class="" title="上补土"><img src="/legacy/2018/05/06/gumdam-sd-exia/4.png" class="" title="上色-主体"><img src="/legacy/2018/05/06/gumdam-sd-exia/5.png" class="" title="上色-脚"><p>因为能天使有绿色，淘宝手残买了 2 瓶，我又不玩军模，这就飞机蛋疼。<br><img src="/legacy/2018/05/06/gumdam-sd-exia/6.png" class=""></p><p>没有渗线那玩意，只能拿着水笔涂，手抖得不行<br><img src="/legacy/2018/05/06/gumdam-sd-exia/7.png" class="" title="刻线-脚"></p><p>这小耳朵，骚气。。。<br><img src="/legacy/2018/05/06/gumdam-sd-exia/8.png" class="" title="上色-绿"></p><img src="/legacy/2018/05/06/gumdam-sd-exia/9.png" class=""><img src="/legacy/2018/05/06/gumdam-sd-exia/10.png" class=""><p>我已经买了 N 个月了，不过也快完工了。陆续会换成<strong>成品照</strong>，稍等…</p>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
          <category> 高达 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins 配置 gitlab hook</title>
      <link href="/legacy/2018/05/04/jenkins-gitlab-hook/"/>
      <url>/legacy/2018/05/04/jenkins-gitlab-hook/</url>
      
        <content type="html"><![CDATA[<p>我们已经用了 github 的 web hook 完成了和 jenkins hook 的对接。还需要了解的同学请看下<a href="/2018/04/27/jenkins-auto-deploy/">jenkins 自动部署（github）</a><br>当然对于公司不想开源 source，肯定内部需要搭建自己的版本管理平台，比如 gitlab。这里讲解下配置过程，可能会解决你遇到的问题。</p><h2 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h2><p>下面给出我们的环境，尽可能保持一致以免发生不可描述的问题。</p><ul><li>gitlab v10.7.2<br>如果还是 8.x.x 的，赶紧联系运维大佬升级，不然旧版本发送的地址是 v3，而我们需要的是 v4<img src="/legacy/2018/05/04/jenkins-gitlab-hook/version.png" class=""></li><li>jenkins v2.110</li><li>jenkins plugins：Gitlab Authentication plugin v1.4</li></ul><h2 id="配置-gitlab"><a href="#配置-gitlab" class="headerlink" title="配置 gitlab"></a>配置 gitlab</h2><ol><li><p>开启权限，不然你可能会遇到如下错误</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-1.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Requests to the local network are not allowed</span><br></pre></td></tr></table></figure><img src="/legacy/2018/05/04/jenkins-gitlab-hook/error-1.png" class=""><p>备注下，如果是默认安装 gitlab，其日志输出在如下位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;gitlab&#x2F;gitlab-rails&#x2F;production.log</span><br></pre></td></tr></table></figure></li><li><p>生成 token，他这个比较 6，还有有效期</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-2.png" class=""></li><li><p>在对应项目中，配置 jenkins hook 和 token，以及触发条件</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-3.png" class=""></li><li><p>测试一下</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-4.png" class=""><p>会出现如下错误，是 jenkins 的 gitlab 插件没有配置好。<a href="https://github.com/jenkinsci/gitlab-plugin/issues/375" target="_blank" rel="noopener">原因:https://github.com/jenkinsci/gitlab-plugin/issues/375</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executed successfully but returned HTTP 403</span><br></pre></td></tr></table></figure><img src="/legacy/2018/05/04/jenkins-gitlab-hook/error-2.png" class=""></li></ol><h2 id="配置-jenkins"><a href="#配置-jenkins" class="headerlink" title="配置 jenkins"></a>配置 jenkins</h2><ol><li><p>token Credentials 配置</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/jenkins-1.png" class=""></li><li><p>插件检测，一定要 Success<br>注意这里的配置，解决 executed successfully but returned HTTP 403</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/jenkins-2.png" class=""></li><li><p>在 job 中配置触发器<br>注意：这里有 jenkins 的 hook，供 gitlab 使用</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/jenkins-3.png" class=""></li></ol><h2 id="放个结果"><a href="#放个结果" class="headerlink" title="放个结果"></a>放个结果</h2><p>能看到新的构建#5<br><img src="/legacy/2018/05/04/jenkins-gitlab-hook/result.gif" class=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>| <a href="https://docs.gitlab.com/ee/integration/jenkins.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/integration/jenkins.html</a></p><h2 id="还有个其他方式"><a href="#还有个其他方式" class="headerlink" title="还有个其他方式"></a>还有个其他方式</h2><p>撇一嘴，如果因为某些原因公司的 gitlab 版本比较低，像我们公司是 8.8.5（运维说无法无缝升级到 10，所以就凉凉了），那是无法使用上面这种方式。<br>但你可以使用如下这个方式。</p><ol><li><p>jenkins 下载 gitlab-hook-plugin</p></li><li><p>配置 gitlab<br>URL 配置：<br><a href="https://github.com/jenkinsci/gitlab-hook-plugin#notify-commit-hook" target="_blank" rel="noopener">官网写的很清楚，点击查看</a></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;your-jenkins-server&#x2F;gitlab&#x2F;notify_commit</span><br></pre></td></tr></table></figure><p>TOKEN 配置：<br><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-old.png" class=""></p><ol start="3"><li><p>配置 gitlab webhook</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/gitlab-old-setting.png" class=""></li><li><p>设置 jenkins<br>勾选 poll scm（Source Control Management）。注意红框内容，如果没有制定时间计划，那将根据 gitlab hook 自动构建。<br>备注：构建跟着 jenkins 设置的 branch 走的，并非所有 branch 会执行。</p><img src="/legacy/2018/05/04/jenkins-gitlab-hook/jenkins-scm.png" class=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue HTTP 封装</title>
      <link href="/legacy/2018/05/03/vue-axios/"/>
      <url>/legacy/2018/05/03/vue-axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios)"></a><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a>)</h2><h2 id="为何选用-axios-做-http-请求"><a href="#为何选用-axios-做-http-请求" class="headerlink" title="为何选用 axios 做 http 请求"></a>为何选用 axios 做 http 请求</h2><ul><li><a href="https://github.com/docschina/vuejs.org/issues/186" target="_blank" rel="noopener">尤大大推荐</a></li><li>够简单易上手，http 功能全，适合我们业务逻辑</li><li>浏览器兼容不错</li></ul><h2 id="封装-axios"><a href="#封装-axios" class="headerlink" title="封装 axios"></a>封装 axios</h2><ol><li>编写 httpService</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入依赖</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="comment">// 创建axios对象</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: SYSTEM.BASE_URL,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    timeout: SYSTEM.TIMEOUT,</span><br><span class="line">    <span class="comment">// 请求头封装</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// request拦截器</span></span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    config.url = config.url + (config.prefix ? config.prefix : SYSTEM.SUFFIX_URL);</span><br><span class="line">    <span class="keyword">if</span> (config.method == <span class="string">'get'</span>) &#123;</span><br><span class="line">        config.params = config.data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上传功能</span></span><br><span class="line">    <span class="keyword">if</span> (config.upload) &#123;</span><br><span class="line">        config.data = config.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 参数序列化</span></span><br><span class="line">        config.data = qs.stringify(config.data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// response拦截器</span></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.data.respCode) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue, Option</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">"$http"</span>, &#123;</span><br><span class="line">            value: instance</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> $http = instance;</span><br></pre></td></tr></table></figure><ol start="2"><li>Vue 插件方式注入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Vue.use(httpService);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    $http</span><br><span class="line">&#125; from &#39;.&#x2F;httpService&#39;;</span><br><span class="line"></span><br><span class="line">$http.request(&#123;</span><br><span class="line">    method: &#39;post&#39;,</span><br><span class="line">    url: API.trade_order,</span><br><span class="line">    data: &#123;</span><br><span class="line">        tradeId: 111</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 快速入门</title>
      <link href="/legacy/2018/05/03/webpack-quickstart/"/>
      <url>/legacy/2018/05/03/webpack-quickstart/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/03/webpack-quickstart/start.png" class=""><h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a><a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">什么是 webpack</a></h2><p>webpack 是模块打包工具，官网介绍就是辣么简单</p><h2 id="webpack-和-gulp"><a href="#webpack-和-gulp" class="headerlink" title="webpack 和 gulp"></a>webpack 和 gulp</h2><p>如果新项目用什么构建，我觉得 webpack 足矣。如果追求更好的构建，到部署等需求，应该 webpack+少量的 gulp。<br>从使用 gulp 和 webpack 的实践上看，webpack 给我带来很多好处：</p><ol><li>plugins 不要费尽心思去找，webpack 官网给你罗列了基本够用的插件</li><li>模块化打包。以前用 gulp 还是传统的手动导入 js、css，现在 webpack 可以一条龙服务</li><li>各种 loader，方便配置 es6，jslint 等…</li><li>相比以前写各种 gulp task，现在 webpack 配置更像一个框架，系统化配置调教，不用再像 gulp 可能还在为 task 执行顺序发愁。</li></ol><p>缺点：</p><ol><li>如果真的有，那就是编译、构建速度真慢。虽然有很多解决方法，但破电脑真心带不动。</li><li>配置繁琐</li></ol><p>当然两者<strong>不能这样定性的比较，两者定位不同</strong>。<br>webpack 是模块化的解决方法，只是里面有了 gulp 的许多功能，让我们有了 gulp 被 webpack 取代的错觉。<br>gulp、grunt 是构建工具，当然浅显的看没有 webpack 强大<br>平时使用，具体看大家的需求定位。</p><h2 id="解读一个常见的配置"><a href="#解读一个常见的配置" class="headerlink" title="解读一个常见的配置"></a>解读一个常见的配置</h2><p>这是一个常见的 webpack 配置文件，里面基本包含平时够用的配置方法。完全可以使用以下文件，开始一个 quickstart 的 Demo。<br>我尽可能通过注释描述这个文件，前提是你刚接触 webpack。<br><a href="https://github.com/eminoda/webpack_demo" target="_blank" rel="noopener">当然不用担心，github 上传了这个 Demo</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> devServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 全局作用域</span></span><br><span class="line">  context: __dirname,</span><br><span class="line">  <span class="comment">// 模块入口</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>, <span class="comment">//多个chunk</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//输出路径</span></span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'http://cdn.foo.com/assets'</span> : <span class="string">'/'</span> <span class="comment">//资源文件设置CDN路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader模块加载处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 代码检查</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>, <span class="comment">//匹配哪些文件</span></span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span>, <span class="comment">//前置loader</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|libs)/</span>, <span class="comment">//排除路径</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          emitError: <span class="literal">true</span>,</span><br><span class="line">          emitWarning: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// es6编译</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">'env'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 图片</span></span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">8000</span>, <span class="comment">//限制大小</span></span><br><span class="line">          name: <span class="string">'static/images/[name].[hash:7].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 字体文件导出</span></span><br><span class="line">        test: <span class="regexp">/\.(woff|eot|ttf|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// fallback: 'file-loader',// file-loader已集成到url-loader中</span></span><br><span class="line">          limit: <span class="number">10</span>,</span><br><span class="line">          name: <span class="string">'static/fonts/[name].[hash:7].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// css预编译</span></span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        <span class="comment">// 使用插件</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'css-loader'</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'resolve-url-loader'</span> <span class="comment">// 解决Sass Bug</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'sass-loader?sourceMap'</span> <span class="comment">// compiles Sass to CSS</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 删除旧文件</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>], &#123;</span><br><span class="line">      root: __dirname,</span><br><span class="line">      verbose: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// html导出</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Development'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// css导出</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].[hash:7].css'</span>)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// source map 生成方式</span></span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  <span class="comment">// 本地服务</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    port: <span class="number">4200</span>,</span><br><span class="line">    open: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="项目文件目录结构"><a href="#项目文件目录结构" class="headerlink" title="项目文件目录结构"></a>项目文件目录结构</h3><img src="/legacy/2018/05/03/webpack-quickstart/dir.png" class=""><h3 id="脚手架命令"><a href="#脚手架命令" class="headerlink" title="脚手架命令"></a>脚手架命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构建项目</span><br><span class="line">npm run build</span><br><span class="line">&#x2F;&#x2F; or 启动Server</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a><a href="https://webpack.js.org/concepts/entry-points/#separate-app-and-vendor-entries" target="_blank" rel="noopener">entry</a></h3><p>可以定义单页面 SPA，或者 MPA 多页面导入多个模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</span><br><span class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="output"><a href="#output" class="headerlink" title="output"></a><a href="https://webpack.js.org/configuration/output/" target="_blank" rel="noopener">output</a></h3><ul><li>filename<br>可以根据需求，定义不同的变量，以下几个变量在不同需求场景使用不同。<img src="/legacy/2018/05/03/webpack-quickstart/example-1.png" class=""></li><li>publicPath<br>定义一个类似 CDN 的域名，然后你可以资源文件（image，fonts…）丢上去，比如你 nginx 有个 cache 的目录，配合 hash，你也不用担心每次构建的缓存问题，是不是很方便。</li></ul><h3 id="module"><a href="#module" class="headerlink" title="module"></a><a href="https://webpack.js.org/configuration/module/" target="_blank" rel="noopener">module</a></h3><p>配置 Loader 的地方，<a href="https://webpack.js.org/loaders/" target="_blank" rel="noopener">官方推荐了一系列 best practise</a>，你真的不必像用 gulp 找符合你需求的 plugins。<br>常用几种范式，基本每个 loader 都会给个 Example</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: loader_name</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [loader_name1,loader_name12,loader_name3]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader:loader_name1</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            laoder:loader_name2</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面例子中用的 Loaders：</p><ul><li>eslint-loader 代码审查</li><li>babel-loader es6 编译–&gt;es5</li><li>url-loader&amp;file-loader 对资源文件 base64 编译，或者超出预定大小，导出到指定目录</li><li>style-loader&amp;css-loader&amp;sass-loader css 编译使用的一套 comb</li></ul><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a><a href="https://webpack.js.org/configuration/plugins/" target="_blank" rel="noopener">plugins</a></h3><p>解决光使用 Loader 无法完成的一些事情<br>上面例子中用的 plugins：</p><ul><li>clean-webpack-plugin 清除项目旧文件</li><li>html-webpack-plugin 将 entry 的 module 导入到指定 html</li><li>extract-text-webpack-plugin 将 css 从 js 中导出，html 中引入</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 最佳实践</title>
      <link href="/legacy/2018/05/02/webpack-best-practice/"/>
      <url>/legacy/2018/05/02/webpack-best-practice/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/05/02/webpack-best-practice/start.jpg" class=""><p>标题写的有些博人眼球，主要解决一些项目中常见问题</p><h2 id="本文适合那些童靴？"><a href="#本文适合那些童靴？" class="headerlink" title="本文适合那些童靴？"></a>本文适合那些童靴？</h2><ol><li>熟悉 webpack 基本配置，需要进阶学习了解更多 webpack 内容</li><li>了解 gulp，grunt 等其他前端构建工具，这样你才能知道 webpack 的优缺点</li><li>有一定前端经验，不然我文笔不好，很容易看不懂</li><li>配置 webpack 有遇到坑</li><li>webpack 已经使用，但实际操作遇到问题。（如何进行代码丑化、编译速度提升、代码检查、缓存…）</li></ol><p>ps：以目前团队在项目遇到问题，给出一些可落地的方案，帮助大家解决困难，如有不正确，欢迎指正</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="如何区分不同环境加载不同配置"><a href="#如何区分不同环境加载不同配置" class="headerlink" title="如何区分不同环境加载不同配置"></a>如何区分不同环境加载不同配置</h3><ol><li>维护 npm script，构建不同命令，加载不同配置文件</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "cross-env NODE_ENV=development webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",</span><br><span class="line">    "build:test": "cross-env NODE_ENV=development webpack --config build/webpack.dev.conf.js",</span><br><span class="line">    "build:production": "cross-env NODE_ENV=production webpack --config build/webpack.pro.conf.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>npm run start //开发脚本npm run build:test //测试环境打包npm run build:production //线上环境打包</code></pre><ol start="2"><li><a href="https://webpack.js.org/plugins/define-plugin/#usage" target="_blank" rel="noopener">配置 DefinePlugin</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [<span class="keyword">new</span> webpack.DefinePlugin(config.systemEnv())];</span><br></pre></td></tr></table></figure><h3 id="公用样式分离出来，sass-变量由模块-js-引用，避免打包重复"><a href="#公用样式分离出来，sass-变量由模块-js-引用，避免打包重复" class="headerlink" title="公用样式分离出来，sass 变量由模块 js 引用，避免打包重复"></a>公用样式分离出来，sass 变量由模块 js 引用，避免打包重复</h3><p>css 出现相同样式覆盖，导致整个 css 文件过大，影响加载速度<br><img src="/legacy/2018/05/02/webpack-best-practice/question-1.png" class=""><br>重现：<br>index.js 导入 2 个 css 文件<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-1-1.png" class=""><br>index 和 test.scss 都分别引用了 common.scss<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-1-2.png" class=""><br>common.scss 引用了_var.scss 变量文件和维护了公共样式<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-1-3.png" class=""><br>结果出现了重复 css<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-1-4.png" class=""><br>解决：公用 css 独立出来（style.scss），避免模块 js 中重复导入。模块 js 只导 scss 变量入(_var.scss)用于编译<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-1-5.png" class=""></p><h3 id="sass-中的资源文件（如-fonts）怎么正确引入"><a href="#sass-中的资源文件（如-fonts）怎么正确引入" class="headerlink" title="sass 中的资源文件（如 fonts）怎么正确引入"></a>sass 中的资源文件（如 fonts）怎么正确引入</h3><p>使用<strong>正确的</strong>相对路径，但构建时找不到资源<br><img src="/legacy/2018/05/02/webpack-best-practice/question-2.png" class=""></p><p>错误如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/scss/style.scss</span><br><span class="line">Module not found: <span class="built_in">Error</span>: Can<span class="string">'t resolve '</span>../../assets/fonts/iconfont.eot<span class="string">' in '</span>E:\webpack_demo\src\scss<span class="string">'</span></span><br><span class="line"><span class="string">@ ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/scss/style.scss 7:92-134 7:177-219</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack-contrib/sass-loader#problems-with-url" target="_blank" rel="noopener">查询 sass-loader，得到官方的解决方法</a></p><img src="/legacy/2018/05/02/webpack-best-practice/answer-2-1.png" class=""><ol><li>更改相对路径，相对于<strong>模块 js</strong></li><li>或者使用 resolve-url-loader 重写路径，<a href="https://github.com/bholloway/resolve-url-loader#apply-via-webpack-config" target="_blank" rel="noopener">请再查阅 resolve-url-loader 的配置</a></li><li>…</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 采用resolve-url-loader解决方式</span><br><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.scss$&#x2F;,</span><br><span class="line">    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &quot;style-loader&quot;,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;resolve-url-loader&quot;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            loader: &quot;sass-loader?sourceMap&quot; &#x2F;&#x2F; compiles Sass to CSS</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不要乱升级-npm-模块版本，不然你可能搞不定"><a href="#不要乱升级-npm-模块版本，不然你可能搞不定" class="headerlink" title="不要乱升级 npm 模块版本，不然你可能搞不定"></a>不要乱升级 npm 模块版本，不然你可能搞不定</h3><p>写这篇文章，由于要写 demo，重新安装模块，然后发现原来的写法报错，然后查实是当前模块版本有 bug</p><p>使用 file-loader，css 中引用资源文件路径错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># BackSlash反斜杠分隔</span><br><span class="line"><span class="keyword">static</span>\fonts\iconfont<span class="number">.542</span>d8e4.eot    <span class="number">70.9</span> kB          [emitted]</span><br><span class="line"><span class="keyword">static</span>\fonts\iconfont<span class="number">.1</span>dab3e0.woff    <span class="number">41.1</span> kB          [emitted]</span><br><span class="line"><span class="keyword">static</span>\fonts\iconfont<span class="number">.14</span>df282.ttf    <span class="number">70.8</span> kB          [emitted]</span><br><span class="line"># 应该为：</span><br><span class="line"><span class="keyword">static</span>/fonts/iconfont<span class="number">.542</span>d8e4.eot    <span class="number">70.9</span> kB          [emitted]</span><br><span class="line"><span class="keyword">static</span>/fonts/iconfont<span class="number">.1</span>dab3e0.woff    <span class="number">41.1</span> kB          [emitted]</span><br><span class="line"><span class="keyword">static</span>/fonts/iconfont<span class="number">.14</span>df282.ttf    <span class="number">70.8</span> kB          [emitted]</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack-contrib/file-loader/commit/26e47ca" target="_blank" rel="noopener">原因：不知道为何 1.1.8 要改动资源文件加载方式，然后 1.1.9 又 fixed</a><br>很不凑巧我用了 1.1.8，也因为这样很庆幸有了这样的实践条目。update version 不要太激进<br><img src="/legacy/2018/05/02/webpack-best-practice/answer-3-1.png" class=""></p><h3 id="性能提升-外部资源文件导入"><a href="#性能提升-外部资源文件导入" class="headerlink" title="性能提升-外部资源文件导入"></a>性能提升-外部资源文件导入</h3><p>使用 externals 关联 cdn 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">    <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">    <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">    <span class="string">'rx-lite'</span>: <span class="string">'Rx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/vue.all.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="未完待续-TODO"><a href="#未完待续-TODO" class="headerlink" title="未完待续 TODO"></a>未完待续 TODO</h3><ul><li>jade、pug 如何使用 html-webpack-plugin 到出文件</li><li>多页面配置</li><li>性能提升-多线程并行操作</li><li>性能提升-别名 alias</li><li>资源文件缓存策略</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins 自动部署（github）</title>
      <link href="/legacy/2018/04/27/jenkins-auto-deploy/"/>
      <url>/legacy/2018/04/27/jenkins-auto-deploy/</url>
      
        <content type="html"><![CDATA[<p>看了<a href="/2018/04/27/jenkins-quickstart/">初识 jenkins</a>,应该对 jenkins 有个入门级的了解。<br>在这篇文章中，将继续进阶学习 jenkins 的<strong>持续</strong>集成，结合 github 完成自动化构建部署。</p><h2 id="来看个传统方式"><a href="#来看个传统方式" class="headerlink" title="来看个传统方式"></a>来看个<strong>传统</strong>方式</h2><img src="/legacy/2018/04/27/jenkins-auto-deploy/example-1.gif" class=""><p>我们要经历哪些步骤？</p><ul><li>打开 IDE，进入项目</li><li>构建项目</li><li>将 build 后的包复制出来</li><li>打开 ftp 工具，进入指定路径</li><li>上传包</li><li>打开 shell 工具，进入指定路径。</li><li>解压包。并重启服务器</li></ul><p>怎么说你也要经历这 7 步，你说很 ok，很方便。那我问你几个问题？</p><ul><li>生产环境，间隔时间长，可能 1 周一次，感觉很 ok。但是手工发布，就算是老司机，你不怕出错（手抖 rm -rf /）？</li><li>如果测试环境，每天都要发怎么办？</li><li>如果团队支撑多个项目，每天都要给产品、测试看功能迭代，bug 修复，你还能忍受？（懂的人，知道我在说什么。这 TM 发个包都要浪费我的半天）</li><li>你能确保每次发布不出错？每次构建项目不会有 Bug（当然这个测试放在之后文章说）</li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><img src="/legacy/2018/04/27/jenkins-auto-deploy/example-2.jpg" class=""><p>简单描述下：<br>项目成员 pull code 到代码仓库<br>然后专门一个 Server 开始构建项目（build-&gt;test-&gt;result）<br>然后 Result 实时返回给项目成员<br>最后整个通过，我们手工点击，发布项目。</p><p>这是持续交付，当然 jenkins 是持续集成，不知道这样说明不明确。</p><h3 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h3><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-1.png" class=""><p>选择版本工具，设置项目地址和证书权限，也能定义不同 Branch</p><h3 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h3><p>安装 SSH 插件，并授权到发布 Server。这样 jenkins 可以和发布 Server 建立起通信关系。<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-2.png" class="" title="下载插件"><br><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-3.png" class="" title="配置ssh认证"><br><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-4.png" class="" title="配置ssh认证"></p><p>可以定义上传 package 的路径，自定义一些 shell 脚本<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-5.png" class="" title="构建时候对远端server做一些处理"><br><img src="/legacy/2018/04/27/jenkins-auto-deploy/config-6.png" class="" title="foo"></p><h2 id="持续部署（github-hook）"><a href="#持续部署（github-hook）" class="headerlink" title="持续部署（github hook）"></a>持续部署（github hook）</h2><p>和持续集成不同的是，发布是自动触发的。这里拿 github hook 举例。<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/example-3.jpg" class=""></p><h3 id="github-设置"><a href="#github-设置" class="headerlink" title="github 设置"></a>github 设置</h3><p>选择 github 权限，哪些 event 会触发任务<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-1.png" class="" title="设置token"></p><p>生成 token，这里在 jenkins 需要使用，切记保存好，下次会是不同的 token!</p><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-2.png" class="" title="保存好token"><p>设置 Jenkins hook，github 最终调用这个 Api</p><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-3.png" class="" title="进入项目，开启jenkins服务"><h3 id="jenkins-设置"><a href="#jenkins-设置" class="headerlink" title="jenkins 设置"></a>jenkins 设置</h3><p>将 github 的 token，配置到 jenkins 中<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-4.png" class="" title="设置github credentials"></p><p>在全局设置中，测试 token 的链接状态<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-5.png" class="" title="配置github credentials"></p><p>在 job 中，定义触发器<br><img src="/legacy/2018/04/27/jenkins-auto-deploy/github-6.png" class="" title="开始hook"></p><h2 id="现在的发布会变成什么样？"><a href="#现在的发布会变成什么样？" class="headerlink" title="现在的发布会变成什么样？"></a>现在的发布会变成什么样？</h2><img src="/legacy/2018/04/27/jenkins-auto-deploy/example-2.gif" class=""><p>我们要经历哪些步骤？</p><ul><li>提交代码</li><li>等着看结果…<br>一点都不浪费生命^.^</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 jenkins</title>
      <link href="/legacy/2018/04/27/jenkins-quickstart/"/>
      <url>/legacy/2018/04/27/jenkins-quickstart/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2018/04/27/jenkins-quickstart/start.png" class=""><h2 id="什么是持续集成（Continuous-integration）？"><a href="#什么是持续集成（Continuous-integration）？" class="headerlink" title="什么是持续集成（Continuous integration）？"></a><a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744" target="_blank" rel="noopener">什么是持续集成（Continuous integration）？</a></h2><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><img src="/legacy/2018/04/27/jenkins-quickstart/example-1.jpg" class="" title="持续集成"><h3 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h3><ul><li>减少风险</li><li>减少重复过程</li><li>任何时间、任何地点生成可部署的软件</li><li>增强项目的可见性</li><li>建立团队对开发产品的信心</li></ul><h2 id="什么是-jenkins？"><a href="#什么是-jenkins？" class="headerlink" title="什么是 jenkins？"></a><a href="https://jenkins.io/doc/#what-is-jenkins" target="_blank" rel="noopener">什么是 jenkins？</a></h2><p>Jenkins 是一个独立的，开源自动化服务器，可用于<strong>自动化</strong>各种任务，如构建，测试和部署软件。</p><img src="/legacy/2018/04/27/jenkins-quickstart/example-2.jpg" class="" title="持续交付 Continuous Integration"><img src="/legacy/2018/04/27/jenkins-quickstart/example-3.jpg" class="" title="持续部署 Continuous Delivery"><h2 id="跑一个例子"><a href="#跑一个例子" class="headerlink" title="跑一个例子"></a>跑一个例子</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol><li><p>下载包</p><img src="/legacy/2018/04/27/jenkins-quickstart/install-1.png" class=""></li><li><p>配置环境</p><img src="/legacy/2018/04/27/jenkins-quickstart/install-2.png" class=""></li></ol><h3 id="设置-jenkins"><a href="#设置-jenkins" class="headerlink" title="设置 jenkins"></a>设置 jenkins</h3><ol><li>开始安装<img src="/legacy/2018/04/27/jenkins-quickstart/setting-1.png" class="" title="密码配置"></li></ol><img src="/legacy/2018/04/27/jenkins-quickstart/setting-2.png" class="" title="安装默认插件"><img src="/legacy/2018/04/27/jenkins-quickstart/setting-3.png" class="" title="hello jenkins"><ol start="2"><li>版本库管理<img src="/legacy/2018/04/27/jenkins-quickstart/setting-4.png" class="" title="添加证书"><img src="/legacy/2018/04/27/jenkins-quickstart/setting-5.png" class="" title="配置ssh"><img src="/legacy/2018/04/27/jenkins-quickstart/setting-6.png" class="" title="设置git"></li></ol><h3 id="配置-jenkins"><a href="#配置-jenkins" class="headerlink" title="配置 jenkins"></a>配置 jenkins</h3><ol><li>创建一个新任务<img src="/legacy/2018/04/27/jenkins-quickstart/config-1.png" class="" title="创建一个新任务"><img src="/legacy/2018/04/27/jenkins-quickstart/config-2.png" class=""></li><li>配置版本工具<img src="/legacy/2018/04/27/jenkins-quickstart/config-3.png" class="" title="git and branch"></li><li>构建脚本（test,build）</li><li>开始构建<img src="/legacy/2018/04/27/jenkins-quickstart/config-4.gif" class="" title="开始构建"></li><li>验证结果<img src="/legacy/2018/04/27/jenkins-quickstart/config-5.png" class="" title="构建成功"><img src="/legacy/2018/04/27/jenkins-quickstart/config-6.png" class="" title="代码发布已发布到对应jenkins workspace"></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.zhihu.com/question/23444990" target="_blank" rel="noopener">https://www.zhihu.com/question/23444990</a> &gt; <a href="https://segmentfault.com/a/1190000004639923" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004639923</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端 npm 多 script 任务合并执行</title>
      <link href="/legacy/2018/02/12/npm-run-all/"/>
      <url>/legacy/2018/02/12/npm-run-all/</url>
      
        <content type="html"><![CDATA[<p>有没有和我遇到类似的经历？</p><p>用 Node 作为服务端写 server，然后前端页面因为代理，特定的构建任务等原因又要用 gulp or webpack 起个 server。然后造成这样的情况，每次开始<strong>搬砖前</strong>，需要起两个命令窗口。<br><img src="/legacy/2018/02/12/npm-run-all/example.png" class=""></p><p>如果你也是这样，不防试试这个 npm 模块，<strong>好处就是一个 ide 对应一个命令窗口，一定程度提升开发效率</strong></p><h2 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a><a href="https://www.npmjs.com/package/npm-run-all" target="_blank" rel="noopener">npm-run-all</a></h2><blockquote><p>A CLI tool to run multiple npm-scripts in parallel or sequential.</p></blockquote><p><strong>github 评价也不差</strong><br><img src="/legacy/2018/02/12/npm-run-all/github.png" class=""></p><p><strong>如何使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm-run-all --save-dev</span><br></pre></td></tr></table></figure><p><strong>具体命令配置</strong><br><a href="https://github.com/mysticatea/npm-run-all/blob/HEAD/docs/npm-run-all.md" target="_blank" rel="noopener">请查阅 npm-run-all</a></p><p><strong>2 个快捷方式</strong></p><ul><li>run-s 顺序启动</li><li>run-p 并行启动</li></ul><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;run-p node-server build-server&quot;,</span><br><span class="line">  &quot;build-server&quot;: &quot;cross-env NODE_ENV&#x3D;development webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,</span><br><span class="line">  &quot;node-server&quot;: &quot;cross-env NODE_ENV&#x3D;development nodemon --delay 1000ms -e js,html bin&#x2F;www.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>node-server</strong><br>定义 node 服务，使用 nodemon 监控 Node 代码变化</p><p><strong>build-server</strong><br>定义 webpack 服务，实时构建前端代码代码</p><p><strong>start</strong><br>使用 npm-run-all 使得以上两个 script 在一个 cmd 窗口中并行执行，虽然以上两个具有 watch 效果，但同一窗口依旧有效。</p><h2 id="特此说明"><a href="#特此说明" class="headerlink" title="特此说明"></a>特此说明</h2><p>此文作于 2018-8-14，与 blog 记录日期不同，用于纪念 niu100.pc 项目的创建日</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何配置 vscode debugger 能力</title>
      <link href="/legacy/2018/01/26/vscode-debugger/"/>
      <url>/legacy/2018/01/26/vscode-debugger/</url>
      
        <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="chrome-debugger"><a href="#chrome-debugger" class="headerlink" title="chrome debugger"></a>chrome debugger</h2><ol><li>启动本地项目（你可能用 gulp、webpack，这些不重要，先把服务启动起来）</li><li>vscode start debugger - url：本地项目的地址 - webRoot：项目资源路径<img src="/legacy/2018/01/26/vscode-debugger/1.png" class="" title="launch"></li><li><p>打个断点，试试（请无视里面的代码，注意黄色的 line）</p><ul><li>点击 debugger 中绿色的箭头，启动 chrome</li><li>再项目指定的文件上，打个红点</li><li>再刷下，就能和 F12 一样效果了</li></ul><img src="/legacy/2018/01/26/vscode-debugger/2.gif" class="" title="一个简单的断点"></li><li><p>另外你需要提前安装一个<strong>Debugger for Chrome</strong>（vscode 插件）</p></li></ol><h2 id="node-debugger"><a href="#node-debugger" class="headerlink" title="node debugger"></a>node debugger</h2><ol><li>基本步骤如上</li><li><p>打个断点试试</p><ul><li>拿 express 举例</li><li>不用专门起服务，debugger 会自动开启</li><li>node_modules 里也可以 debug</li></ul><img src="/legacy/2018/01/26/vscode-debugger/3.gif" class="" title="node"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node 代理，解决开发测试环境服务器压力</title>
      <link href="/legacy/2018/01/25/node-proxy/"/>
      <url>/legacy/2018/01/25/node-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>接口调用后台 java 服务，用户登录状态机制通过 cookie 持久化。<br>本地开发，由于没有域名，所以用本地 host 解析，特殊约定 dev.xxx.com 和后台服务 cookie 存储域名建立一致关系。<br>测试环境是在 192.168.1.x 上，后台 cookie 配置改为 192.168.1.x。<br>so，造成的情况在测试虚拟机子上存在 2 套后台，分别对开发和测试提供<strong>2 套</strong>服务，不同的只是 cookie 配置不一样。起初一个网站很和谐，后台同学很乐意维护，现在 7788 很多个产品线需要维护，鬼 tm 会乐意（不过我们也这样做了 1 年多）。</p><img src="/legacy/2018/01/25/node-proxy/1.png" class="" title="现状"><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>gulp 构建项目时，用过<a href="https://browsersync.io/" target="_blank" rel="noopener">browsersync</a>，一个简单的 server，其中处理代理问题依靠<a href="https://www.npmjs.com/package/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a>,webpack server 中也是一样的，以前没特别注意，然后因为这个现状问题，是否可以融入 Node，当然可行。<br>Node 作为中间服务接入前后端之间，完成类似 nginx 代理的功能。（没错，万能的前端具备这样的能力）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以express举例，就那么几行</span><br><span class="line">&#x2F;&#x2F; 代理</span><br><span class="line">var proxy &#x3D; require(&#39;http-proxy-middleware&#39;);</span><br><span class="line">app.use(&#39;*&#39;, proxy(&#39;&#x2F;**&#39;, &#123;</span><br><span class="line">  target: &#39;http:&#x2F;&#x2F;192.168.1.65:9188&#39;,</span><br><span class="line">  changeOrigin: true,</span><br><span class="line">  onProxyReq: function (proxyReq, req, res) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  onProxyRes: function (proxyRes, req, res) &#123;</span><br><span class="line">    proxyRes.headers[&#39;set-cookie&#39;]</span><br><span class="line">  &#125;,</span><br><span class="line">  cookieDomainRewrite: &#123;</span><br><span class="line">    &#39;9niutest.com&#39;: &#39;127.0.0.1&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>随着产线的扩大，后台的服务基本就是产线的个数，不会因为以前不优雅的配置导致双倍的维护和运行成本。<br><img src="/legacy/2018/01/25/node-proxy/2.png" class="" title="未来的架构"></p><h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p><a href="https://stackoverflow.com/questions/25207333/socket-hang-up-error-with-nodejs/25651651#25651651" target="_blank" rel="noopener">代理服务器成功代理，但目标服务器没有响应</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git merge 分支遇到的奇葩现象</title>
      <link href="/legacy/2018/01/24/git-branch/"/>
      <url>/legacy/2018/01/24/git-branch/</url>
      
        <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>切换分支的时候，A 分支新建的文件居然被 B 分支历史文件夹同步了。</p><h1 id="重现步骤"><a href="#重现步骤" class="headerlink" title="重现步骤"></a>重现步骤</h1><img src="/legacy/2018/01/24/git-branch/1.png" class="" title="1.master 目录结构"><img src="/legacy/2018/01/24/git-branch/2.png" class="" title="2.分别创建test1，test2"><img src="/legacy/2018/01/24/git-branch/3-1.png" class="" title="3.test1上，剪切src目录文件到dist中"><img src="/legacy/2018/01/24/git-branch/3-2.png" class="" title="4.提交"><img src="/legacy/2018/01/24/git-branch/4-1.png" class="" title="5.test2上，修改src下文件"><img src="/legacy/2018/01/24/git-branch/4-2.png" class="" title="6.提交"><img src="/legacy/2018/01/24/git-branch/5-1.png" class="" title="7.切换到test1，merge test2的修改"><p><strong>神奇的一 B：test2 中 src 的修改，居然到了 test1 的 dist 中提现出来</strong><br><img src="/legacy/2018/01/24/git-branch/5-2.png" class="" title="8.神奇的一B"></p><h1 id="大致原因"><a href="#大致原因" class="headerlink" title="大致原因"></a>大致原因</h1><img src="/legacy/2018/01/24/git-branch/6.png" class="" title="流程"><p>官方介绍：<a href="https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并" target="_blank" rel="noopener">git branch 介绍</a><br>如图所示，C3&amp;C4 是由 C2 开始，并且根据不同的需求做修改。当 test1 和 test2 合并的时候，test2 并不是 test1 的父级，所以会出现<strong>‘recursive’ strategy</strong>策略的处理。<br>这个策略，将 C3，C4 作为两个副本快照，和他们公共的父节点 C2 做策略合并（three way merge）。<br>值得注意的是，C3 上做剪切动作时，git status 是<strong>rename</strong>，估计是这个原因 merge 后，会把 c4 的修改同步到 dist 的文件中。<br><img src="/legacy/2018/01/24/git-branch/7.png" class="" title="rename"></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb 快速入门</title>
      <link href="/legacy/2017/11/15/mongodb-quickstart/"/>
      <url>/legacy/2017/11/15/mongodb-quickstart/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2017/11/15/mongodb-quickstart/mongodb.jpg" class=""><h1 id="什么是-mongodb"><a href="#什么是-mongodb" class="headerlink" title="什么是 mongodb"></a><a href="https://www.mongodb.com" target="_blank" rel="noopener">什么是 mongodb</a></h1><p>有哪些好处？（外面是这样流传的）</p><ol><li>对比传统主流数据库，比较‘新’。</li><li>非关系数据库。没有结构的约束，扩展，速度会更‘快’</li><li>适合填坑的你…</li></ol><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ol><li><a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">mongodb 下载</a></li><li>解压 mongo 安装包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf .&#x2F;mongodb-linux-x86_64-3.4.10.tgz</span><br></pre></td></tr></table></figure></li><li>配置环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MONGO_HOME&#x3D;&#x2F;root&#x2F;mydata&#x2F;mongodb-linux-x86_64-3.4.10</span><br></pre></td></tr></table></figure></li><li><p><a href="https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes/#start-mongod-processes" target="_blank" rel="noopener">开启 mongod 服务</a></p><img src="/legacy/2017/11/15/mongodb-quickstart/mongod.png" class=""><p>注意这是非守护进程方式，一关后面就连接不上了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@izj6c8pmxwulw3fkf18zqqz mydata]# mongo</span><br><span class="line">MongoDB shell version v3.4.10</span><br><span class="line">connecting to: mongodb:&#x2F;&#x2F;127.0.0.1:27017</span><br><span class="line">2018-05-31T11:30:51.137+0800 W NETWORK  [thread1] Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused</span><br><span class="line">2018-05-31T11:30:51.137+0800 E QUERY    [thread1] Error: couldn&#39;t connect to server 127.0.0.1:27017, connection attempt failed :</span><br><span class="line">connect@src&#x2F;mongo&#x2F;shell&#x2F;mongo.js:237:13</span><br><span class="line">@(connect):1:6</span><br><span class="line">exception: connect failed</span><br></pre></td></tr></table></figure></li><li><p><a href="https://docs.mongodb.com/manual/mongo/" target="_blank" rel="noopener">链接 mongo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@izj6c8pmxwulw3fkf18zqqz mydata]# mongo</span><br><span class="line">MongoDB shell version v3.4.10</span><br><span class="line">connecting to: mongodb:&#x2F;&#x2F;127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.4.10</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="配置-mongod"><a href="#配置-mongod" class="headerlink" title="配置 mongod"></a>配置 mongod</h1><h2 id="简单的一些修改"><a href="#简单的一些修改" class="headerlink" title="简单的一些修改"></a>简单的一些修改</h2><ol><li>数据库路径<br>路径文件夹需要提前建好</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath &#x2F;your path</span><br></pre></td></tr></table></figure><ol start="2"><li>日志文件路径</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --logpath &#x2F;your path</span><br></pre></td></tr></table></figure><ol start="3"><li>修改端口 port</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --port 12345</span><br></pre></td></tr></table></figure><h2 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h2><ol><li>shutdownServer</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.shutdownServer()</span><br><span class="line">server should be down...</span><br><span class="line">2018-05-31T11:40:56.277+0800 I NETWORK  [thread1] trying reconnect to 127.0.0.1:27017 (127.0.0.1) failed</span><br><span class="line">2018-05-31T11:40:56.277+0800 W NETWORK  [thread1] Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused</span><br><span class="line">2018-05-31T11:40:56.277+0800 I NETWORK  [thread1] reconnect 127.0.0.1:27017 (127.0.0.1) failed failed</span><br></pre></td></tr></table></figure><ol start="2"><li>kill</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izj6c8pmxwulw3fkf18zqqz ~]# ps -aux |grep mongo</span><br><span class="line">root     12185  0.7  3.9 942148 40512 pts&#x2F;1    Sl+  11:43   0:00 mongod</span><br><span class="line">root     12212  0.0  0.0 112660   972 pts&#x2F;2    R+   11:44   0:00 grep --color&#x3D;auto mongo</span><br><span class="line">[root@izj6c8pmxwulw3fkf18zqqz ~]# kill -9 12185</span><br></pre></td></tr></table></figure><ol start="3"><li>shutdown</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izj6c8pmxwulw3fkf18zqqz ~]# mongod --shutdown</span><br><span class="line">killing process with pid: 12213</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li><p>指定配置文件方式<br>指定配置文件 –config <filename>, -f <filename></p></li><li><p>编写配置文件（YAML 范式）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 守护开启</span><br><span class="line">processManagement:</span><br><span class="line">  fork: true</span><br><span class="line"># 系统日志</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &quot;&#x2F;root&#x2F;mydata&#x2F;mongo&#x2F;mongod.log&quot;</span><br><span class="line">  logAppend: true</span><br><span class="line"># 数据库存储位置</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &quot;&#x2F;root&#x2F;mydata&#x2F;mongo&#x2F;data&#x2F;db&quot;</span><br><span class="line"># 安全</span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br></pre></td></tr></table></figure><h2 id="守护配置"><a href="#守护配置" class="headerlink" title="守护配置"></a>守护配置</h2><p>参考配置文件，如果你没有配置，就–fork 开启守护模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izj6c8pmxwulw3fkf18zqqz ~]# mongod -f &#x2F;root&#x2F;mydata&#x2F;mongo&#x2F;conf&#x2F;mongod.conf</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 12343</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><ol><li>添加权限用户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.createUser(&#123;</span><br><span class="line">...     user:&quot;xxx_dba&quot;,</span><br><span class="line">...     pwd:&quot;xxxxxx&quot;,</span><br><span class="line">...     roles:[&#123;</span><br><span class="line">...         role:&quot;userAdminAnyDatabase&quot;,</span><br><span class="line">...         db:&quot;admin&quot;</span><br><span class="line">...     &#125;]</span><br><span class="line">... &#125;)</span><br><span class="line">Successfully added user: &#123;</span><br><span class="line">&quot;user&quot; : &quot;eminoda_dba&quot;,</span><br><span class="line">&quot;roles&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;role&quot; : &quot;userAdminAnyDatabase&quot;,</span><br><span class="line">&quot;db&quot; : &quot;admin&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>开启权限模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f &#x2F;root&#x2F;mydata&#x2F;mongo&#x2F;conf&#x2F;mongod.conf --auth</span><br></pre></td></tr></table></figure><ol start="3"><li>按照权限操作不同功能</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; show dbs</span><br><span class="line">2018-05-31T14:26:11.129+0800 E QUERY    [thread1] Error: listDatabases failed:&#123;</span><br><span class="line">&quot;ok&quot; : 0,</span><br><span class="line">&quot;errmsg&quot; : &quot;not authorized on admin to execute command &#123; listDatabases: 1.0 &#125;&quot;,</span><br><span class="line">&quot;code&quot; : 13,</span><br><span class="line">&quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125; :</span><br><span class="line">_getErrorWithCode@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:25:13</span><br><span class="line">Mongo.prototype.getDBs@src&#x2F;mongo&#x2F;shell&#x2F;mongo.js:62:1</span><br><span class="line">shellHelper.show@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:781:19</span><br><span class="line">shellHelper@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:671:15</span><br><span class="line">@(shellhelp2):1:1</span><br><span class="line">&gt; db.auth(&#39;xxx_dba&#39;,&#39;xxxxxx&#39;)</span><br><span class="line">1</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin  0.000GB</span><br><span class="line">local  0.000GB</span><br></pre></td></tr></table></figure><ol start="4"><li>显示用户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; show users</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : &quot;admin.xxx_dba&quot;,</span><br><span class="line">&quot;user&quot; : &quot;xxx_dba&quot;,</span><br><span class="line">&quot;db&quot; : &quot;admin&quot;,</span><br><span class="line">&quot;roles&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;role&quot; : &quot;userAdminAnyDatabase&quot;,</span><br><span class="line">&quot;db&quot; : &quot;admin&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ol><li>显示当前库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">test</span><br></pre></td></tr></table></figure><ol start="2"><li>切换（添加）数据库<br>后续 insert 一条数据，新增数据库就会出现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use eminoda_db</span><br><span class="line">switched to db eminoda_db</span><br></pre></td></tr></table></figure><ol start="3"><li>显示数据库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin       0.000GB</span><br><span class="line">eminoda_db  0.000GB</span><br><span class="line">local       0.000GB</span><br></pre></td></tr></table></figure><ol start="4"><li>删除数据库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">eminoda_db</span><br><span class="line">&gt; db.dropDatabase()</span><br><span class="line">&#123; &quot;dropped&quot; : &quot;eminoda_db&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; show dbs</span><br><span class="line">admin  0.000GB</span><br><span class="line">local  0.000GB</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><ol><li>增</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.user.insertOne(&#123;</span><br><span class="line">    name:&#39;eminoda&#39;,</span><br><span class="line">    age:28</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>删</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.user.deleteOne(&#123;</span><br><span class="line">    name:&#39;eminoda&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>改</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.user.updateMany(&#123;</span><br><span class="line">    name:&#39;eminoda&#39;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    $set:&#123;</span><br><span class="line">        age:28</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>查</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 条件判断</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    age:&#123;</span><br><span class="line">        $gt:28</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    $or:[&#123;</span><br><span class="line">        name:&#39;zhang3&#39;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        age:28</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="帮助资料（基本都来自官网）"><a href="#帮助资料（基本都来自官网）" class="headerlink" title="帮助资料（基本都来自官网）"></a>帮助资料（基本都来自官网）</h1><ul><li><a href="https://docs.mongodb.com/manual/reference/program/mongo/#bin.mongo" target="_blank" rel="noopener">mongo</a></li><li><a href="https://docs.mongodb.com/manual/reference/program/mongod/#bin.mongod" target="_blank" rel="noopener">mongod</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes" target="_blank" rel="noopener">管理 mongod 进程</a></li><li><a href="https://docs.mongodb.com/manual/administration/configuration/" target="_blank" rel="noopener">mongod 配置-关于启动运行</a></li><li><a href="https://docs.mongodb.com/manual/reference/configuration-options/index.html" target="_blank" rel="noopener">mongod 配置文件详解</a></li><li><a href="https://docs.mongodb.com/manual/security/" target="_blank" rel="noopener">security 目录</a></li><li><a href="https://docs.mongodb.com/manual/reference/built-in-roles" target="_blank" rel="noopener">roles 角色介绍</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/enable-authentication/" target="_blank" rel="noopener">创建一个授权用户</a></li><li><a href="https://www.cnblogs.com/shiyiwen/p/5552750.html" target="_blank" rel="noopener">创建 auth，基本够用了</a></li><li><a href="https://docs.mongodb.com/manual/reference/command/nav-administration/" target="_blank" rel="noopener">db 相关操作</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/query-documents/#additional-query-tutorials" target="_blank" rel="noopener">query</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>[mongodb vs mysql]<a href="https://blog.panoply.io/mongodb-and-mysql" target="_blank" rel="noopener">https://blog.panoply.io/mongodb-and-mysql</a> &gt; <a href="https://www.zhihu.com/question/20059632" target="_blank" rel="noopener">MongoDB 等 NoSQL 与关系型数据库相比，有什么优缺点及适用场景？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同一环境配置多个 java 版本</title>
      <link href="/legacy/2017/10/23/java-version-change/"/>
      <url>/legacy/2017/10/23/java-version-change/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>测试环境后台 java 测试环境是 java1.7，而因为要安装 jenkins 集成测试，配置新的 tomcat，最低环境需要 1.8。但要确保不影响测试原有 Java 环境。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>修改 etc/profile 文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 新增加java1.8的配置</span><br><span class="line">export JAVA_HOME8&#x3D;&#x2F;mydata&#x2F;jdk1.8.0_144&#x2F;bin</span><br></pre></td></tr></table></figure><ol start="2"><li>修改 tomcat catalina.sh，指定 java 环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># OS specific support.  $var _must_ be set to either true or false.</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;mydata&#x2F;jdk1.8.0_144</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;mydata&#x2F;jdk1.8.0_144</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Java 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 常用命令</title>
      <link href="/legacy/2017/07/28/linux-command/"/>
      <url>/legacy/2017/07/28/linux-command/</url>
      
        <content type="html"><![CDATA[<p>不是专业运维，有时候操作服务器也是烦的一笔。记录几个常用命令，基本日常生活够用了。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><a href="https://baike.baidu.com/item/Netstat" target="_blank" rel="noopener">netstat</a></h2><blockquote><p>Netstat 是在内核中访问网络连接状态及其相关信息的程序，它能提供 TCP 连接，TCP 和 UDP 监听，进程内存管理的相关报告</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有 socket，包括正在监听的。</td></tr><tr><td>-c</td><td>每隔 1 秒就重新显示一遍，直到用户中断它。</td></tr><tr><td>-i</td><td>显示所有网络接口的信息，格式“netstat -i”。</td></tr><tr><td>-n</td><td>以网络 IP 地址代替名称，显示出网络连接情形。</td></tr><tr><td>-r</td><td>显示核心路由表，格式同“route -e”。</td></tr><tr><td>-t</td><td>显示 TCP 协议的连接情况</td></tr><tr><td>-u</td><td>显示 UDP 协议的连接情况。</td></tr><tr><td>-v</td><td>显示正在进行的工作。</td></tr><tr><td>-p</td><td>显示建立相关连接的程序名和 PID。</td></tr><tr><td>-b</td><td>显示在创建每个连接或侦听端口时涉及的可执行程序。</td></tr><tr><td>-e</td><td>显示以太网统计。此选项可以与 -s 选项结合使用。</td></tr><tr><td>-f</td><td>显示外部地址的完全限定域名(FQDN)。</td></tr><tr><td>-o</td><td>显示与每个连接相关的所属进程 ID。</td></tr><tr><td>-s</td><td>显示每个协议的统计。</td></tr><tr><td>-x</td><td>显示 NetworkDirect 连接、侦听器和共享端点。</td></tr><tr><td>-y</td><td>显示所有连接的 TCP 连接模板。无法与其他选项结合使用。</td></tr></tbody></table><p>举例：显示所有 tcp，udp 的监听中的 ip 信息，包含程序名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -alptun |grep nginx</span><br></pre></td></tr></table></figure><p>备注：如果非 0.0.0.0:port 而是 ip:port，确认下 nginx 下 server 中 listen 数值<br><img src="/legacy/2017/07/28/linux-command/1.png" class="" title="nginx显示0.0.0.0和ip的区别"></p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a><a href="http://www.cnblogs.com/wangkangluo1/archive/2011/09/23/2185938.html" target="_blank" rel="noopener">ps</a></h2><p>查看进程的命令</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-A</td><td>显示所有进程（等价于-e）(utility)</td></tr><tr><td>-a</td><td>显示一个终端的所有进程，除了会话引线</td></tr><tr><td>-N</td><td>忽略选择。</td></tr><tr><td>-d</td><td>显示所有进程，但省略所有的会话引线(utility)</td></tr><tr><td>-x</td><td>显示没有控制终端的进程，同时显示各个命令的具体路径。dx 不可合用。（utility）</td></tr><tr><td>-p</td><td>pid 进程使用 cpu 的时间</td></tr><tr><td>-u</td><td>uid or username 选择有效的用户 id 或者是用户名</td></tr><tr><td>-g</td><td>gid or groupname 显示组的所有进程。</td></tr><tr><td>U</td><td>username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)</td></tr><tr><td>-f</td><td>全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.</td></tr><tr><td>-l</td><td>长格式（有 F,wchan,C 等字段）</td></tr><tr><td>-j</td><td>作业格式</td></tr><tr><td>-o</td><td>用户自定义格式。</td></tr><tr><td>v</td><td>以虚拟存储器格式显示</td></tr><tr><td>s</td><td>以信号格式显示</td></tr><tr><td>-m</td><td>显示所有的线程</td></tr><tr><td>-H</td><td>显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）</td></tr><tr><td>e</td><td>命令之后显示环境（如：ps -d e; ps -a e）(utility)</td></tr><tr><td>h</td><td>不显示第一行</td></tr></tbody></table><p>举例：列出特定进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps aux |grep node</span><br><span class="line">USER PID    %CPU    %MEM    VSZ     RSS     TTY     STAT    START   TIME    COMMAND</span><br><span class="line">root 1819   0.0     0.4     968256  36988   ?       Sl      May16   0:04    &#x2F;mydata&#x2F;node-v4.4.1&#x2F;bin&#x2F;node &#x2F;usr&#x2F;share&#x2F;nodeProject&#x2F;com.cfniu.www&#x2F;bin&#x2F;www.js</span><br><span class="line">USER: 行程拥有者</span><br><span class="line">PID: pid</span><br><span class="line">%CPU: 占用的 CPU 使用率</span><br><span class="line">%MEM: 占用的记忆体使用率</span><br><span class="line">VSZ: 占用的虚拟记忆体大小</span><br><span class="line">RSS: 占用的记忆体大小</span><br><span class="line">TTY: 终端的次要装置号码 (minor device number of tty)</span><br></pre></td></tr></table></figure><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p><a href="https://curl.haxx.se/docs/httpscripting.html" target="_blank" rel="noopener">curl api</a></p><h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/" target="_blank" rel="noopener">ulimit</a></h2><blockquote><p>通过一些参数选项来管理不同种类的系统资源</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-H</td><td>设置硬资源限制.</td></tr><tr><td>-S</td><td>设置软资源限制.</td></tr><tr><td>-a</td><td>显示当前所有的资源限制.</td></tr><tr><td>-c</td><td>size:设置 core 文件的最大值.单位:blocks</td></tr><tr><td>-d</td><td>size:设置数据段的最大值.单位:kbytes</td></tr><tr><td>-f</td><td>size:设置创建文件的最大值.单位:blocks</td></tr><tr><td>-l</td><td>size:设置在内存中锁定进程的最大值.单位:kbytes</td></tr><tr><td>-m</td><td>size:设置可以使用的常驻内存的最大值.单位:kbytes</td></tr><tr><td>-n</td><td>size:设置内核可以同时打开的文件描述符的最大值.单位:n</td></tr><tr><td>-p</td><td>size:设置管道缓冲区的最大值.单位:kbytes</td></tr><tr><td>-s</td><td>size:设置堆栈的最大值.单位:kbytes</td></tr><tr><td>-t</td><td>size:设置 CPU 使用时间的最大上限.单位:seconds</td></tr><tr><td>-v</td><td>size:设置虚拟内存的最大值.单位:kbytes</td></tr><tr><td>-u</td><td>&lt;程序数目&gt; 　用户最多可开启的程序数目</td></tr></tbody></table><p>举例：nginx: [warn] 65536 worker_connections exceed open file resource limit: 65535</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp18tya24l2k7vs6b7j4Z ~]# nginx</span><br><span class="line">nginx: [warn] 65536 worker_connections exceed open file resource limit: 65535</span><br><span class="line"># 查询现在文件打开最大值</span><br><span class="line">[root@iZbp18tya24l2k7vs6b7j4Z ~]# ulimit -n</span><br><span class="line">65535</span><br><span class="line"># 重新设置</span><br><span class="line">[root@iZbp18tya24l2k7vs6b7j4Z ~]# ulimit -n 65536</span><br><span class="line">[root@iZbp18tya24l2k7vs6b7j4Z ~]# ulimit -n</span><br><span class="line">65536</span><br></pre></td></tr></table></figure><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a><a href="http://www.runoob.com/linux/linux-comm-wc.html" target="_blank" rel="noopener">wc</a></h2><blockquote><p>会从标准输入设备读取数据。</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c –bytes –chars</td><td>只显示 Bytes 数</td></tr><tr><td>-l –lines</td><td>只显示行数</td></tr><tr><td>-w –words</td><td>只显示字数</td></tr></tbody></table><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 操作系统内核信息</span><br><span class="line">[root@iZ2365bvzwbZ ~]# uname -a</span><br><span class="line">Linux iZ2365bvzwbZ 2.6.32-696.23.1.el6.x86_64 #1 SMP Tue Mar 13 22:44:18 UTC 2018 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br><span class="line"></span><br><span class="line"># 操作系统版本信息</span><br><span class="line">[root@iZ2365bvzwbZ ~]# cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 2.6.32-696.23.1.el6.x86_64 (mockbuild@x86-01.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Mar 13 22:44:18 UTC 2018</span><br><span class="line"></span><br><span class="line"># 系统cpu信息</span><br><span class="line">[root@iZbp17s23bov6rawl02chjZ ~]# cat &#x2F;proc&#x2F;cpuinfo</span><br><span class="line">[root@iZbp17s23bov6rawl02chjZ ~]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;processor&quot;| wc -l</span><br><span class="line">4 &#x2F;&#x2F;4个逻辑核</span><br><span class="line"># 每个cpu逻辑核数</span><br><span class="line">[root@iZbp17s23bov6rawl02chjZ ~]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br><span class="line">2 &#x2F;&#x2F;每个cpu有2个物理核</span><br><span class="line"># 物理cpu个数</span><br><span class="line">[root@iZbp17s23bov6rawl02chjZ ~]# cat &#x2F;proc&#x2F;cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br><span class="line">1 &#x2F;&#x2F;1个物理cpu</span><br><span class="line"></span><br><span class="line"># 操作系统发行版信息</span><br><span class="line">[root@iZ2365bvzwbZ ~]# cat &#x2F;etc&#x2F;issue</span><br><span class="line">CentOS release 6.8 (Final)</span><br><span class="line">Kernel \r on an \m</span><br><span class="line"></span><br><span class="line"># bit类型</span><br><span class="line">[root@iZ2365bvzwbZ ~]# getconf LONG_BIT</span><br><span class="line">64</span><br><span class="line">You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/YangJieCheng/p/5907166.html" target="_blank" rel="noopener">https://www.cnblogs.com/YangJieCheng/p/5907166.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 将本地项目上传到服务器</title>
      <link href="/legacy/2017/06/13/git-init/"/>
      <url>/legacy/2017/06/13/git-init/</url>
      
        <content type="html"><![CDATA[<h2 id="已有项目如何-git-版本控制"><a href="#已有项目如何-git-版本控制" class="headerlink" title="已有项目如何 git 版本控制"></a>已有项目如何 git 版本控制</h2><h3 id="参考-gitlab"><a href="#参考-gitlab" class="headerlink" title="参考 gitlab"></a>参考 gitlab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@192.168.1.99:niu_front&#x2F;fanfan.git</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信JS-SDK开发中的问题</title>
      <link href="/legacy/2017/03/15/webcat-problem-collection/"/>
      <url>/legacy/2017/03/15/webcat-problem-collection/</url>
      
        <content type="html"><![CDATA[<p>微信社交目前是企业赚取用户流量不可缺少的一环，前端开发多多少少都要涉及一些。但是其中的坑真是要跪倒多少小朋友，你文档就不能搞搞好。看的心累。以下记录一些踩坑经验</p><h2 id="分享图片显示不出？"><a href="#分享图片显示不出？" class="headerlink" title="分享图片显示不出？"></a>分享图片显示不出？</h2><ol><li>分享图片过大，请尽可能的小。几百 kb 部分手机分享出去显示不全（建议几十 kb）</li><li>分享描述文案字数过多。（建议 20 字左右）</li></ol><h2 id="分享图片的-ImgUrl-的请求头包含-WeChat"><a href="#分享图片的-ImgUrl-的请求头包含-WeChat" class="headerlink" title="分享图片的 ImgUrl 的请求头包含 WeChat"></a>分享图片的 ImgUrl 的请求头包含 WeChat</h2><p>可能你的服务器用了 nginx，对不同端做了拦截分流，请别忘了加这个 userAgent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( $http_user_agent !~* &quot;(Mobile|Android|iPad|iPhone|iPod|WeChat|BlackBerry|Windows Phone)&quot; ) &#123;</span><br><span class="line">  rewrite ^&#x2F; http:&#x2F;&#x2F;www.xxx.com? last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁用微信返回"><a href="#禁用微信返回" class="headerlink" title="禁用微信返回"></a>禁用微信返回</h2><img src="/legacy/2017/03/15/webcat-problem-collection/inhibit-header.png" class=""><p>图上有个返回 button，可以做隐藏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(null , null , window.location.href),</span><br><span class="line">window.onpopstate &#x3D; function(e) &#123;</span><br><span class="line">    history.go(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用-sdk-中生成的-signature-签名不正确"><a href="#调用-sdk-中生成的-signature-签名不正确" class="headerlink" title="调用 sdk 中生成的 signature 签名不正确"></a>调用 sdk 中生成的 signature 签名不正确</h2><ol><li><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign" target="_blank" rel="noopener">线上验证工具</a></li><li>参数说明</li></ol><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>noncestr</td><td>随机字符串</td></tr><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>url</td><td>当前网页的 URL，<strong>不包含#及其后面部分</strong></td></tr><tr><td>jsapi_ticket</td><td>票据</td></tr></tbody></table><h2 id="SPA-单页面微信分享验证失败"><a href="#SPA-单页面微信分享验证失败" class="headerlink" title="SPA 单页面微信分享验证失败"></a>SPA 单页面微信分享验证失败</h2><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">文档中有涉及，但是你懂的</a><br><img src="/legacy/2017/03/15/webcat-problem-collection/spa.png" class=""></p><p>原因估计是因为单页面应用基本采用 hash 模式（#），然后微信不认为你浏览器地址发生了变化。然后在跳转页面路由的时候，记录的还是上一个页面的 url，导致<strong>config 接口注入权限验证配置</strong>失败。</p><p>具体解决方法（提供 vue 解决方案）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供一个路由拦截</span></span><br><span class="line">routers.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未记录过</span></span><br><span class="line">    <span class="keyword">if</span> (!store.state.router.beforeUrl) &#123;</span><br><span class="line">        <span class="comment">// 这里处理ios手机访问首页xxx/，router跳转为xxx/#/的问题</span></span><br><span class="line">        store.state.router.beforeUrl = <span class="keyword">from</span> &amp;&amp; <span class="keyword">from</span>.path === <span class="string">'/'</span> ? <span class="built_in">window</span>.location.href.split(<span class="string">'#'</span>)[<span class="number">0</span>] : <span class="built_in">window</span>.location.href;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成signature中url的参数处理</span></span><br><span class="line"><span class="comment">// 安卓可能会识别url变化，所以安卓浏览器直接使用原生地址</span></span><br><span class="line">utilService.getDeviceType() !== <span class="string">'android'</span> ? store.state.router.beforeUrl : <span class="built_in">window</span>.location.href</span><br></pre></td></tr></table></figure><h2 id="可能同样的分享代码，会出现分享朋友圈-error，但是分享朋友-ok。"><a href="#可能同样的分享代码，会出现分享朋友圈-error，但是分享朋友-ok。" class="headerlink" title="可能同样的分享代码，会出现分享朋友圈 error，但是分享朋友 ok。"></a>可能同样的分享代码，会出现分享朋友圈 error，但是分享朋友 ok。</h2><p>可能是我们代码问题，但也请改个良辰吉日再试试，说不定又好了。亲测过</p><h2 id="errMsg-“onMenuShareAppMessage-fail-the-permission-value-is-offline-verifying”"><a href="#errMsg-“onMenuShareAppMessage-fail-the-permission-value-is-offline-verifying”" class="headerlink" title="errMsg: “onMenuShareAppMessage:fail, the permission value is offline verifying”"></a>errMsg: “onMenuShareAppMessage:fail, the permission value is offline verifying”</h2><p>先确定 config 参数正常的情况下，查看公众号等平台分享等功能是否有权限。可能账号权限过期，运营等迁移公众号主体等操作影响到了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信开发指南</title>
      <link href="/legacy/2017/02/16/webcat-helper/"/>
      <url>/legacy/2017/02/16/webcat-helper/</url>
      
        <content type="html"><![CDATA[<img src="/legacy/2017/02/16/webcat-helper/start.png" class=""><h2 id="为什么要写这个？"><a href="#为什么要写这个？" class="headerlink" title="为什么要写这个？"></a>为什么要写这个？</h2><p>反正和微信相关开发，我是怕了。到现在都没有明白什么是公众号，什么是服务号，开放平台和公众平台有啥区别？<br>官网文档有时候个别地址还 404；<br>由于自己没有公司账号权限，每次还要让他们运营扫码登录，烦的一笔；<br>所以特别记录下，方便自己和大家查阅。有什么不对的，请 qq 我改正:wrench:</p><h2 id="接口文档地址"><a href="#接口文档地址" class="headerlink" title="接口文档地址"></a>接口文档地址</h2><ul><li><a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">公众平台 https://mp.weixin.qq.com</a></li><li><a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">开放平台 https://open.weixin.qq.com</a></li><li><a href="https://mp.weixin.qq.com/wiki" target="_blank" rel="noopener">公众平台 doc</a></li><li><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">开发平台 doc</a></li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">JS-SDK doc</a></li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">网页授权 doc</a></li></ul><h2 id="公众平台设置"><a href="#公众平台设置" class="headerlink" title="公众平台设置"></a>公众平台设置</h2><h3 id="设置开发者权限"><a href="#设置开发者权限" class="headerlink" title="设置开发者权限"></a>设置开发者权限</h3><p>如果你没有这样做再使用微信客户端是获取不到相关信息的<br><img src="/legacy/2017/02/16/webcat-helper/auth-1.png" class="" title="左侧开发菜单"><br><img src="/legacy/2017/02/16/webcat-helper/auth-2.png" class="" title="web开发者工具"><br><img src="/legacy/2017/02/16/webcat-helper/auth-3.png" class="" title="绑定相关微信号"></p><h3 id="相关域名设置"><a href="#相关域名设置" class="headerlink" title="相关域名设置"></a>相关域名设置</h3><img src="/legacy/2017/02/16/webcat-helper/domain-1.png" class="" title="授权入口"><img src="/legacy/2017/02/16/webcat-helper/domain-2.png" class="" title="核心3种授权方式"><ol><li><p>业务域名<br>设置业务域名后，在微信内访问该域名下页面时，不会被<strong>重新排版</strong>。（比如：如下图一些非法不安全的提示。）</p><img src="/legacy/2017/02/16/webcat-helper/domain-3.png" class="" title="业务域名"></li><li><p>JS 调用域名（JSSDK）<br>你在哪些域名下，可以调用微信的 SDK，使用微信提供的接口，友情提示：<strong>可设置顶级域名</strong></p><img src="/legacy/2017/02/16/webcat-helper/domain-4.png" class="" title="js-sdk安全域名调用"></li><li><p>网页授权域名<br><strong>貌似不能设置顶级域名，自行做页面中间跳转</strong>（由于域名固定，所以只能自己写重定向地址完成特殊需求跳转）</p><img src="/legacy/2017/02/16/webcat-helper/domain-5.png" class="" title="回调网页授权"></li><li><p>设置白名单<br>开发&gt;基本设置&gt;设置白名单，不然微信不会平白无故接受你的请求</p><img src="/legacy/2017/02/16/webcat-helper/domain-6.png" class="" title="white list"></li></ol><h3 id="JSSDK-使用步骤"><a href="#JSSDK-使用步骤" class="headerlink" title="JSSDK 使用步骤"></a>JSSDK 使用步骤</h3><ol><li>绑定域名<br>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS 接口安全域名”。<img src="/legacy/2017/02/16/webcat-helper/domain-7.png" class="" title="你看坑不？和上面JS调用域名有什么区别，我好烦躁"><img src="/legacy/2017/02/16/webcat-helper/domain-8.png" class="" title="white list"></li><li>引入 JS 文件<br><a href="http://res.wx.qq.com/open/js/jweixin-1.2.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.2.0.js</a></li><li>通过 config 接口注入权限验证配置（附录有 Q&amp;A）<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">config 配置</a></li></ol><h2 id="开放平台设置"><a href="#开放平台设置" class="headerlink" title="开放平台设置"></a>开放平台设置</h2><h3 id="设置回调域名"><a href="#设置回调域名" class="headerlink" title="设置回调域名"></a>设置回调域名</h3><img src="/legacy/2017/02/16/webcat-helper/back-1.png" class="" title="进入网站应用"><img src="/legacy/2017/02/16/webcat-helper/back-2.png" class="" title="回调网页授权"><h2 id="授权方式地址"><a href="#授权方式地址" class="headerlink" title="授权方式地址"></a>授权方式地址</h2><h3 id="公众平台"><a href="#公众平台" class="headerlink" title="公众平台"></a><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">公众平台</a></h3><blockquote><p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a></p></blockquote><h3 id="开发平台（扫码）"><a href="#开发平台（扫码）" class="headerlink" title="开发平台（扫码）"></a><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">开发平台（扫码）</a></h3><blockquote><p><a href="https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a></p></blockquote><h3 id="参数说明（参考，具体-api-文档查阅）"><a href="#参数说明（参考，具体-api-文档查阅）" class="headerlink" title="参数说明（参考，具体 api 文档查阅）"></a>参数说明（参考，具体 api 文档查阅）</h3><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>appid</td><td>是</td><td>公众号的唯一标识</td></tr><tr><td>redirect_uri</td><td>是</td><td>授权后重定向的回调链接地址，<strong>请使用 urlEncode 对链接进行处理</strong></td></tr><tr><td>response_type</td><td>是</td><td>code</td></tr><tr><td>scope</td><td>是</td><td><strong>snsapi_base</strong> （不弹出授权页面，直接跳转，只能获取用户 openid），<strong>snsapi_userinfo</strong> （弹出授权页面，可通过 openid 拿到昵称、性别、所在地。并且，即使在未关注的情况下，只要用户授权，也能获取其信息）</td></tr><tr><td>state</td><td>否</td><td>重定向后会带上 state 参数，开发者可以填写 a-zA-Z0-9 的参数值，最多 128 字节</td></tr><tr><td>#wechat_redirect</td><td>是</td><td>无论直接打开还是做页面 302 重定向时候，必须带此参数</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 快速入门</title>
      <link href="/legacy/2017/02/09/git-quickstart/"/>
      <url>/legacy/2017/02/09/git-quickstart/</url>
      
        <content type="html"><![CDATA[<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ol><li><p>集中化的版本控制系统</p><img src="/legacy/2017/02/09/git-quickstart/1.png" class="" title="Subversion，CVS..."></li><li><p>分布式版本控制系统</p><img src="/legacy/2017/02/09/git-quickstart/2.png" class="" title="git"></li><li><p>区别</p><ul><li>无网络，用 svn，不能向数据库提交修改</li><li>控制文件方式<br>_ svn：随时间逐步增加<img src="/legacy/2017/02/09/git-quickstart/3.png" class="" title="Subversion，CVS...">_ git：快照流<img src="/legacy/2017/02/09/git-quickstart/4.png" class="" title="git"></li></ul></li><li><p>git 的三种状态</p><img src="/legacy/2017/02/09/git-quickstart/5.png" class="" title="git"></li></ol><h2 id="cli-基本操作"><a href="#cli-基本操作" class="headerlink" title="cli 基本操作"></a>cli 基本操作</h2><ol><li><p>服务器端创建项目</p><img src="/legacy/2017/02/09/git-quickstart/6.png" class="" title="Subversion，CVS..."></li><li><p>克隆项目</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shixinghao@SC-201611201637 MINGW64 &#x2F;e&#x2F;my_work&#x2F;github</span><br><span class="line">$ git clone git@github.com:eminoda&#x2F;hello-git.git</span><br><span class="line">Cloning into &#39;hello-git&#39;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (3&#x2F;3), done.</span><br></pre></td></tr></table></figure><ol start="3"><li>检查状态<br>已跟踪、未跟踪<img src="/legacy/2017/02/09/git-quickstart/7.png" class="" title="git"><img src="/legacy/2017/02/09/git-quickstart/8.png" class="" title="git"></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">$ git diff</span><br></pre></td></tr></table></figure><ol start="4"><li>提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#39;init&#39;</span><br><span class="line">[master 4618f45] init</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 index.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shixinghao@SC-201611201637 MINGW64 &#x2F;e&#x2F;my_work&#x2F;github&#x2F;hello-git (master)</span><br><span class="line">$ git commit -a -m &#39;init&#39;</span><br></pre></td></tr></table></figure></li><li><p>移除文件<br>提交区删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm index.txt</span><br><span class="line">$ git rm index.txt</span><br></pre></td></tr></table></figure><p>暂存区删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -f index.txt</span><br></pre></td></tr></table></figure></li><li><p>撤销<br>覆盖提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#39;initial commit&#39;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>撤销暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD 2.txt</span><br></pre></td></tr></table></figure><p>还原至上次提交版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- 2.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ol><li>新建分支<img src="/legacy/2017/02/09/git-quickstart/9.png" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch v1.0</span><br></pre></td></tr></table></figure></li><li>切换分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v1.0</span><br></pre></td></tr></table></figure></li><li><p>分支移动</p><img src="/legacy/2017/02/09/git-quickstart/10.png" class="" title="checkout到testing分支"><img src="/legacy/2017/02/09/git-quickstart/11.png" class="" title="分叉"></li><li><p>分支应用</p></li></ol><h3 id="合并-merge"><a href="#合并-merge" class="headerlink" title="合并 merge"></a>合并 merge</h3><pre><code>{% asset_img 12.png 开始 %}{% asset_img 13.png 处理新业务53 %}{% asset_img 14.png 提交53 %}{% asset_img 15.png 在主分支新建bug %}{% asset_img 16.png fix后merge到master %}{% asset_img 17.png 53继续进行 %}{% asset_img 18.png 53 merge到master %}</code></pre><h3 id="变基-rebase"><a href="#变基-rebase" class="headerlink" title="变基 rebase"></a>变基 rebase</h3><pre><code>{% asset_img 19.png start %}{% asset_img 20.png git rebase master %}{% asset_img 21.png git merge experiment %}</code></pre><h2 id="GUI-基本操作"><a href="#GUI-基本操作" class="headerlink" title="GUI 基本操作"></a>GUI 基本操作</h2><ol><li><p>clone</p><img src="/legacy/2017/02/09/git-quickstart/g1.png" class="" title="clone"><img src="/legacy/2017/02/09/git-quickstart/g2.png" class="" title="clone"></li><li><p>add/commit/ignore</p><img src="/legacy/2017/02/09/git-quickstart/g3.png" class="" title="git"><img src="/legacy/2017/02/09/git-quickstart/g4.png" class="" title="git"></li><li><p>branch</p><img src="/legacy/2017/02/09/git-quickstart/g5.png" class="" title="创建分支"><img src="/legacy/2017/02/09/git-quickstart/g6.png" class="" title="切换分支"><img src="/legacy/2017/02/09/git-quickstart/g7.png" class="" title="切换分支"><img src="/legacy/2017/02/09/git-quickstart/g8.png" class="" title="分支中修改文件提交"><img src="/legacy/2017/02/09/git-quickstart/g9.png" class="" title="比较目录变化"></li></ol><h2 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h2><ol><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git download</a></li><li><a href="https://tortoisegit.org/" target="_blank" rel="noopener">tortoiseGit download</a></li><li><a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="noopener">git 在线操作</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">git 中文文档</a></li></ol><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><ol><li><a href="https://github.com/eminoda" target="_blank" rel="noopener">github</a></li><li><a href="https://coding.net/" target="_blank" rel="noopener">coding</a></li><li><a href="https://code.csdn.net/" target="_blank" rel="noopener">csdn</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/legacy/2017/01/23/hello-world/"/>
      <url>/legacy/2017/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
